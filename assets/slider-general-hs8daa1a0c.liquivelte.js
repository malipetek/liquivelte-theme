import { SvelteComponent, init, safe_not_equal, create_component, claim_component, mount_component, transition_in, transition_out, destroy_component, space, claim_space, insert_hydration, detach, text, claim_text, empty, group_outros, check_outros, destroy_each, noop } from './liquivelte-svelte-hs532e1aa9.liquivelte.js';
import './framework7-liquivelte-hs5d6b599e.liquivelte.js';
import { Block_title } from './framework7-liquivelte-block-title-hs8daa1a0c.liquivelte.js';
import { Block } from './framework7-liquivelte-block-hs8daa1a0c.liquivelte.js';
import { Swiper_slide } from './framework7-liquivelte-swiper-slide-hs8daa1a0c.liquivelte.js';
import { Swiper_1 } from './framework7-liquivelte-swiper-hs8daa1a0c.liquivelte.js';

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/sections/slider-general/index.liquivelte generated by Svelte v3.50.0 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i];
	child_ctx[5] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[5] === 0,
		index: /*index*/ child_ctx[5] + 1,
		index0: /*index*/ child_ctx[5],
		last: /*index*/ child_ctx[5] === section.blocks.length - 1,
		rindex: section.blocks.length - /*index*/ child_ctx[5],
		rindex0: section.blocks.length - /*index*/ child_ctx[5] - 1,
		length: section.blocks.length
	};

	child_ctx[3] = constants_0;
	return child_ctx;
}

// (12:0) <BlockTitle      lec={lec} >
function create_default_slot_3(ctx) {
	let t;

	return {
		c() {
			t = text("With all controls");
		},
		l(nodes) {
			t = claim_text(nodes, "With all controls");
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (29:48) 
function create_if_block_2(ctx) {
	return { c: noop, l: noop, m: noop, d: noop };
}

// (27:48) 
function create_if_block_1(ctx) {
	return { c: noop, l: noop, m: noop, d: noop };
}

// (25:6) {#if block.type == 'image' }
function create_if_block(ctx) {
	return { c: noop, l: noop, m: noop, d: noop };
}

// (24:4) <SwiperSlide       lec={lec} >
function create_default_slot_2(ctx) {
	let t;

	function select_block_type(ctx, dirty) {
		if (/*block*/ ctx[2].type == 'image') return create_if_block;
		if (/*block*/ ctx[2].type == 'image-with-card') return create_if_block_1;
		if (/*block*/ ctx[2].type == 'image-with-card') return create_if_block_2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
		},
		l(nodes) {
			if (if_block) if_block.l(nodes);
			t = claim_space(nodes);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_hydration(target, t, anchor);
		},
		p: noop,
		d(detaching) {
			if (if_block) {
				if_block.d(detaching);
			}

			if (detaching) detach(t);
		}
	};
}

// (14:4) {#each  section.blocks as block, index   }
function create_each_block(ctx) {
	let swiperslide;
	let current;

	swiperslide = new Swiper_slide({
			props: {
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(swiperslide.$$.fragment);
		},
		l(nodes) {
			claim_component(swiperslide.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(swiperslide, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const swiperslide_changes = {};
			if (dirty & /*lec*/ 1) swiperslide_changes.lec = /*lec*/ ctx[0];

			if (dirty & /*$$scope*/ 64) {
				swiperslide_changes.$$scope = { dirty, ctx };
			}

			swiperslide.$set(swiperslide_changes);
		},
		i(local) {
			if (current) return;
			transition_in(swiperslide.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(swiperslide.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(swiperslide, detaching);
		}
	};
}

// (13:2) <Swiper  breakpoints="{breakpoints}"     lec={lec} >
function create_default_slot_1(ctx) {
	let each_1_anchor;
	let current;
	let each_value = section.blocks;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_hydration(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*lec, section*/ 1) {
				each_value = section.blocks;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (11:0) <Block      lec={lec} >
function create_default_slot(ctx) {
	let blocktitle;
	let t;
	let swiper;
	let current;

	blocktitle = new Block_title({
			props: {
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	swiper = new Swiper_1({
			props: {
				breakpoints,
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(blocktitle.$$.fragment);
			t = space();
			create_component(swiper.$$.fragment);
		},
		l(nodes) {
			claim_component(blocktitle.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(swiper.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(blocktitle, target, anchor);
			insert_hydration(target, t, anchor);
			mount_component(swiper, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const blocktitle_changes = {};
			if (dirty & /*lec*/ 1) blocktitle_changes.lec = /*lec*/ ctx[0];

			if (dirty & /*$$scope*/ 64) {
				blocktitle_changes.$$scope = { dirty, ctx };
			}

			blocktitle.$set(blocktitle_changes);
			const swiper_changes = {};
			if (dirty & /*lec*/ 1) swiper_changes.lec = /*lec*/ ctx[0];

			if (dirty & /*$$scope, lec*/ 65) {
				swiper_changes.$$scope = { dirty, ctx };
			}

			swiper.$set(swiper_changes);
		},
		i(local) {
			if (current) return;
			transition_in(blocktitle.$$.fragment, local);
			transition_in(swiper.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(blocktitle.$$.fragment, local);
			transition_out(swiper.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(blocktitle, detaching);
			if (detaching) detach(t);
			destroy_component(swiper, detaching);
		}
	};
}

function create_fragment(ctx) {
	let block;
	let current;

	block = new Block({
			props: {
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(block.$$.fragment);
		},
		l(nodes) {
			claim_component(block.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(block, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const block_changes = {};
			if (dirty & /*lec*/ 1) block_changes.lec = /*lec*/ ctx[0];

			if (dirty & /*$$scope, lec*/ 65) {
				block_changes.$$scope = { dirty, ctx };
			}

			block.$set(block_changes);
		},
		i(local) {
			if (current) return;
			transition_in(block.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(block.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(block, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { lec } = $$props;

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(0, lec = $$props.lec);
	};

	return [lec];
}

class Slider_general extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { lec: 0 });
	}
}

export { Slider_general };
