import { globals, element, space, claim_element, children, claim_space, detach, attr, src_url_equal, set_style, add_render_callback, insert_hydration, append_hydration, add_resize_listener, text, claim_text, listen, noop, destroy_each, tweened, identity, component_subscribe, binding_callbacks, SvelteComponent, init, safe_not_equal } from './liquivelte-svelte-hs623f7d73.liquivelte.js';
import { cachedLiquid } from './liquivelte-liquid-hs6dbc6cca.liquivelte.js';

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/sections/exploding-gallery.liquivelte generated by Svelte v3.50.0 */

const { window: window_1 } = globals;

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i];
	child_ctx[36] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[36] === 0,
		index: /*index*/ child_ctx[36] + 1,
		index0: /*index*/ child_ctx[36],
		last: /*index*/ child_ctx[36] === /*section*/ child_ctx[5].blocks.length - 1,
		rindex: /*section*/ child_ctx[5].blocks.length - /*index*/ child_ctx[36],
		rindex0: /*section*/ child_ctx[5].blocks.length - /*index*/ child_ctx[36] - 1,
		length: /*section*/ child_ctx[5].blocks.length
	};

	child_ctx[34] = constants_0;
	return child_ctx;
}

// (108:6) {#each  section.blocks as block, index  }
function create_each_block(ctx) {
	let div;
	let picture;
	let source0;
	let source0_srcset_value;
	let t0;
	let source1;
	let source1_srcset_value;
	let t1;
	let img;
	let img_src_value;
	let img_alt_value;
	let t2;
	let div_resize_listener;

	function div_elementresize_handler() {
		/*div_elementresize_handler*/ ctx[24].call(div, /*forloop*/ ctx[34]);
	}

	return {
		c() {
			div = element("div");
			picture = element("picture");
			source0 = element("source");
			t0 = space();
			source1 = element("source");
			t1 = space();
			img = element("img");
			t2 = space();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);
			picture = claim_element(div_nodes, "PICTURE", { class: true });
			var picture_nodes = children(picture);
			source0 = claim_element(picture_nodes, "SOURCE", { media: true, srcset: true });
			t0 = claim_space(picture_nodes);
			source1 = claim_element(picture_nodes, "SOURCE", { media: true, srcset: true });
			t1 = claim_space(picture_nodes);

			img = claim_element(picture_nodes, "IMG", {
				class: true,
				src: true,
				alt: true,
				style: true
			});

			picture_nodes.forEach(detach);
			t2 = claim_space(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(source0, "media", "(min-width:650px)");
			attr(source0, "srcset", source0_srcset_value = /*liquid*/ ctx[10].img_url(/*block*/ ctx[33].settings.image, 'x800'));
			attr(source1, "media", "(min-width:1200px)");
			attr(source1, "srcset", source1_srcset_value = /*liquid*/ ctx[10].img_url(/*block*/ ctx[33].settings.image, 'x800'));
			attr(img, "class", " svelte-12dbek");
			if (!src_url_equal(img.src, img_src_value = /*liquid*/ ctx[10].img_url(/*block*/ ctx[33].settings.image, 'x800'))) attr(img, "src", img_src_value);
			attr(img, "alt", img_alt_value = /*block*/ ctx[33].settings.image.alt);
			set_style(img, "width", "auto");
			attr(picture, "class", " svelte-12dbek");
			attr(div, "class", "image-container a svelte-12dbek");
			set_style(div, "--image-aspect-ratio", /*block*/ ctx[33].settings.image.aspect_ratio);
			add_render_callback(() => div_elementresize_handler.call(div));
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, picture);
			append_hydration(picture, source0);
			append_hydration(picture, t0);
			append_hydration(picture, source1);
			append_hydration(picture, t1);
			append_hydration(picture, img);
			append_hydration(div, t2);
			div_resize_listener = add_resize_listener(div, div_elementresize_handler.bind(div));
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*section*/ 32 && source0_srcset_value !== (source0_srcset_value = /*liquid*/ ctx[10].img_url(/*block*/ ctx[33].settings.image, 'x800'))) {
				attr(source0, "srcset", source0_srcset_value);
			}

			if (dirty[0] & /*section*/ 32 && source1_srcset_value !== (source1_srcset_value = /*liquid*/ ctx[10].img_url(/*block*/ ctx[33].settings.image, 'x800'))) {
				attr(source1, "srcset", source1_srcset_value);
			}

			if (dirty[0] & /*section*/ 32 && !src_url_equal(img.src, img_src_value = /*liquid*/ ctx[10].img_url(/*block*/ ctx[33].settings.image, 'x800'))) {
				attr(img, "src", img_src_value);
			}

			if (dirty[0] & /*section*/ 32 && img_alt_value !== (img_alt_value = /*block*/ ctx[33].settings.image.alt)) {
				attr(img, "alt", img_alt_value);
			}

			if (dirty[0] & /*section*/ 32) {
				set_style(div, "--image-aspect-ratio", /*block*/ ctx[33].settings.image.aspect_ratio);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			div_resize_listener();
		}
	};
}

function create_fragment(ctx) {
	let scrolling = false;

	let clear_scrolling = () => {
		scrolling = false;
	};

	let scrolling_timeout;
	let div3;
	let div1;
	let div0;
	let t0;
	let div2;
	let t1;
	let div3_style_value;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowscroll*/ ctx[23]);
	let each_value = /*section*/ ctx[5].blocks;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			div2 = element("div");
			t1 = text(" ");
			this.h();
		},
		l(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true, style: true });
			var div3_nodes = children(div3);
			div1 = claim_element(div3_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t0 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true, style: true });
			var div2_nodes = children(div2);
			t1 = claim_text(div2_nodes, " ");
			div2_nodes.forEach(detach);
			div3_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "exp-gallery-stage svelte-12dbek");
			attr(div1, "class", "stage-container svelte-12dbek");
			attr(div2, "class", "exp-gallery-placeholder");
			set_style(div2, "height", /*stageHeight*/ ctx[6] + keepFor + "px");
			attr(div3, "class", "exp-gallery-container svelte-12dbek");
			attr(div3, "style", div3_style_value = "--explode-gap: 1em; --explode-size-imbalance: 0%; --image-oversize: 1; " + /*animationVariables*/ ctx[7].join(';') + "; " + /*widthVariables*/ ctx[9].join(';') + "; " + /*heightVariables*/ ctx[8].join(';'));
		},
		m(target, anchor) {
			insert_hydration(target, div3, anchor);
			append_hydration(div3, div1);
			append_hydration(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			/*div0_binding*/ ctx[25](div0);
			append_hydration(div3, t0);
			append_hydration(div3, div2);
			append_hydration(div2, t1);
			/*div3_binding*/ ctx[26](div3);

			if (!mounted) {
				dispose = listen(window_1, "scroll", () => {
					scrolling = true;
					clearTimeout(scrolling_timeout);
					scrolling_timeout = setTimeout(clear_scrolling, 100);
					/*onwindowscroll*/ ctx[23]();
				});

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*scrollY*/ 4 && !scrolling) {
				scrolling = true;
				clearTimeout(scrolling_timeout);
				scrollTo(window_1.pageXOffset, /*scrollY*/ ctx[2]);
				scrolling_timeout = setTimeout(clear_scrolling, 100);
			}

			if (dirty[0] & /*section, itemWidths, itemHeights, liquid*/ 1080) {
				each_value = /*section*/ ctx[5].blocks;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty[0] & /*stageHeight*/ 64) {
				set_style(div2, "height", /*stageHeight*/ ctx[6] + keepFor + "px");
			}

			if (dirty[0] & /*animationVariables, widthVariables, heightVariables*/ 896 && div3_style_value !== (div3_style_value = "--explode-gap: 1em; --explode-size-imbalance: 0%; --image-oversize: 1; " + /*animationVariables*/ ctx[7].join(';') + "; " + /*widthVariables*/ ctx[9].join(';') + "; " + /*heightVariables*/ ctx[8].join(';'))) {
				attr(div3, "style", div3_style_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div3);
			destroy_each(each_blocks, detaching);
			/*div0_binding*/ ctx[25](null);
			/*div3_binding*/ ctx[26](null);
			mounted = false;
			dispose();
		}
	};
}

let index = 0;
let keepFor = 900;

function instance($$self, $$props, $$invalidate) {
	let widthVariables;
	let heightVariables;
	let $progress;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let container, stage;
	let scrollY = 0;
	const section = {};
	let { section$settings } = $$props;
	section.settings = section$settings;
	let { section$blocks } = $$props;
	section.blocks = section$blocks;
	let { imbalance } = $$props;
	const itemWidths = [];
	const itemHeights = [];
	let top = 0;
	let height = 0;
	let isEntered = 0;
	let isTopped = 0;
	let isFixed = 0;
	let cachedHeight = 0;
	let keptFor = 0;
	let topOffset = 0;
	let progressPercent = 0;
	let enteredAmount = 0;
	let stageHeight = 0;
	let fifthImage;

	let animations = [
		{
			from: 52,
			to: 77,
			valueFrom: 1,
			valueTo: 10,
			variable: '--explode-gap',
			unit: 'em'
		},
		{
			from: 33,
			to: 66,
			valueFrom: 0,
			valueTo: 20,
			variable: '--explode-size-imbalance',
			unit: '%'
		},
		{
			from: 66,
			to: 100,
			valueFrom: 1,
			valueTo: 2,
			variable: '--image-oversize'
		}
	];

	const progress = tweened(0, { duration: 100, easing: identity });
	component_subscribe($$self, progress, value => $$invalidate(22, $progress = value));

	// $: explodeGap = progressPercent > 33 ? `${1 + (10) * (progressPercent - 33) / 100}em` : '1em';
	let animationVariables = [1];

	function onwindowscroll() {
		$$invalidate(2, scrollY = window_1.pageYOffset);
	}

	function div_elementresize_handler(forloop) {
		itemWidths[forloop.index] = this.clientWidth;
		itemHeights[forloop.index] = this.clientHeight;
		$$invalidate(3, itemWidths);
		$$invalidate(4, itemHeights);
	}

	function div0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			stage = $$value;
			$$invalidate(1, stage);
		});
	}

	function div3_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			container = $$value;
			$$invalidate(0, container);
		});
	}

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(12, lec = $$props.lec);
		if ('section$settings' in $$props) $$invalidate(13, section$settings = $$props.section$settings);
		if ('section$blocks' in $$props) $$invalidate(14, section$blocks = $$props.section$blocks);
		if ('imbalance' in $$props) $$invalidate(15, imbalance = $$props.imbalance);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*fifthImage*/ 2097152) {
			$: if (!fifthImage) {
				$$invalidate(21, fifthImage = [...document.querySelectorAll('.image-container')][4].children[0]);
			}
		}

		if ($$self.$$.dirty[0] & /*container, stage, scrollY, isTopped, keptFor, cachedHeight, progressPercent*/ 1966087) {
			$: if (container && stage) {
				(top = container.offsetTop, $$invalidate(16, height = container.clientHeight), isEntered = container.offsetTop < scrollY + window.innerHeight, enteredAmount = container.offsetTop - (scrollY + window.innerHeight), $$invalidate(17, isTopped = container.offsetTop - scrollY < 0), isFixed = isTopped && keptFor < keepFor, $$invalidate(18, cachedHeight = isTopped ? cachedHeight : container.clientHeight), $$invalidate(19, keptFor = Math.abs(container.offsetTop - scrollY)), topOffset = container.offsetTop - scrollY < 0 && keepFor > keptFor
				? keptFor
				: isTopped ? keepFor : 0, $$invalidate(20, progressPercent = (scrollY + window.innerHeight - container.offsetTop) / (container.clientHeight + window.innerHeight) * 100), $$invalidate(20, progressPercent = progressPercent > 0 ? progressPercent : 0));

				progress.set(progressPercent);
				$$invalidate(6, stageHeight = stage.clientHeight);
			} // console.log('stageHeight ', stageHeight);
			// console.log('progressPercent ', progressPercent);
		}

		if ($$self.$$.dirty[0] & /*$progress*/ 4194304) {
			$: $$invalidate(7, animationVariables = animations.map(animation => {
				let animationProgress = ($progress - animation.from) / (animation.to - animation.from);
				let value = animation.valueFrom + (animation.valueTo - animation.valueFrom) * animationProgress;

				value = value < animation.valueFrom
				? animation.valueFrom
				: value > animation.valueTo
					? animation.valueTo
					: Math.round(value * 1e6) / 1e6;

				return `${animation.variable}:${value}${animation.unit || ''}`;
			}));
		}

		if ($$self.$$.dirty[0] & /*itemWidths*/ 8) {
			$: $$invalidate(9, widthVariables = itemWidths.map((width, index) => `--item-${index}-width: ${width}px`));
		}

		if ($$self.$$.dirty[0] & /*itemHeights*/ 16) {
			$: $$invalidate(8, heightVariables = itemHeights.map((height, index) => `--item-${index}-height: ${height}px`));
		}
	};

	return [
		container,
		stage,
		scrollY,
		itemWidths,
		itemHeights,
		section,
		stageHeight,
		animationVariables,
		heightVariables,
		widthVariables,
		liquid,
		progress,
		lec,
		section$settings,
		section$blocks,
		imbalance,
		height,
		isTopped,
		cachedHeight,
		keptFor,
		progressPercent,
		fifthImage,
		$progress,
		onwindowscroll,
		div_elementresize_handler,
		div0_binding,
		div3_binding
	];
}

class Exploding_gallery extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				lec: 12,
				section$settings: 13,
				section$blocks: 14,
				imbalance: 15
			},
			null,
			[-1, -1]
		);
	}
}

export { Exploding_gallery as default };
