import { SvelteComponent, init, safe_not_equal, element, space, claim_element, children, detach, claim_space, attr, set_style, toggle_class, insert_hydration, append_hydration, noop, destroy_each, onMount, src_url_equal, binding_callbacks, text, claim_text, set_data, empty, svg_element, claim_svg_element, bind, assign, HtmlTagHydration, create_component, claim_html_tag, claim_component, set_attributes, mount_component, add_flush_callback, get_spread_update, transition_in, transition_out, destroy_component, listen } from './liquivelte-svelte-hs532e1aa9.liquivelte.js';
import { cachedLiquid } from './liquivelte-liquid-hs8daa1a0c.liquivelte.js';
import './swiper.js-hs8daa1a0c.liquivelte.js';
import { Swiper } from './framework7-liquivelte-get-params-hs6b273664.liquivelte.js';
import { Quantity_box } from './header-hs39c6dc7d.liquivelte.js';
import './framework7-liquivelte-utils-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-params-list-hs8daa1a0c.liquivelte.js';
import './store.js-hs6c336c77.liquivelte.js';
import './framework7-liquivelte-hs5d6b599e.liquivelte.js';
import './framework7-liquivelte-popup-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-view-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-router-context-provider-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-login-screen-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-sheet-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-popover-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-panel-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-block-title-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-block-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-list-item-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-badge-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-list-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-page-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-page-content-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-preloader-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-stepper-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-appbar-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-button-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-use-icon-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-icon-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-link-hs8daa1a0c.liquivelte.js';

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/sections/main-product/blocks/image-gallery.liquivelte generated by Svelte v3.50.0 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	child_ctx[12] = list;
	child_ctx[13] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[13] === 0,
		index: /*index*/ child_ctx[13] + 1,
		index0: /*index*/ child_ctx[13],
		last: /*index*/ child_ctx[13] === /*product*/ child_ctx[0].images.length - 1,
		rindex: /*product*/ child_ctx[0].images.length - /*index*/ child_ctx[13],
		rindex0: /*product*/ child_ctx[0].images.length - /*index*/ child_ctx[13] - 1,
		length: /*product*/ child_ctx[0].images.length
	};

	child_ctx[11] = constants_0;
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	child_ctx[13] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[13] === 0,
		index: /*index*/ child_ctx[13] + 1,
		index0: /*index*/ child_ctx[13],
		last: /*index*/ child_ctx[13] === /*product*/ child_ctx[0].images.length - 1,
		rindex: /*product*/ child_ctx[0].images.length - /*index*/ child_ctx[13],
		rindex0: /*product*/ child_ctx[0].images.length - /*index*/ child_ctx[13] - 1,
		length: /*product*/ child_ctx[0].images.length
	};

	child_ctx[11] = constants_0;
	return child_ctx;
}

// (319:10) {#each  product.images as image, index   }
function create_each_block_1$1(ctx) {
	let div1;
	let div0;
	let img;
	let img_src_value;
	let img_alt_value;
	let t;

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			img = element("img");
			t = space();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			img = claim_element(div0_nodes, "IMG", { src: true, alt: true, class: true });
			div0_nodes.forEach(detach);
			t = claim_space(div1_nodes);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			if (!src_url_equal(img.src, img_src_value = /*liquid*/ ctx[5].img_url(/*image*/ ctx[10], '100x'))) attr(img, "src", img_src_value);
			attr(img, "alt", img_alt_value = /*image*/ ctx[10].alt);
			attr(img, "class", "object-center object-cover");
			attr(div0, "class", "w-fit aspect-w-4 aspect-h-5 sm:rounded-lg sm:overflow-hidden lg:aspect-w-3 lg:aspect-h-4");
			attr(div1, "class", "swiper-slide slide-thumbs ");
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);
			append_hydration(div1, div0);
			append_hydration(div0, img);
			append_hydration(div1, t);
		},
		p(ctx, dirty) {
			if (dirty & /*product*/ 1 && !src_url_equal(img.src, img_src_value = /*liquid*/ ctx[5].img_url(/*image*/ ctx[10], '100x'))) {
				attr(img, "src", img_src_value);
			}

			if (dirty & /*product*/ 1 && img_alt_value !== (img_alt_value = /*image*/ ctx[10].alt)) {
				attr(img, "alt", img_alt_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

// (340:6) {#each  product.images as image, index   }
function create_each_block$2(ctx) {
	let div1;
	let div0;
	let img;
	let img_src_value;
	let img_alt_value;
	let index = /*index*/ ctx[13];
	const assign_img = () => /*img_binding*/ ctx[8](img, index);
	const unassign_img = () => /*img_binding*/ ctx[8](null, index);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			img = element("img");
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true, "data-swiper-zoom": true });
			var div0_nodes = children(div0);
			img = claim_element(div0_nodes, "IMG", { src: true, alt: true, class: true });
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			if (!src_url_equal(img.src, img_src_value = /*liquid*/ ctx[5].img_url(/*image*/ ctx[10], '500x'))) attr(img, "src", img_src_value);
			attr(img, "alt", img_alt_value = /*image*/ ctx[10].alt);
			attr(img, "class", "w-full h-full object-center object-cover");
			attr(div0, "class", "swiper-zoom-container");
			attr(div0, "data-swiper-zoom", "5");
			attr(div1, "class", "swiper-slide aspect-w-4 aspect-h-5 sm:rounded-lg sm:overflow-hidden lg:aspect-w-3 lg:aspect-h-4");
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);
			append_hydration(div1, div0);
			append_hydration(div0, img);
			assign_img();
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*product*/ 1 && !src_url_equal(img.src, img_src_value = /*liquid*/ ctx[5].img_url(/*image*/ ctx[10], '500x'))) {
				attr(img, "src", img_src_value);
			}

			if (dirty & /*product*/ 1 && img_alt_value !== (img_alt_value = /*image*/ ctx[10].alt)) {
				attr(img, "alt", img_alt_value);
			}

			if (index !== /*index*/ ctx[13]) {
				unassign_img();
				index = /*index*/ ctx[13];
				assign_img();
			}
		},
		d(detaching) {
			if (detaching) detach(div1);
			unassign_img();
		}
	};
}

function create_fragment$2(ctx) {
	let div7;
	let div2;
	let div1;
	let div0;
	let t0;
	let div6;
	let div5;
	let t1;
	let div3;
	let t2;
	let div4;
	let each_value_1 = /*product*/ ctx[0].images;
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	let each_value = /*product*/ ctx[0].images;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	return {
		c() {
			div7 = element("div");
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t0 = space();
			div6 = element("div");
			div5 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			div3 = element("div");
			t2 = space();
			div4 = element("div");
			this.h();
		},
		l(nodes) {
			div7 = claim_element(nodes, "DIV", { style: true, class: true });
			var div7_nodes = children(div7);
			div2 = claim_element(div7_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t0 = claim_space(div7_nodes);
			div6 = claim_element(div7_nodes, "DIV", { class: true });
			var div6_nodes = children(div6);
			div5 = claim_element(div6_nodes, "DIV", { class: true });
			var div5_nodes = children(div5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div5_nodes);
			}

			t1 = claim_space(div5_nodes);
			div3 = claim_element(div5_nodes, "DIV", { class: true });
			children(div3).forEach(detach);
			t2 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			children(div4).forEach(detach);
			div5_nodes.forEach(detach);
			div6_nodes.forEach(detach);
			div7_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "flex-column swiper-wrapper");
			attr(div1, "class", "mx-auto max-w-full");
			attr(div2, "class", "thumbs-slider swiper max-w-full hidden lg:flex justify-items-center overflow-hidden");
			attr(div3, "class", "swiper-button-next");
			attr(div4, "class", "swiper-button-prev");
			attr(div5, "class", "swiper-wrapper");
			attr(div6, "class", "swiper max-w-full");
			set_style(div7, "--swiper-navigation-color", "#fff");
			set_style(div7, "--swiper-pagination-color", "#fff");
			set_style(div7, "grid-template-columns", "100px auto");

			set_style(div7, "--max-height", (/*gallery_images*/ ctx[4][0]
			? /*gallery_images*/ ctx[4][0].clientHeight
			: 500) + "px");

			attr(div7, "class", "mt-6 w-2xl max-w-2xl mx-auto sm:px-6 lg:max-w-7xl lg:px-8 lg:grid justify-items-center lg:gap-8 image-gallery");
			toggle_class(div7, "uninitialized", /*initialized*/ ctx[1] != true);
		},
		m(target, anchor) {
			insert_hydration(target, div7, anchor);
			append_hydration(div7, div2);
			append_hydration(div2, div1);
			append_hydration(div1, div0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			/*div1_binding*/ ctx[7](div1);
			append_hydration(div7, t0);
			append_hydration(div7, div6);
			append_hydration(div6, div5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div5, null);
			}

			append_hydration(div5, t1);
			append_hydration(div5, div3);
			append_hydration(div5, t2);
			append_hydration(div5, div4);
			/*div6_binding*/ ctx[9](div6);
		},
		p(ctx, [dirty]) {
			if (dirty & /*liquid, product*/ 33) {
				each_value_1 = /*product*/ ctx[0].images;
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1$1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div0, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (dirty & /*liquid, product, gallery_images*/ 49) {
				each_value = /*product*/ ctx[0].images;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div5, t1);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*gallery_images*/ 16) {
				set_style(div7, "--max-height", (/*gallery_images*/ ctx[4][0]
				? /*gallery_images*/ ctx[4][0].clientHeight
				: 500) + "px");
			}

			if (dirty & /*initialized*/ 2) {
				toggle_class(div7, "uninitialized", /*initialized*/ ctx[1] != true);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div7);
			destroy_each(each_blocks_1, detaching);
			/*div1_binding*/ ctx[7](null);
			destroy_each(each_blocks, detaching);
			/*div6_binding*/ ctx[9](null);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { product } = $$props;
	let initialized;
	let galleryElement, thubmnailsElement;
	let gallery_images = [];

	onMount(() => {
		const thumbnailsSwiper = new Swiper(thubmnailsElement,
		{
				slidesPerView: 5,
				spaceBetween: 10,
				watchSlidesProgress: true,
				direction: 'vertical'
			});

		new Swiper(galleryElement,
		{
				zoom: true,
				loop: true,
				slidesPerView: 1,
				navigation: {
					nextEl: ".swiper-button-next",
					prevEl: ".swiper-button-prev"
				},
				thumbs: { swiper: thumbnailsSwiper }
			});

		$$invalidate(1, initialized = true);
		console.log('gallery_images ', gallery_images);
	});

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			thubmnailsElement = $$value;
			$$invalidate(3, thubmnailsElement);
		});
	}

	function img_binding($$value, index) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			gallery_images[index] = $$value;
			$$invalidate(4, gallery_images);
		});
	}

	function div6_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			galleryElement = $$value;
			$$invalidate(2, galleryElement);
		});
	}

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(6, lec = $$props.lec);
		if ('product' in $$props) $$invalidate(0, product = $$props.product);
	};

	return [
		product,
		initialized,
		galleryElement,
		thubmnailsElement,
		gallery_images,
		liquid,
		lec,
		div1_binding,
		img_binding,
		div6_binding
	];
}

class Image_gallery extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { lec: 6, product: 0 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/sections/main-product/blocks/reviews.liquivelte generated by Svelte v3.50.0 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	child_ctx[8] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[8] === 0,
		index: /*index*/ child_ctx[8] + 1,
		index0: /*index*/ child_ctx[8],
		last: /*index*/ child_ctx[8] === /*review_stars*/ child_ctx[0].length - 1,
		rindex: /*review_stars*/ child_ctx[0].length - /*index*/ child_ctx[8],
		rindex0: /*review_stars*/ child_ctx[0].length - /*index*/ child_ctx[8] - 1,
		length: /*review_stars*/ child_ctx[0].length
	};

	child_ctx[6] = constants_0;
	return child_ctx;
}

// (39:8) {:else}
function create_else_block$1(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			this.h();
		},
		l(nodes) {
			svg = claim_svg_element(nodes, "svg", {
				class: true,
				xmlns: true,
				viewBox: true,
				fill: true,
				"aria-hidden": true
			});

			var svg_nodes = children(svg);
			path = claim_svg_element(svg_nodes, "path", { d: true });
			children(path).forEach(detach);
			svg_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path, "d", "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z");
			attr(svg, "class", "text-gray-900 h-5 w-5 flex-shrink-0");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "viewBox", "0 0 20 20");
			attr(svg, "fill", "currentColor");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert_hydration(target, svg, anchor);
			append_hydration(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (34:8) {#if score < forloop.index }
function create_if_block$1(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			this.h();
		},
		l(nodes) {
			svg = claim_svg_element(nodes, "svg", {
				class: true,
				xmlns: true,
				viewBox: true,
				fill: true,
				"aria-hidden": true
			});

			var svg_nodes = children(svg);
			path = claim_svg_element(svg_nodes, "path", { d: true });
			children(path).forEach(detach);
			svg_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path, "d", "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z");
			attr(svg, "class", "text-gray-200 h-5 w-5 flex-shrink-0");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "viewBox", "0 0 20 20");
			attr(svg, "fill", "currentColor");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert_hydration(target, svg, anchor);
			append_hydration(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (24:6) {#each  review_stars as star, index   }
function create_each_block$1(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*score*/ ctx[1] < /*forloop*/ ctx[6].index) return create_if_block$1;
		return create_else_block$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$1(ctx) {
	let div2;
	let h3;
	let t0;
	let t1;
	let div1;
	let div0;
	let t2;
	let p;
	let t3;
	let t4;
	let a;
	let t5;
	let t6;
	let each_value = /*review_stars*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	return {
		c() {
			div2 = element("div");
			h3 = element("h3");
			t0 = text("Reviews");
			t1 = space();
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			p = element("p");
			t3 = text("4 out of 5 stars");
			t4 = space();
			a = element("a");
			t5 = text(/*reviews_count*/ ctx[2]);
			t6 = text(" reviews");
			this.h();
		},
		l(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h3 = claim_element(div2_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, "Reviews");
			h3_nodes.forEach(detach);
			t1 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach);
			t2 = claim_space(div1_nodes);
			p = claim_element(div1_nodes, "P", { class: true });
			var p_nodes = children(p);
			t3 = claim_text(p_nodes, "4 out of 5 stars");
			p_nodes.forEach(detach);
			t4 = claim_space(div1_nodes);
			a = claim_element(div1_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t5 = claim_text(a_nodes, /*reviews_count*/ ctx[2]);
			t6 = claim_text(a_nodes, " reviews");
			a_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(h3, "class", "sr-only");
			attr(div0, "class", "flex items-center");
			attr(p, "class", "sr-only");
			attr(a, "href", "#");
			attr(a, "class", "ml-3 text-sm font-medium text-indigo-600 hover:text-indigo-500");
			attr(div1, "class", "flex items-center");
			attr(div2, "class", "mt-6");
		},
		m(target, anchor) {
			insert_hydration(target, div2, anchor);
			append_hydration(div2, h3);
			append_hydration(h3, t0);
			append_hydration(div2, t1);
			append_hydration(div2, div1);
			append_hydration(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			append_hydration(div1, t2);
			append_hydration(div1, p);
			append_hydration(p, t3);
			append_hydration(div1, t4);
			append_hydration(div1, a);
			append_hydration(a, t5);
			append_hydration(a, t6);
		},
		p(ctx, [dirty]) {
			if (dirty & /*score, review_stars*/ 3) {
				each_value = /*review_stars*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*reviews_count*/ 4) set_data(t5, /*reviews_count*/ ctx[2]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div2);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { lec } = $$props;
	let { review_stars } = $$props;
	let { score } = $$props;
	let { reviews_count } = $$props;
	console.log('review_stars ', review_stars);

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(3, lec = $$props.lec);
		if ('review_stars' in $$props) $$invalidate(0, review_stars = $$props.review_stars);
		if ('score' in $$props) $$invalidate(1, score = $$props.score);
		if ('reviews_count' in $$props) $$invalidate(2, reviews_count = $$props.reviews_count);
	};

	return [review_stars, score, reviews_count, lec];
}

class Reviews extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			lec: 3,
			review_stars: 0,
			score: 1,
			reviews_count: 2
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/sections/main-product/index.liquivelte generated by Svelte v3.50.0 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[23] = list[i];
	child_ctx[26] = list;
	child_ctx[27] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[27] === 0,
		index: /*index*/ child_ctx[27] + 1,
		index0: /*index*/ child_ctx[27],
		last: /*index*/ child_ctx[27] === /*product*/ child_ctx[0].options_with_values.length - 1,
		rindex: /*product*/ child_ctx[0].options_with_values.length - /*index*/ child_ctx[27],
		rindex0: /*product*/ child_ctx[0].options_with_values.length - /*index*/ child_ctx[27] - 1,
		length: /*product*/ child_ctx[0].options_with_values.length
	};

	child_ctx[24] = constants_0;
	const constants_1 = /*forloop*/ child_ctx[24].index0;
	child_ctx[25] = constants_1;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[28] = list[i];
	child_ctx[27] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[27] === 0,
		index: /*index*/ child_ctx[27] + 1,
		index0: /*index*/ child_ctx[27],
		last: /*index*/ child_ctx[27] === /*option*/ child_ctx[23].values.length - 1,
		rindex: /*option*/ child_ctx[23].values.length - /*index*/ child_ctx[27],
		rindex0: /*option*/ child_ctx[23].values.length - /*index*/ child_ctx[27] - 1,
		length: /*option*/ child_ctx[23].values.length
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[28] = list[i];
	child_ctx[27] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[27] === 0,
		index: /*index*/ child_ctx[27] + 1,
		index0: /*index*/ child_ctx[27],
		last: /*index*/ child_ctx[27] === /*option*/ child_ctx[23].values.length - 1,
		rindex: /*option*/ child_ctx[23].values.length - /*index*/ child_ctx[27],
		rindex0: /*option*/ child_ctx[23].values.length - /*index*/ child_ctx[27] - 1,
		length: /*option*/ child_ctx[23].values.length
	};

	child_ctx[24] = constants_0;
	return child_ctx;
}

// (1106:16) {:else}
function create_else_block_1(ctx) {
	let div;
	let each_value_2 = /*option*/ ctx[23].values;
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "grid grid-cols-4 gap-4 sm:grid-cols-8 lg:grid-cols-4");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, dirty) {
			if (dirty & /*product, selected_options*/ 2049) {
				each_value_2 = /*option*/ ctx[23].values;
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (1079:16) {#if option.name == 'Color' }
function create_if_block(ctx) {
	let div;
	let each_value_1 = /*option*/ ctx[23].values;
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "flex items-center space-x-3");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, dirty) {
			if (dirty & /*product, selected_options*/ 2049) {
				each_value_1 = /*option*/ ctx[23].values;
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (1126:24) {:else}
function create_else_block_2(ctx) {
	let input;
	let input_value_value;
	let mounted;
	let dispose;
	/*$$binding_groups*/ ctx[15][0][/*index*/ ctx[27]] = [];

	function input_change_handler_3() {
		/*input_change_handler_3*/ ctx[18].call(input, /*option*/ ctx[23]);
	}

	return {
		c() {
			input = element("input");
			this.h();
		},
		l(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				name: true,
				class: true,
				"aria-labelledby": true
			});

			this.h();
		},
		h() {
			attr(input, "type", "radio");
			attr(input, "name", "size-choice");
			input.__value = input_value_value = /*value*/ ctx[28];
			input.value = input.__value;
			attr(input, "class", "sr-only");
			attr(input, "aria-labelledby", "size-choice-1-label");
			/*$$binding_groups*/ ctx[15][0][/*index*/ ctx[27]].push(input);
		},
		m(target, anchor) {
			insert_hydration(target, input, anchor);
			input.checked = input.__value === /*selected_options*/ ctx[11][/*option*/ ctx[23].position];

			if (!mounted) {
				dispose = listen(input, "change", input_change_handler_3);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*product*/ 1 && input_value_value !== (input_value_value = /*value*/ ctx[28])) {
				input.__value = input_value_value;
				input.value = input.__value;
			}

			if (dirty & /*selected_options, product*/ 2049) {
				input.checked = input.__value === /*selected_options*/ ctx[11][/*option*/ ctx[23].position];
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			/*$$binding_groups*/ ctx[15][0][/*index*/ ctx[27]].splice(/*$$binding_groups*/ ctx[15][0][/*index*/ ctx[27]].indexOf(input), 1);
			mounted = false;
			dispose();
		}
	};
}

// (1124:24) {#if value == product.selected_or_first_available_variant.options[option_index] }
function create_if_block_2(ctx) {
	let input;
	let input_value_value;
	let mounted;
	let dispose;
	/*$$binding_groups*/ ctx[15][0][/*index*/ ctx[27]] = [];

	function input_change_handler_2() {
		/*input_change_handler_2*/ ctx[17].call(input, /*option*/ ctx[23]);
	}

	return {
		c() {
			input = element("input");
			this.h();
		},
		l(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				name: true,
				class: true,
				"aria-labelledby": true
			});

			this.h();
		},
		h() {
			attr(input, "type", "radio");
			attr(input, "name", "size-choice");
			input.__value = input_value_value = /*value*/ ctx[28];
			input.value = input.__value;
			attr(input, "class", "sr-only");
			attr(input, "aria-labelledby", "size-choice-1-label");
			input.checked = true;
			/*$$binding_groups*/ ctx[15][0][/*index*/ ctx[27]].push(input);
		},
		m(target, anchor) {
			insert_hydration(target, input, anchor);
			input.checked = input.__value === /*selected_options*/ ctx[11][/*option*/ ctx[23].position];

			if (!mounted) {
				dispose = listen(input, "change", input_change_handler_2);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*product*/ 1 && input_value_value !== (input_value_value = /*value*/ ctx[28])) {
				input.__value = input_value_value;
				input.value = input.__value;
			}

			if (dirty & /*selected_options, product*/ 2049) {
				input.checked = input.__value === /*selected_options*/ ctx[11][/*option*/ ctx[23].position];
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			/*$$binding_groups*/ ctx[15][0][/*index*/ ctx[27]].splice(/*$$binding_groups*/ ctx[15][0][/*index*/ ctx[27]].indexOf(input), 1);
			mounted = false;
			dispose();
		}
	};
}

// (1108:18) {#each  option.values as value, index   }
function create_each_block_2(ctx) {
	let label;
	let t0;
	let p;
	let t1_value = /*value*/ ctx[28] + "";
	let t1;
	let t2;
	let div;
	let t3;

	function select_block_type_2(ctx, dirty) {
		if (/*value*/ ctx[28] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[25]]) return create_if_block_2;
		return create_else_block_2;
	}

	let current_block_type = select_block_type_2(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			label = element("label");
			if_block.c();
			t0 = space();
			p = element("p");
			t1 = text(t1_value);
			t2 = space();
			div = element("div");
			t3 = space();
			this.h();
		},
		l(nodes) {
			label = claim_element(nodes, "LABEL", { class: true });
			var label_nodes = children(label);
			if_block.l(label_nodes);
			t0 = claim_space(label_nodes);
			p = claim_element(label_nodes, "P", { id: true });
			var p_nodes = children(p);
			t1 = claim_text(p_nodes, t1_value);
			p_nodes.forEach(detach);
			t2 = claim_space(label_nodes);
			div = claim_element(label_nodes, "DIV", { class: true, "aria-hidden": true });
			children(div).forEach(detach);
			t3 = claim_space(label_nodes);
			label_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(p, "id", "size-choice-1-label");
			attr(div, "class", "absolute -inset-px rounded-md pointer-events-none");
			attr(div, "aria-hidden", "true");
			attr(label, "class", "group relative border rounded-md py-3 hover:bg-indigo-400 hover:text-white px-4 flex items-center justify-center text-sm font-medium uppercase focus:outline-none sm:flex-1 sm:py-6 bg-white shadow-sm cursor-pointer");
			toggle_class(label, "bg-indigo-600", /*value*/ ctx[28] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[25]]);
			toggle_class(label, "text-white", /*value*/ ctx[28] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[25]]);
			toggle_class(label, "text-gray-900", /*value*/ ctx[28] != /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[25]]);
		},
		m(target, anchor) {
			insert_hydration(target, label, anchor);
			if_block.m(label, null);
			append_hydration(label, t0);
			append_hydration(label, p);
			append_hydration(p, t1);
			append_hydration(label, t2);
			append_hydration(label, div);
			append_hydration(label, t3);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(label, t0);
				}
			}

			if (dirty & /*product*/ 1 && t1_value !== (t1_value = /*value*/ ctx[28] + "")) set_data(t1, t1_value);

			if (dirty & /*product*/ 1) {
				toggle_class(label, "bg-indigo-600", /*value*/ ctx[28] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[25]]);
			}

			if (dirty & /*product*/ 1) {
				toggle_class(label, "text-white", /*value*/ ctx[28] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[25]]);
			}

			if (dirty & /*product*/ 1) {
				toggle_class(label, "text-gray-900", /*value*/ ctx[28] != /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[25]]);
			}
		},
		d(detaching) {
			if (detaching) detach(label);
			if_block.d();
		}
	};
}

// (1098:22) {:else}
function create_else_block(ctx) {
	let input;
	let input_value_value;
	let mounted;
	let dispose;
	/*$$binding_groups*/ ctx[15][0][/*index*/ ctx[27]] = [];

	function input_change_handler_1() {
		/*input_change_handler_1*/ ctx[16].call(input, /*option*/ ctx[23]);
	}

	return {
		c() {
			input = element("input");
			this.h();
		},
		l(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				name: true,
				class: true,
				"aria-labelledby": true
			});

			this.h();
		},
		h() {
			attr(input, "type", "radio");
			attr(input, "name", "color-choice");
			input.__value = input_value_value = /*value*/ ctx[28];
			input.value = input.__value;
			attr(input, "class", "sr-only");
			attr(input, "aria-labelledby", "color-choice-0-label");
			/*$$binding_groups*/ ctx[15][0][/*index*/ ctx[27]].push(input);
		},
		m(target, anchor) {
			insert_hydration(target, input, anchor);
			input.checked = input.__value === /*selected_options*/ ctx[11][/*option*/ ctx[23].position];

			if (!mounted) {
				dispose = listen(input, "change", input_change_handler_1);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*product*/ 1 && input_value_value !== (input_value_value = /*value*/ ctx[28])) {
				input.__value = input_value_value;
				input.value = input.__value;
			}

			if (dirty & /*selected_options, product*/ 2049) {
				input.checked = input.__value === /*selected_options*/ ctx[11][/*option*/ ctx[23].position];
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			/*$$binding_groups*/ ctx[15][0][/*index*/ ctx[27]].splice(/*$$binding_groups*/ ctx[15][0][/*index*/ ctx[27]].indexOf(input), 1);
			mounted = false;
			dispose();
		}
	};
}

// (1096:22) {#if value == product.selected_or_first_available_variant.options[option_index] }
function create_if_block_1(ctx) {
	let input;
	let input_value_value;
	let mounted;
	let dispose;
	/*$$binding_groups*/ ctx[15][0][/*index*/ ctx[27]] = [];

	function input_change_handler() {
		/*input_change_handler*/ ctx[14].call(input, /*option*/ ctx[23]);
	}

	return {
		c() {
			input = element("input");
			this.h();
		},
		l(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				name: true,
				class: true,
				"aria-labelledby": true
			});

			this.h();
		},
		h() {
			attr(input, "type", "radio");
			attr(input, "name", "color-choice");
			input.__value = input_value_value = /*value*/ ctx[28];
			input.value = input.__value;
			attr(input, "class", "sr-only");
			attr(input, "aria-labelledby", "color-choice-0-label");
			input.checked = true;
			/*$$binding_groups*/ ctx[15][0][/*index*/ ctx[27]].push(input);
		},
		m(target, anchor) {
			insert_hydration(target, input, anchor);
			input.checked = input.__value === /*selected_options*/ ctx[11][/*option*/ ctx[23].position];

			if (!mounted) {
				dispose = listen(input, "change", input_change_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*product*/ 1 && input_value_value !== (input_value_value = /*value*/ ctx[28])) {
				input.__value = input_value_value;
				input.value = input.__value;
			}

			if (dirty & /*selected_options, product*/ 2049) {
				input.checked = input.__value === /*selected_options*/ ctx[11][/*option*/ ctx[23].position];
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			/*$$binding_groups*/ ctx[15][0][/*index*/ ctx[27]].splice(/*$$binding_groups*/ ctx[15][0][/*index*/ ctx[27]].indexOf(input), 1);
			mounted = false;
			dispose();
		}
	};
}

// (1081:18) {#each  option.values as value, index   }
function create_each_block_1(ctx) {
	let label;
	let t0;
	let p;
	let t1_value = /*value*/ ctx[28] + "";
	let t1;
	let t2;
	let span;
	let t3;

	function select_block_type_1(ctx, dirty) {
		if (/*value*/ ctx[28] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[25]]) return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			label = element("label");
			if_block.c();
			t0 = space();
			p = element("p");
			t1 = text(t1_value);
			t2 = space();
			span = element("span");
			t3 = space();
			this.h();
		},
		l(nodes) {
			label = claim_element(nodes, "LABEL", { class: true });
			var label_nodes = children(label);
			if_block.l(label_nodes);
			t0 = claim_space(label_nodes);
			p = claim_element(label_nodes, "P", { id: true, class: true });
			var p_nodes = children(p);
			t1 = claim_text(p_nodes, t1_value);
			p_nodes.forEach(detach);
			t2 = claim_space(label_nodes);
			span = claim_element(label_nodes, "SPAN", { "aria-hidden": true, class: true });
			children(span).forEach(detach);
			t3 = claim_space(label_nodes);
			label_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(p, "id", "color-choice-0-label");
			attr(p, "class", "sr-only");
			attr(span, "aria-hidden", "true");
			attr(span, "class", "h-8 w-8 bg-white border border-black border-opacity-10 rounded-full");
			attr(label, "class", "-m-0.5 relative p-0.5 rounded-full flex items-center justify-center cursor-pointer focus:outline-none ring-gray-400");
			toggle_class(label, "ring", /*value*/ ctx[28] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[25]]);
			toggle_class(label, "ring-offset-1", /*value*/ ctx[28] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[25]]);
		},
		m(target, anchor) {
			insert_hydration(target, label, anchor);
			if_block.m(label, null);
			append_hydration(label, t0);
			append_hydration(label, p);
			append_hydration(p, t1);
			append_hydration(label, t2);
			append_hydration(label, span);
			append_hydration(label, t3);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(label, t0);
				}
			}

			if (dirty & /*product*/ 1 && t1_value !== (t1_value = /*value*/ ctx[28] + "")) set_data(t1, t1_value);

			if (dirty & /*product*/ 1) {
				toggle_class(label, "ring", /*value*/ ctx[28] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[25]]);
			}

			if (dirty & /*product*/ 1) {
				toggle_class(label, "ring-offset-1", /*value*/ ctx[28] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[25]]);
			}
		},
		d(detaching) {
			if (detaching) detach(label);
			if_block.d();
		}
	};
}

// (1061:12) {#each  product.options_with_values as option, index   }
function create_each_block(ctx) {
	let h3;
	let t0;
	let t1_value = /*option*/ ctx[23].name + "";
	let t1;
	let t2;
	let fieldset;
	let legend;
	let t3;
	let t4_value = /*option*/ ctx[23].name + "";
	let t4;
	let t5;
	let t6;

	function select_block_type(ctx, dirty) {
		if (/*option*/ ctx[23].name == 'Color') return create_if_block;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			h3 = element("h3");
			t0 = text("Choose a ");
			t1 = text(t1_value);
			t2 = space();
			fieldset = element("fieldset");
			legend = element("legend");
			t3 = text("Choose a ");
			t4 = text(t4_value);
			t5 = space();
			if_block.c();
			t6 = space();
			this.h();
		},
		l(nodes) {
			h3 = claim_element(nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, "Choose a ");
			t1 = claim_text(h3_nodes, t1_value);
			h3_nodes.forEach(detach);
			t2 = claim_space(nodes);
			fieldset = claim_element(nodes, "FIELDSET", { class: true });
			var fieldset_nodes = children(fieldset);
			legend = claim_element(fieldset_nodes, "LEGEND", { class: true });
			var legend_nodes = children(legend);
			t3 = claim_text(legend_nodes, "Choose a ");
			t4 = claim_text(legend_nodes, t4_value);
			legend_nodes.forEach(detach);
			t5 = claim_space(fieldset_nodes);
			if_block.l(fieldset_nodes);
			t6 = claim_space(fieldset_nodes);
			fieldset_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(h3, "class", "text-sm text-gray-900 font-medium mt-4");
			attr(legend, "class", "sr-only");
			attr(fieldset, "class", "mt-4");
		},
		m(target, anchor) {
			insert_hydration(target, h3, anchor);
			append_hydration(h3, t0);
			append_hydration(h3, t1);
			insert_hydration(target, t2, anchor);
			insert_hydration(target, fieldset, anchor);
			append_hydration(fieldset, legend);
			append_hydration(legend, t3);
			append_hydration(legend, t4);
			append_hydration(fieldset, t5);
			if_block.m(fieldset, null);
			append_hydration(fieldset, t6);
		},
		p(ctx, dirty) {
			if (dirty & /*product*/ 1 && t1_value !== (t1_value = /*option*/ ctx[23].name + "")) set_data(t1, t1_value);
			if (dirty & /*product*/ 1 && t4_value !== (t4_value = /*option*/ ctx[23].name + "")) set_data(t4, t4_value);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(fieldset, t6);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(h3);
			if (detaching) detach(t2);
			if (detaching) detach(fieldset);
			if_block.d();
		}
	};
}

function create_fragment(ctx) {
	let div15;
	let html_tag;
	let raw0_value = /*rawinclude_f5b8cf1c*/ ctx[4][0] + "";
	let t0;
	let div14;
	let div13;
	let div1;
	let imagegallery;
	let t1;
	let div0;
	let t2;
	let h10;
	let t3_value = /*section*/ ctx[12].settings.product_title + "";
	let t3;
	let t4;
	let div5;
	let h11;
	let t5_value = /*product*/ ctx[0].title + "";
	let t5;
	let t6;
	let h20;
	let t7;
	let t8;
	let p0;
	let t9;
	let t10;
	let reviews;
	let t11;
	let form;
	let html_tag_1;
	let raw1_value = /*form_inputs_f58d08b6b*/ ctx[2][0] + "";
	let t12;
	let input;
	let input_value_value;
	let t13;
	let div2;
	let t14;
	let div4;
	let label;
	let t15;
	let t16;
	let quantitybox;
	let updating_quantity;
	let t17;
	let div3;
	let button;
	let t18;
	let t19;
	let div12;
	let div7;
	let h30;
	let t20;
	let t21;
	let div6;
	let p1;
	let raw2_value = (/*product*/ ctx[0].description || '') + "";
	let t22;
	let div9;
	let h31;
	let t23;
	let t24;
	let div8;
	let ul;
	let li0;
	let span0;
	let t25;
	let t26;
	let li1;
	let span1;
	let t27;
	let t28;
	let li2;
	let span2;
	let t29;
	let t30;
	let li3;
	let span3;
	let t31;
	let t32;
	let div11;
	let h21;
	let t33;
	let t34;
	let div10;
	let p2;
	let t35;
	let current;

	imagegallery = new Image_gallery({
			props: {
				breadcrumbs: /*breadcrumbs*/ ctx[5],
				breadcrumbs_size: /*breadcrumbs_size*/ ctx[6],
				price_formatted: /*price_formatted*/ ctx[7],
				product: /*product*/ ctx[0],
				productƒƒoptions_with_values: /*productƒƒoptions_with_values*/ ctx[8],
				sectionƒƒsettings: /*sectionƒƒsettings*/ ctx[9],
				productƒƒselected_or_first_available_variant: /*productƒƒselected_or_first_available_variant*/ ctx[10],
				form_props_f58d08b6b: /*form_props_f58d08b6b*/ ctx[3],
				form_inputs_f58d08b6b: /*form_inputs_f58d08b6b*/ ctx[2],
				rawinclude_f5b8cf1c: /*rawinclude_f5b8cf1c*/ ctx[4],
				lec: /*lec*/ ctx[1]
			}
		});

	reviews = new Reviews({
			props: {
				breadcrumbs: /*breadcrumbs*/ ctx[5],
				breadcrumbs_size: /*breadcrumbs_size*/ ctx[6],
				price_formatted: /*price_formatted*/ ctx[7],
				product: /*product*/ ctx[0],
				productƒƒoptions_with_values: /*productƒƒoptions_with_values*/ ctx[8],
				sectionƒƒsettings: /*sectionƒƒsettings*/ ctx[9],
				productƒƒselected_or_first_available_variant: /*productƒƒselected_or_first_available_variant*/ ctx[10],
				form_props_f58d08b6b: /*form_props_f58d08b6b*/ ctx[3],
				form_inputs_f58d08b6b: /*form_inputs_f58d08b6b*/ ctx[2],
				rawinclude_f5b8cf1c: /*rawinclude_f5b8cf1c*/ ctx[4],
				lec: /*lec*/ ctx[1]
			}
		});

	let each_value = /*product*/ ctx[0].options_with_values;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	function quantitybox_quantity_binding(value) {
		/*quantitybox_quantity_binding*/ ctx[19](value);
	}

	let quantitybox_props = {
		breadcrumbs: /*breadcrumbs*/ ctx[5],
		breadcrumbs_size: /*breadcrumbs_size*/ ctx[6],
		price_formatted: /*price_formatted*/ ctx[7],
		product: /*product*/ ctx[0],
		productƒƒoptions_with_values: /*productƒƒoptions_with_values*/ ctx[8],
		sectionƒƒsettings: /*sectionƒƒsettings*/ ctx[9],
		productƒƒselected_or_first_available_variant: /*productƒƒselected_or_first_available_variant*/ ctx[10],
		form_props_f58d08b6b: /*form_props_f58d08b6b*/ ctx[3],
		form_inputs_f58d08b6b: /*form_inputs_f58d08b6b*/ ctx[2],
		rawinclude_f5b8cf1c: /*rawinclude_f5b8cf1c*/ ctx[4],
		lec: /*lec*/ ctx[1]
	};

	if (/*quantity*/ ctx[13] !== void 0) {
		quantitybox_props.quantity = /*quantity*/ ctx[13];
	}

	quantitybox = new Quantity_box({ props: quantitybox_props });
	binding_callbacks.push(() => bind(quantitybox, 'quantity', quantitybox_quantity_binding));
	let form_levels = [{ class: "mt-10" }, /*form_props_f58d08b6b*/ ctx[3][0]];
	let form_data = {};

	for (let i = 0; i < form_levels.length; i += 1) {
		form_data = assign(form_data, form_levels[i]);
	}

	return {
		c() {
			div15 = element("div");
			html_tag = new HtmlTagHydration(false);
			t0 = space();
			div14 = element("div");
			div13 = element("div");
			div1 = element("div");
			create_component(imagegallery.$$.fragment);
			t1 = space();
			div0 = element("div");
			t2 = space();
			h10 = element("h1");
			t3 = text(t3_value);
			t4 = space();
			div5 = element("div");
			h11 = element("h1");
			t5 = text(t5_value);
			t6 = space();
			h20 = element("h2");
			t7 = text("Product information");
			t8 = space();
			p0 = element("p");
			t9 = text(/*price_formatted*/ ctx[7]);
			t10 = space();
			create_component(reviews.$$.fragment);
			t11 = space();
			form = element("form");
			html_tag_1 = new HtmlTagHydration(false);
			t12 = space();
			input = element("input");
			t13 = space();
			div2 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t14 = space();
			div4 = element("div");
			label = element("label");
			t15 = text("Quantity");
			t16 = space();
			create_component(quantitybox.$$.fragment);
			t17 = space();
			div3 = element("div");
			button = element("button");
			t18 = text("Add to bag");
			t19 = space();
			div12 = element("div");
			div7 = element("div");
			h30 = element("h3");
			t20 = text("Description");
			t21 = space();
			div6 = element("div");
			p1 = element("p");
			t22 = space();
			div9 = element("div");
			h31 = element("h3");
			t23 = text("Highlights");
			t24 = space();
			div8 = element("div");
			ul = element("ul");
			li0 = element("li");
			span0 = element("span");
			t25 = text("Hand cut and sewn locally");
			t26 = space();
			li1 = element("li");
			span1 = element("span");
			t27 = text("Dyed with our proprietary colors");
			t28 = space();
			li2 = element("li");
			span2 = element("span");
			t29 = text("Pre-washed & pre-shrunk");
			t30 = space();
			li3 = element("li");
			span3 = element("span");
			t31 = text("Ultra-soft 100% cotton");
			t32 = space();
			div11 = element("div");
			h21 = element("h2");
			t33 = text("Details");
			t34 = space();
			div10 = element("div");
			p2 = element("p");
			t35 = text("The 6-Pack includes two black, two white, and two heather gray Basic Tees. Sign up for our subscription service and be the first to get new, exciting colors, like our upcoming \"Charcoal Gray\" limited release.");
			this.h();
		},
		l(nodes) {
			div15 = claim_element(nodes, "DIV", { class: true });
			var div15_nodes = children(div15);
			html_tag = claim_html_tag(div15_nodes, false);
			t0 = claim_space(div15_nodes);
			div14 = claim_element(div15_nodes, "DIV", { class: true });
			var div14_nodes = children(div14);
			div13 = claim_element(div14_nodes, "DIV", { class: true });
			var div13_nodes = children(div13);
			div1 = claim_element(div13_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(imagegallery.$$.fragment, div1_nodes);
			t1 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			children(div0).forEach(detach);
			t2 = claim_space(div1_nodes);
			h10 = claim_element(div1_nodes, "H1", { class: true });
			var h10_nodes = children(h10);
			t3 = claim_text(h10_nodes, t3_value);
			h10_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t4 = claim_space(div13_nodes);
			div5 = claim_element(div13_nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			h11 = claim_element(div5_nodes, "H1", { class: true });
			var h11_nodes = children(h11);
			t5 = claim_text(h11_nodes, t5_value);
			h11_nodes.forEach(detach);
			t6 = claim_space(div5_nodes);
			h20 = claim_element(div5_nodes, "H2", { class: true });
			var h20_nodes = children(h20);
			t7 = claim_text(h20_nodes, "Product information");
			h20_nodes.forEach(detach);
			t8 = claim_space(div5_nodes);
			p0 = claim_element(div5_nodes, "P", { class: true });
			var p0_nodes = children(p0);
			t9 = claim_text(p0_nodes, /*price_formatted*/ ctx[7]);
			p0_nodes.forEach(detach);
			t10 = claim_space(div5_nodes);
			claim_component(reviews.$$.fragment, div5_nodes);
			t11 = claim_space(div5_nodes);
			form = claim_element(div5_nodes, "FORM", { class: true });
			var form_nodes = children(form);
			html_tag_1 = claim_html_tag(form_nodes, false);
			t12 = claim_space(form_nodes);
			input = claim_element(form_nodes, "INPUT", { type: true, name: true });
			t13 = claim_space(form_nodes);
			div2 = claim_element(form_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div2_nodes);
			}

			div2_nodes.forEach(detach);
			t14 = claim_space(form_nodes);
			div4 = claim_element(form_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			label = claim_element(div4_nodes, "LABEL", { class: true });
			var label_nodes = children(label);
			t15 = claim_text(label_nodes, "Quantity");
			label_nodes.forEach(detach);
			t16 = claim_space(div4_nodes);
			claim_component(quantitybox.$$.fragment, div4_nodes);
			t17 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", {});
			var div3_nodes = children(div3);
			button = claim_element(div3_nodes, "BUTTON", { type: true, class: true });
			var button_nodes = children(button);
			t18 = claim_text(button_nodes, "Add to bag");
			button_nodes.forEach(detach);
			div3_nodes.forEach(detach);
			div4_nodes.forEach(detach);
			form_nodes.forEach(detach);
			div5_nodes.forEach(detach);
			t19 = claim_space(div13_nodes);
			div12 = claim_element(div13_nodes, "DIV", { class: true });
			var div12_nodes = children(div12);
			div7 = claim_element(div12_nodes, "DIV", {});
			var div7_nodes = children(div7);
			h30 = claim_element(div7_nodes, "H3", { class: true });
			var h30_nodes = children(h30);
			t20 = claim_text(h30_nodes, "Description");
			h30_nodes.forEach(detach);
			t21 = claim_space(div7_nodes);
			div6 = claim_element(div7_nodes, "DIV", { class: true });
			var div6_nodes = children(div6);
			p1 = claim_element(div6_nodes, "P", { class: true });
			var p1_nodes = children(p1);
			p1_nodes.forEach(detach);
			div6_nodes.forEach(detach);
			div7_nodes.forEach(detach);
			t22 = claim_space(div12_nodes);
			div9 = claim_element(div12_nodes, "DIV", { class: true });
			var div9_nodes = children(div9);
			h31 = claim_element(div9_nodes, "H3", { class: true });
			var h31_nodes = children(h31);
			t23 = claim_text(h31_nodes, "Highlights");
			h31_nodes.forEach(detach);
			t24 = claim_space(div9_nodes);
			div8 = claim_element(div9_nodes, "DIV", { class: true });
			var div8_nodes = children(div8);
			ul = claim_element(div8_nodes, "UL", { role: true, class: true });
			var ul_nodes = children(ul);
			li0 = claim_element(ul_nodes, "LI", { class: true });
			var li0_nodes = children(li0);
			span0 = claim_element(li0_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t25 = claim_text(span0_nodes, "Hand cut and sewn locally");
			span0_nodes.forEach(detach);
			li0_nodes.forEach(detach);
			t26 = claim_space(ul_nodes);
			li1 = claim_element(ul_nodes, "LI", { class: true });
			var li1_nodes = children(li1);
			span1 = claim_element(li1_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t27 = claim_text(span1_nodes, "Dyed with our proprietary colors");
			span1_nodes.forEach(detach);
			li1_nodes.forEach(detach);
			t28 = claim_space(ul_nodes);
			li2 = claim_element(ul_nodes, "LI", { class: true });
			var li2_nodes = children(li2);
			span2 = claim_element(li2_nodes, "SPAN", { class: true });
			var span2_nodes = children(span2);
			t29 = claim_text(span2_nodes, "Pre-washed & pre-shrunk");
			span2_nodes.forEach(detach);
			li2_nodes.forEach(detach);
			t30 = claim_space(ul_nodes);
			li3 = claim_element(ul_nodes, "LI", { class: true });
			var li3_nodes = children(li3);
			span3 = claim_element(li3_nodes, "SPAN", { class: true });
			var span3_nodes = children(span3);
			t31 = claim_text(span3_nodes, "Ultra-soft 100% cotton");
			span3_nodes.forEach(detach);
			li3_nodes.forEach(detach);
			ul_nodes.forEach(detach);
			div8_nodes.forEach(detach);
			div9_nodes.forEach(detach);
			t32 = claim_space(div12_nodes);
			div11 = claim_element(div12_nodes, "DIV", { class: true });
			var div11_nodes = children(div11);
			h21 = claim_element(div11_nodes, "H2", { class: true });
			var h21_nodes = children(h21);
			t33 = claim_text(h21_nodes, "Details");
			h21_nodes.forEach(detach);
			t34 = claim_space(div11_nodes);
			div10 = claim_element(div11_nodes, "DIV", { class: true });
			var div10_nodes = children(div10);
			p2 = claim_element(div10_nodes, "P", { class: true });
			var p2_nodes = children(p2);
			t35 = claim_text(p2_nodes, "The 6-Pack includes two black, two white, and two heather gray Basic Tees. Sign up for our subscription service and be the first to get new, exciting colors, like our upcoming \"Charcoal Gray\" limited release.");
			p2_nodes.forEach(detach);
			div10_nodes.forEach(detach);
			div11_nodes.forEach(detach);
			div12_nodes.forEach(detach);
			div13_nodes.forEach(detach);
			div14_nodes.forEach(detach);
			div15_nodes.forEach(detach);
			this.h();
		},
		h() {
			html_tag.a = t0;
			attr(div0, "class", "h-8 md:h-20");
			attr(h10, "class", "text-2xl font-extrabold tracking-tight text-gray-900 sm:text-3xl");
			attr(div1, "class", "lg:col-span-2 lg:border-r lg:border-gray-200 lg:pr-8");
			attr(h11, "class", "text-2xl font-extrabold tracking-tight text-gray-900 sm:text-3xl");
			attr(h20, "class", "sr-only");
			attr(p0, "class", "text-3xl text-gray-900 mt-4");
			html_tag_1.a = t12;
			attr(input, "type", "hidden");
			attr(input, "name", "id");
			input.value = input_value_value = /*product*/ ctx[0].selected_or_first_available_variant.id;
			attr(div2, "class", "");
			attr(label, "class", "text-base");
			attr(button, "type", "submit");
			attr(button, "class", "mt-10 w-full bg-indigo-600 border border-transparent rounded-md py-3 px-8 flex items-center justify-center text-base font-medium text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500");
			attr(div4, "class", "mt-10");
			set_attributes(form, form_data);
			attr(div5, "class", "mt-4 lg:mt-0 lg:row-span-3");
			attr(h30, "class", "sr-only");
			attr(p1, "class", "text-base text-gray-900");
			attr(div6, "class", "space-y-6");
			attr(h31, "class", "text-sm font-medium text-gray-900");
			attr(span0, "class", "text-gray-600");
			attr(li0, "class", "text-gray-400");
			attr(span1, "class", "text-gray-600");
			attr(li1, "class", "text-gray-400");
			attr(span2, "class", "text-gray-600");
			attr(li2, "class", "text-gray-400");
			attr(span3, "class", "text-gray-600");
			attr(li3, "class", "text-gray-400");
			attr(ul, "role", "list");
			attr(ul, "class", "pl-4 list-disc text-sm space-y-2");
			attr(div8, "class", "mt-4");
			attr(div9, "class", "mt-10");
			attr(h21, "class", "text-sm font-medium text-gray-900");
			attr(p2, "class", "text-sm text-gray-600");
			attr(div10, "class", "mt-4 space-y-6");
			attr(div11, "class", "mt-10");
			attr(div12, "class", "py-10 lg:pt-6 lg:pb-16 lg:col-start-1 lg:col-span-2 lg:border-r lg:border-gray-200 lg:pr-8");
			attr(div13, "class", "max-w-2xl mx-auto pt-10 pb-16 px-4 sm:px-6 lg:max-w-7xl lg:pt-16 lg:pb-24 lg:px-8 lg:grid lg:grid-cols-3 lg:grid-rows-[auto,auto,1fr] lg:gap-x-8");
			attr(div14, "class", "pt-6");
			attr(div15, "class", "bg-white");
		},
		m(target, anchor) {
			insert_hydration(target, div15, anchor);
			html_tag.m(raw0_value, div15);
			append_hydration(div15, t0);
			append_hydration(div15, div14);
			append_hydration(div14, div13);
			append_hydration(div13, div1);
			mount_component(imagegallery, div1, null);
			append_hydration(div1, t1);
			append_hydration(div1, div0);
			append_hydration(div1, t2);
			append_hydration(div1, h10);
			append_hydration(h10, t3);
			append_hydration(div13, t4);
			append_hydration(div13, div5);
			append_hydration(div5, h11);
			append_hydration(h11, t5);
			append_hydration(div5, t6);
			append_hydration(div5, h20);
			append_hydration(h20, t7);
			append_hydration(div5, t8);
			append_hydration(div5, p0);
			append_hydration(p0, t9);
			append_hydration(div5, t10);
			mount_component(reviews, div5, null);
			append_hydration(div5, t11);
			append_hydration(div5, form);
			html_tag_1.m(raw1_value, form);
			append_hydration(form, t12);
			append_hydration(form, input);
			append_hydration(form, t13);
			append_hydration(form, div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div2, null);
			}

			append_hydration(form, t14);
			append_hydration(form, div4);
			append_hydration(div4, label);
			append_hydration(label, t15);
			append_hydration(div4, t16);
			mount_component(quantitybox, div4, null);
			append_hydration(div4, t17);
			append_hydration(div4, div3);
			append_hydration(div3, button);
			append_hydration(button, t18);
			append_hydration(div13, t19);
			append_hydration(div13, div12);
			append_hydration(div12, div7);
			append_hydration(div7, h30);
			append_hydration(h30, t20);
			append_hydration(div7, t21);
			append_hydration(div7, div6);
			append_hydration(div6, p1);
			p1.innerHTML = raw2_value;
			append_hydration(div12, t22);
			append_hydration(div12, div9);
			append_hydration(div9, h31);
			append_hydration(h31, t23);
			append_hydration(div9, t24);
			append_hydration(div9, div8);
			append_hydration(div8, ul);
			append_hydration(ul, li0);
			append_hydration(li0, span0);
			append_hydration(span0, t25);
			append_hydration(ul, t26);
			append_hydration(ul, li1);
			append_hydration(li1, span1);
			append_hydration(span1, t27);
			append_hydration(ul, t28);
			append_hydration(ul, li2);
			append_hydration(li2, span2);
			append_hydration(span2, t29);
			append_hydration(ul, t30);
			append_hydration(ul, li3);
			append_hydration(li3, span3);
			append_hydration(span3, t31);
			append_hydration(div12, t32);
			append_hydration(div12, div11);
			append_hydration(div11, h21);
			append_hydration(h21, t33);
			append_hydration(div11, t34);
			append_hydration(div11, div10);
			append_hydration(div10, p2);
			append_hydration(p2, t35);
			current = true;
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*rawinclude_f5b8cf1c*/ 16) && raw0_value !== (raw0_value = /*rawinclude_f5b8cf1c*/ ctx[4][0] + "")) html_tag.p(raw0_value);
			const imagegallery_changes = {};
			if (dirty & /*breadcrumbs*/ 32) imagegallery_changes.breadcrumbs = /*breadcrumbs*/ ctx[5];
			if (dirty & /*breadcrumbs_size*/ 64) imagegallery_changes.breadcrumbs_size = /*breadcrumbs_size*/ ctx[6];
			if (dirty & /*price_formatted*/ 128) imagegallery_changes.price_formatted = /*price_formatted*/ ctx[7];
			if (dirty & /*product*/ 1) imagegallery_changes.product = /*product*/ ctx[0];
			if (dirty & /*productƒƒoptions_with_values*/ 256) imagegallery_changes.productƒƒoptions_with_values = /*productƒƒoptions_with_values*/ ctx[8];
			if (dirty & /*sectionƒƒsettings*/ 512) imagegallery_changes.sectionƒƒsettings = /*sectionƒƒsettings*/ ctx[9];
			if (dirty & /*productƒƒselected_or_first_available_variant*/ 1024) imagegallery_changes.productƒƒselected_or_first_available_variant = /*productƒƒselected_or_first_available_variant*/ ctx[10];
			if (dirty & /*form_props_f58d08b6b*/ 8) imagegallery_changes.form_props_f58d08b6b = /*form_props_f58d08b6b*/ ctx[3];
			if (dirty & /*form_inputs_f58d08b6b*/ 4) imagegallery_changes.form_inputs_f58d08b6b = /*form_inputs_f58d08b6b*/ ctx[2];
			if (dirty & /*rawinclude_f5b8cf1c*/ 16) imagegallery_changes.rawinclude_f5b8cf1c = /*rawinclude_f5b8cf1c*/ ctx[4];
			if (dirty & /*lec*/ 2) imagegallery_changes.lec = /*lec*/ ctx[1];
			imagegallery.$set(imagegallery_changes);
			if ((!current || dirty & /*section*/ 4096) && t3_value !== (t3_value = /*section*/ ctx[12].settings.product_title + "")) set_data(t3, t3_value);
			if ((!current || dirty & /*product*/ 1) && t5_value !== (t5_value = /*product*/ ctx[0].title + "")) set_data(t5, t5_value);
			if (!current || dirty & /*price_formatted*/ 128) set_data(t9, /*price_formatted*/ ctx[7]);
			const reviews_changes = {};
			if (dirty & /*breadcrumbs*/ 32) reviews_changes.breadcrumbs = /*breadcrumbs*/ ctx[5];
			if (dirty & /*breadcrumbs_size*/ 64) reviews_changes.breadcrumbs_size = /*breadcrumbs_size*/ ctx[6];
			if (dirty & /*price_formatted*/ 128) reviews_changes.price_formatted = /*price_formatted*/ ctx[7];
			if (dirty & /*product*/ 1) reviews_changes.product = /*product*/ ctx[0];
			if (dirty & /*productƒƒoptions_with_values*/ 256) reviews_changes.productƒƒoptions_with_values = /*productƒƒoptions_with_values*/ ctx[8];
			if (dirty & /*sectionƒƒsettings*/ 512) reviews_changes.sectionƒƒsettings = /*sectionƒƒsettings*/ ctx[9];
			if (dirty & /*productƒƒselected_or_first_available_variant*/ 1024) reviews_changes.productƒƒselected_or_first_available_variant = /*productƒƒselected_or_first_available_variant*/ ctx[10];
			if (dirty & /*form_props_f58d08b6b*/ 8) reviews_changes.form_props_f58d08b6b = /*form_props_f58d08b6b*/ ctx[3];
			if (dirty & /*form_inputs_f58d08b6b*/ 4) reviews_changes.form_inputs_f58d08b6b = /*form_inputs_f58d08b6b*/ ctx[2];
			if (dirty & /*rawinclude_f5b8cf1c*/ 16) reviews_changes.rawinclude_f5b8cf1c = /*rawinclude_f5b8cf1c*/ ctx[4];
			if (dirty & /*lec*/ 2) reviews_changes.lec = /*lec*/ ctx[1];
			reviews.$set(reviews_changes);
			if ((!current || dirty & /*form_inputs_f58d08b6b*/ 4) && raw1_value !== (raw1_value = /*form_inputs_f58d08b6b*/ ctx[2][0] + "")) html_tag_1.p(raw1_value);

			if (!current || dirty & /*product*/ 1 && input_value_value !== (input_value_value = /*product*/ ctx[0].selected_or_first_available_variant.id)) {
				input.value = input_value_value;
			}

			if (dirty & /*product, selected_options*/ 2049) {
				each_value = /*product*/ ctx[0].options_with_values;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div2, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			const quantitybox_changes = {};
			if (dirty & /*breadcrumbs*/ 32) quantitybox_changes.breadcrumbs = /*breadcrumbs*/ ctx[5];
			if (dirty & /*breadcrumbs_size*/ 64) quantitybox_changes.breadcrumbs_size = /*breadcrumbs_size*/ ctx[6];
			if (dirty & /*price_formatted*/ 128) quantitybox_changes.price_formatted = /*price_formatted*/ ctx[7];
			if (dirty & /*product*/ 1) quantitybox_changes.product = /*product*/ ctx[0];
			if (dirty & /*productƒƒoptions_with_values*/ 256) quantitybox_changes.productƒƒoptions_with_values = /*productƒƒoptions_with_values*/ ctx[8];
			if (dirty & /*sectionƒƒsettings*/ 512) quantitybox_changes.sectionƒƒsettings = /*sectionƒƒsettings*/ ctx[9];
			if (dirty & /*productƒƒselected_or_first_available_variant*/ 1024) quantitybox_changes.productƒƒselected_or_first_available_variant = /*productƒƒselected_or_first_available_variant*/ ctx[10];
			if (dirty & /*form_props_f58d08b6b*/ 8) quantitybox_changes.form_props_f58d08b6b = /*form_props_f58d08b6b*/ ctx[3];
			if (dirty & /*form_inputs_f58d08b6b*/ 4) quantitybox_changes.form_inputs_f58d08b6b = /*form_inputs_f58d08b6b*/ ctx[2];
			if (dirty & /*rawinclude_f5b8cf1c*/ 16) quantitybox_changes.rawinclude_f5b8cf1c = /*rawinclude_f5b8cf1c*/ ctx[4];
			if (dirty & /*lec*/ 2) quantitybox_changes.lec = /*lec*/ ctx[1];

			if (!updating_quantity && dirty & /*quantity*/ 8192) {
				updating_quantity = true;
				quantitybox_changes.quantity = /*quantity*/ ctx[13];
				add_flush_callback(() => updating_quantity = false);
			}

			quantitybox.$set(quantitybox_changes);

			set_attributes(form, form_data = get_spread_update(form_levels, [
				{ class: "mt-10" },
				dirty & /*form_props_f58d08b6b*/ 8 && /*form_props_f58d08b6b*/ ctx[3][0]
			]));

			if ((!current || dirty & /*product*/ 1) && raw2_value !== (raw2_value = (/*product*/ ctx[0].description || '') + "")) p1.innerHTML = raw2_value;		},
		i(local) {
			if (current) return;
			transition_in(imagegallery.$$.fragment, local);
			transition_in(reviews.$$.fragment, local);
			transition_in(quantitybox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(imagegallery.$$.fragment, local);
			transition_out(reviews.$$.fragment, local);
			transition_out(quantitybox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div15);
			destroy_component(imagegallery);
			destroy_component(reviews);
			destroy_each(each_blocks, detaching);
			destroy_component(quantitybox);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { lec } = $$props;
	let { form_inputs_f58d08b6b } = $$props;
	let { form_props_f58d08b6b } = $$props;
	let { rawinclude_f5b8cf1c } = $$props;
	let { breadcrumbs } = $$props;
	let { breadcrumbs_size } = $$props;
	let { price_formatted } = $$props;
	let { product } = $$props;
	let { productƒƒoptions_with_values } = $$props;
	product.options_with_values = productƒƒoptions_with_values;
	let section = {};
	let { sectionƒƒsettings } = $$props;
	section.settings = sectionƒƒsettings;
	let { productƒƒselected_or_first_available_variant } = $$props;
	product.selected_or_first_available_variant = productƒƒselected_or_first_available_variant;
	const JSTRFY = JSON.stringify;
	let selected_options = [null, ...product.selected_or_first_available_variant.options];
	let quantity;
	product.options_with_values[0].values[0];
	const $$binding_groups = [[]];

	function input_change_handler(option) {
		selected_options[option.position] = this.__value;
		$$invalidate(11, selected_options);
	}

	function input_change_handler_1(option) {
		selected_options[option.position] = this.__value;
		$$invalidate(11, selected_options);
	}

	function input_change_handler_2(option) {
		selected_options[option.position] = this.__value;
		$$invalidate(11, selected_options);
	}

	function input_change_handler_3(option) {
		selected_options[option.position] = this.__value;
		$$invalidate(11, selected_options);
	}

	function quantitybox_quantity_binding(value) {
		quantity = value;
		$$invalidate(13, quantity);
	}

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(1, lec = $$props.lec);
		if ('form_inputs_f58d08b6b' in $$props) $$invalidate(2, form_inputs_f58d08b6b = $$props.form_inputs_f58d08b6b);
		if ('form_props_f58d08b6b' in $$props) $$invalidate(3, form_props_f58d08b6b = $$props.form_props_f58d08b6b);
		if ('rawinclude_f5b8cf1c' in $$props) $$invalidate(4, rawinclude_f5b8cf1c = $$props.rawinclude_f5b8cf1c);
		if ('breadcrumbs' in $$props) $$invalidate(5, breadcrumbs = $$props.breadcrumbs);
		if ('breadcrumbs_size' in $$props) $$invalidate(6, breadcrumbs_size = $$props.breadcrumbs_size);
		if ('price_formatted' in $$props) $$invalidate(7, price_formatted = $$props.price_formatted);
		if ('product' in $$props) $$invalidate(0, product = $$props.product);
		if ('productƒƒoptions_with_values' in $$props) $$invalidate(8, productƒƒoptions_with_values = $$props.productƒƒoptions_with_values);
		if ('sectionƒƒsettings' in $$props) $$invalidate(9, sectionƒƒsettings = $$props.sectionƒƒsettings);
		if ('productƒƒselected_or_first_available_variant' in $$props) $$invalidate(10, productƒƒselected_or_first_available_variant = $$props.productƒƒselected_or_first_available_variant);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*product, selected_options*/ 2049) {
			$$invalidate(0, product = {
				...product,
				selected_or_first_available_variant: product.variants.find(v => JSTRFY(v.options) == JSTRFY(selected_options.slice(1)))
			});
		}

		if ($$self.$$.dirty & /*product*/ 1) {
			console.log('product ', product);
		}

		if ($$self.$$.dirty & /*selected_options*/ 2048) {
			console.log('selected_options ', selected_options);
		}

		if ($$self.$$.dirty & /*product*/ 1) {
			console.log('checked_size ', product.selected_or_first_available_variant);
		}
	};

	return [
		product,
		lec,
		form_inputs_f58d08b6b,
		form_props_f58d08b6b,
		rawinclude_f5b8cf1c,
		breadcrumbs,
		breadcrumbs_size,
		price_formatted,
		productƒƒoptions_with_values,
		sectionƒƒsettings,
		productƒƒselected_or_first_available_variant,
		selected_options,
		section,
		quantity,
		input_change_handler,
		$$binding_groups,
		input_change_handler_1,
		input_change_handler_2,
		input_change_handler_3,
		quantitybox_quantity_binding
	];
}

class Main_product extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			lec: 1,
			form_inputs_f58d08b6b: 2,
			form_props_f58d08b6b: 3,
			rawinclude_f5b8cf1c: 4,
			breadcrumbs: 5,
			breadcrumbs_size: 6,
			price_formatted: 7,
			product: 0,
			productƒƒoptions_with_values: 8,
			sectionƒƒsettings: 9,
			productƒƒselected_or_first_available_variant: 10
		});
	}
}

export { Main_product as default };
