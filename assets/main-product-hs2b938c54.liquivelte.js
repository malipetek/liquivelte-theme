import { element, text, space, claim_element, children, claim_text, detach, claim_space, attr, toggle_class, set_style, insert_hydration, append_hydration, set_input_value, listen, to_number, noop, run_all, createEventDispatcher, SvelteComponent, init, safe_not_equal, src_url_equal, destroy_each, onMount, binding_callbacks, svg_element, claim_svg_element, empty, set_data, bind, assign, HtmlTagHydration, create_component, claim_html_tag, claim_component, set_attributes, mount_component, add_flush_callback, get_spread_update, transition_in, transition_out, destroy_component } from './liquivelte-svelte-hs6e88e89c.liquivelte.js';
import { cachedLiquid } from './liquivelte-liquid-hs6dbc6cca.liquivelte.js';
import { Swiper } from './swiper.js-hs1ada1fe2.liquivelte.js';

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/snippets/quantity-box.liquivelte generated by Svelte v3.50.0 */

function create_fragment$3(ctx) {
	let div2;
	let div0;
	let t0;
	let t1;
	let input;
	let t2;
	let div1;
	let t3;
	let mounted;
	let dispose;

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			t0 = text("-");
			t1 = space();
			input = element("input");
			t2 = space();
			div1 = element("div");
			t3 = text("+");
			this.h();
		},
		l(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t0 = claim_text(div0_nodes, "-");
			div0_nodes.forEach(detach);
			t1 = claim_space(div2_nodes);

			input = claim_element(div2_nodes, "INPUT", {
				class: true,
				name: true,
				type: true,
				min: true,
				"data-quantity-input": true,
				style: true
			});

			t2 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			t3 = claim_text(div1_nodes, "+");
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "minus-icon cursor-pointer");
			toggle_class(div0, "disabled", /*quantity*/ ctx[0] <= /*minimum*/ ctx[2]);
			attr(input, "class", "quantity text-base");
			attr(input, "name", "quantity");
			attr(input, "type", "number");
			attr(input, "min", "0");
			attr(input, "data-quantity-input", "");
			set_style(input, "width", /*inputWidth*/ ctx[1]);
			attr(div1, "class", "plus-icon cursor-pointer");
			attr(div2, "class", "quantity-box");
		},
		m(target, anchor) {
			insert_hydration(target, div2, anchor);
			append_hydration(div2, div0);
			append_hydration(div0, t0);
			append_hydration(div2, t1);
			append_hydration(div2, input);
			set_input_value(input, /*quantity*/ ctx[0]);
			append_hydration(div2, t2);
			append_hydration(div2, div1);
			append_hydration(div1, t3);

			if (!mounted) {
				dispose = [
					listen(div0, "click", /*click_handler*/ ctx[5]),
					listen(input, "input", /*input_input_handler*/ ctx[6]),
					listen(div1, "click", /*click_handler_1*/ ctx[7])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*quantity, minimum*/ 5) {
				toggle_class(div0, "disabled", /*quantity*/ ctx[0] <= /*minimum*/ ctx[2]);
			}

			if (dirty & /*inputWidth*/ 2) {
				set_style(input, "width", /*inputWidth*/ ctx[1]);
			}

			if (dirty & /*quantity*/ 1 && to_number(input.value) !== /*quantity*/ ctx[0]) {
				set_input_value(input, /*quantity*/ ctx[0]);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div2);
			mounted = false;
			run_all(dispose);
		}
	};
}

let index$4 = 0;
let boxSize = 16;

function instance$3($$self, $$props, $$invalidate) {
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { inputWidth } = $$props;
	let { quantity = 1 } = $$props;
	let { minimum = 0 } = $$props;
	const dispatch = createEventDispatcher();

	const qtyChange = change => {
		// console.log('Qty change');
		$$invalidate(0, quantity = quantity + change);

		dispatch('qtychange', { quantity });
	};

	const click_handler = () => qtyChange(-1);

	function input_input_handler() {
		quantity = to_number(this.value);
		$$invalidate(0, quantity);
	}

	const click_handler_1 = () => qtyChange(1);

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(4, lec = $$props.lec);
		if ('inputWidth' in $$props) $$invalidate(1, inputWidth = $$props.inputWidth);
		if ('quantity' in $$props) $$invalidate(0, quantity = $$props.quantity);
		if ('minimum' in $$props) $$invalidate(2, minimum = $$props.minimum);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*quantity*/ 1) {
			$: $$invalidate(0, quantity = quantity == null ? 0 : quantity);
		}

		if ($$self.$$.dirty & /*quantity*/ 1) {
			$: $$invalidate(1, inputWidth = boxSize + boxSize * (quantity.toString().length - 1) * .3);
		}
	};

	return [
		quantity,
		inputWidth,
		minimum,
		qtyChange,
		lec,
		click_handler,
		input_input_handler,
		click_handler_1
	];
}

class Quantity_box extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			lec: 4,
			inputWidth: 1,
			quantity: 0,
			minimum: 2
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/sections/main-product/blocks/image-gallery.liquivelte generated by Svelte v3.50.0 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	child_ctx[12] = list;
	child_ctx[13] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[13] === 0,
		index: /*index*/ child_ctx[13] + 1,
		index0: /*index*/ child_ctx[13],
		last: /*index*/ child_ctx[13] === /*product*/ child_ctx[0].images.length - 1,
		rindex: /*product*/ child_ctx[0].images.length - /*index*/ child_ctx[13],
		rindex0: /*product*/ child_ctx[0].images.length - /*index*/ child_ctx[13] - 1,
		length: /*product*/ child_ctx[0].images.length
	};

	child_ctx[11] = constants_0;
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	child_ctx[13] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[13] === 0,
		index: /*index*/ child_ctx[13] + 1,
		index0: /*index*/ child_ctx[13],
		last: /*index*/ child_ctx[13] === /*product*/ child_ctx[0].images.length - 1,
		rindex: /*product*/ child_ctx[0].images.length - /*index*/ child_ctx[13],
		rindex0: /*product*/ child_ctx[0].images.length - /*index*/ child_ctx[13] - 1,
		length: /*product*/ child_ctx[0].images.length
	};

	child_ctx[11] = constants_0;
	return child_ctx;
}

// (322:10) {#each  product.images as image, index  }
function create_each_block_1$1(ctx) {
	let div1;
	let div0;
	let img;
	let img_src_value;
	let img_alt_value;
	let t;

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			img = element("img");
			t = space();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			img = claim_element(div0_nodes, "IMG", { src: true, alt: true, class: true });
			div0_nodes.forEach(detach);
			t = claim_space(div1_nodes);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			if (!src_url_equal(img.src, img_src_value = /*liquid*/ ctx[5].img_url(/*image*/ ctx[10], '100x'))) attr(img, "src", img_src_value);
			attr(img, "alt", img_alt_value = /*image*/ ctx[10].alt);
			attr(img, "class", "object-center object-cover");
			attr(div0, "class", "w-fit aspect-w-4 aspect-h-5 sm:rounded-lg sm:overflow-hidden lg:aspect-w-3 lg:aspect-h-4");
			attr(div1, "class", "swiper-slide slide-thumbs ");
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);
			append_hydration(div1, div0);
			append_hydration(div0, img);
			append_hydration(div1, t);
		},
		p(ctx, dirty) {
			if (dirty & /*product*/ 1 && !src_url_equal(img.src, img_src_value = /*liquid*/ ctx[5].img_url(/*image*/ ctx[10], '100x'))) {
				attr(img, "src", img_src_value);
			}

			if (dirty & /*product*/ 1 && img_alt_value !== (img_alt_value = /*image*/ ctx[10].alt)) {
				attr(img, "alt", img_alt_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div1);
		}
	};
}

// (343:6) {#each  product.images as image, index  }
function create_each_block$2(ctx) {
	let div1;
	let div0;
	let img;
	let img_src_value;
	let img_alt_value;
	let index = /*index*/ ctx[13];
	const assign_img = () => /*img_binding*/ ctx[8](img, index);
	const unassign_img = () => /*img_binding*/ ctx[8](null, index);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			img = element("img");
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true, "data-swiper-zoom": true });
			var div0_nodes = children(div0);
			img = claim_element(div0_nodes, "IMG", { src: true, alt: true, class: true });
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			if (!src_url_equal(img.src, img_src_value = /*liquid*/ ctx[5].img_url(/*image*/ ctx[10], '500x'))) attr(img, "src", img_src_value);
			attr(img, "alt", img_alt_value = /*image*/ ctx[10].alt);
			attr(img, "class", "w-full h-full object-center object-cover");
			attr(div0, "class", "swiper-zoom-container");
			attr(div0, "data-swiper-zoom", "5");
			attr(div1, "class", "swiper-slide aspect-w-4 aspect-h-5 sm:rounded-lg sm:overflow-hidden lg:aspect-w-3 lg:aspect-h-4");
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);
			append_hydration(div1, div0);
			append_hydration(div0, img);
			assign_img();
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*product*/ 1 && !src_url_equal(img.src, img_src_value = /*liquid*/ ctx[5].img_url(/*image*/ ctx[10], '500x'))) {
				attr(img, "src", img_src_value);
			}

			if (dirty & /*product*/ 1 && img_alt_value !== (img_alt_value = /*image*/ ctx[10].alt)) {
				attr(img, "alt", img_alt_value);
			}

			if (index !== /*index*/ ctx[13]) {
				unassign_img();
				index = /*index*/ ctx[13];
				assign_img();
			}
		},
		d(detaching) {
			if (detaching) detach(div1);
			unassign_img();
		}
	};
}

function create_fragment$2(ctx) {
	let div7;
	let div2;
	let div1;
	let div0;
	let t0;
	let div6;
	let div5;
	let t1;
	let div3;
	let t2;
	let div4;
	let each_value_1 = /*product*/ ctx[0].images;
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	let each_value = /*product*/ ctx[0].images;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	return {
		c() {
			div7 = element("div");
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t0 = space();
			div6 = element("div");
			div5 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			div3 = element("div");
			t2 = space();
			div4 = element("div");
			this.h();
		},
		l(nodes) {
			div7 = claim_element(nodes, "DIV", { style: true, class: true });
			var div7_nodes = children(div7);
			div2 = claim_element(div7_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			t0 = claim_space(div7_nodes);
			div6 = claim_element(div7_nodes, "DIV", { class: true });
			var div6_nodes = children(div6);
			div5 = claim_element(div6_nodes, "DIV", { class: true });
			var div5_nodes = children(div5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div5_nodes);
			}

			t1 = claim_space(div5_nodes);
			div3 = claim_element(div5_nodes, "DIV", { class: true });
			children(div3).forEach(detach);
			t2 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			children(div4).forEach(detach);
			div5_nodes.forEach(detach);
			div6_nodes.forEach(detach);
			div7_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "flex-column swiper-wrapper");
			attr(div1, "class", "mx-auto max-w-full");
			attr(div2, "class", "thumbs-slider swiper max-w-full hidden lg:flex justify-items-center overflow-hidden");
			attr(div3, "class", "swiper-button-next");
			attr(div4, "class", "swiper-button-prev");
			attr(div5, "class", "swiper-wrapper");
			attr(div6, "class", "swiper max-w-full");
			set_style(div7, "--swiper-navigation-color", "#fff");
			set_style(div7, "--swiper-pagination-color", "#fff");
			set_style(div7, "grid-template-columns", "100px auto");

			set_style(div7, "--max-height", (/*gallery_images*/ ctx[4][0]
			? /*gallery_images*/ ctx[4][0].clientHeight
			: 500) + "px");

			attr(div7, "class", "mt-6 w-2xl max-w-2xl mx-auto sm:px-6 lg:max-w-7xl lg:px-8 lg:grid justify-items-center lg:gap-8 image-gallery");
			toggle_class(div7, "uninitialized", /*initialized*/ ctx[1] != true);
		},
		m(target, anchor) {
			insert_hydration(target, div7, anchor);
			append_hydration(div7, div2);
			append_hydration(div2, div1);
			append_hydration(div1, div0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			/*div1_binding*/ ctx[7](div1);
			append_hydration(div7, t0);
			append_hydration(div7, div6);
			append_hydration(div6, div5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div5, null);
			}

			append_hydration(div5, t1);
			append_hydration(div5, div3);
			append_hydration(div5, t2);
			append_hydration(div5, div4);
			/*div6_binding*/ ctx[9](div6);
		},
		p(ctx, [dirty]) {
			if (dirty & /*liquid, product*/ 33) {
				each_value_1 = /*product*/ ctx[0].images;
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1$1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div0, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (dirty & /*liquid, product, gallery_images*/ 49) {
				each_value = /*product*/ ctx[0].images;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div5, t1);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*gallery_images*/ 16) {
				set_style(div7, "--max-height", (/*gallery_images*/ ctx[4][0]
				? /*gallery_images*/ ctx[4][0].clientHeight
				: 500) + "px");
			}

			if (dirty & /*initialized*/ 2) {
				toggle_class(div7, "uninitialized", /*initialized*/ ctx[1] != true);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div7);
			destroy_each(each_blocks_1, detaching);
			/*div1_binding*/ ctx[7](null);
			destroy_each(each_blocks, detaching);
			/*div6_binding*/ ctx[9](null);
		}
	};
}

let index$3 = 0;

function instance$2($$self, $$props, $$invalidate) {
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { product } = $$props;
	let initialized;
	let galleryElement, thubmnailsElement;
	let gallery_images = [];

	onMount(() => {
		const thumbnailsSwiper = new Swiper(thubmnailsElement,
		{
				slidesPerView: 5,
				spaceBetween: 10,
				watchSlidesProgress: true,
				direction: 'vertical'
			});

		const swiper = new Swiper(galleryElement,
		{
				zoom: true,
				loop: true,
				slidesPerView: 1,
				navigation: {
					nextEl: ".swiper-button-next",
					prevEl: ".swiper-button-prev"
				},
				thumbs: { swiper: thumbnailsSwiper }
			});

		$$invalidate(1, initialized = true);
		console.log('gallery_images ', gallery_images);
	});

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			thubmnailsElement = $$value;
			$$invalidate(3, thubmnailsElement);
		});
	}

	function img_binding($$value, index) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			gallery_images[index] = $$value;
			$$invalidate(4, gallery_images);
		});
	}

	function div6_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			galleryElement = $$value;
			$$invalidate(2, galleryElement);
		});
	}

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(6, lec = $$props.lec);
		if ('product' in $$props) $$invalidate(0, product = $$props.product);
	};

	return [
		product,
		initialized,
		galleryElement,
		thubmnailsElement,
		gallery_images,
		liquid,
		lec,
		div1_binding,
		img_binding,
		div6_binding
	];
}

class Image_gallery extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { lec: 6, product: 0 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/sections/main-product/blocks/reviews.liquivelte generated by Svelte v3.50.0 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	child_ctx[8] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[8] === 0,
		index: /*index*/ child_ctx[8] + 1,
		index0: /*index*/ child_ctx[8],
		last: /*index*/ child_ctx[8] === /*review_stars*/ child_ctx[0].length - 1,
		rindex: /*review_stars*/ child_ctx[0].length - /*index*/ child_ctx[8],
		rindex0: /*review_stars*/ child_ctx[0].length - /*index*/ child_ctx[8] - 1,
		length: /*review_stars*/ child_ctx[0].length
	};

	child_ctx[6] = constants_0;
	return child_ctx;
}

// (37:8) {:else}
function create_else_block$1(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			this.h();
		},
		l(nodes) {
			svg = claim_svg_element(nodes, "svg", {
				class: true,
				xmlns: true,
				viewBox: true,
				fill: true,
				"aria-hidden": true
			});

			var svg_nodes = children(svg);
			path = claim_svg_element(svg_nodes, "path", { d: true });
			children(path).forEach(detach);
			svg_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path, "d", "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z");
			attr(svg, "class", "text-gray-900 h-5 w-5 flex-shrink-0");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "viewBox", "0 0 20 20");
			attr(svg, "fill", "currentColor");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert_hydration(target, svg, anchor);
			append_hydration(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (32:8) {#if score < forloop.index }
function create_if_block$1(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = svg_element("svg");
			path = svg_element("path");
			this.h();
		},
		l(nodes) {
			svg = claim_svg_element(nodes, "svg", {
				class: true,
				xmlns: true,
				viewBox: true,
				fill: true,
				"aria-hidden": true
			});

			var svg_nodes = children(svg);
			path = claim_svg_element(svg_nodes, "path", { d: true });
			children(path).forEach(detach);
			svg_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path, "d", "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z");
			attr(svg, "class", "text-gray-200 h-5 w-5 flex-shrink-0");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "viewBox", "0 0 20 20");
			attr(svg, "fill", "currentColor");
			attr(svg, "aria-hidden", "true");
		},
		m(target, anchor) {
			insert_hydration(target, svg, anchor);
			append_hydration(svg, path);
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

// (22:6) {#each  review_stars as star, index  }
function create_each_block$1(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*score*/ ctx[1] < /*forloop*/ ctx[6].index) return create_if_block$1;
		return create_else_block$1;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type !== (current_block_type = select_block_type(ctx, dirty))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$1(ctx) {
	let div2;
	let h3;
	let t0;
	let t1;
	let div1;
	let div0;
	let t2;
	let p;
	let t3;
	let t4;
	let a;
	let t5;
	let t6;
	let each_value = /*review_stars*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	return {
		c() {
			div2 = element("div");
			h3 = element("h3");
			t0 = text("Reviews");
			t1 = space();
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			p = element("p");
			t3 = text("4 out of 5 stars");
			t4 = space();
			a = element("a");
			t5 = text(/*reviews_count*/ ctx[2]);
			t6 = text(" reviews");
			this.h();
		},
		l(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h3 = claim_element(div2_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, "Reviews");
			h3_nodes.forEach(detach);
			t1 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach);
			t2 = claim_space(div1_nodes);
			p = claim_element(div1_nodes, "P", { class: true });
			var p_nodes = children(p);
			t3 = claim_text(p_nodes, "4 out of 5 stars");
			p_nodes.forEach(detach);
			t4 = claim_space(div1_nodes);
			a = claim_element(div1_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t5 = claim_text(a_nodes, /*reviews_count*/ ctx[2]);
			t6 = claim_text(a_nodes, " reviews");
			a_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(h3, "class", "sr-only");
			attr(div0, "class", "flex items-center");
			attr(p, "class", "sr-only");
			attr(a, "href", "#");
			attr(a, "class", "ml-3 text-sm font-medium text-indigo-600 hover:text-indigo-500");
			attr(div1, "class", "flex items-center");
			attr(div2, "class", "mt-6");
		},
		m(target, anchor) {
			insert_hydration(target, div2, anchor);
			append_hydration(div2, h3);
			append_hydration(h3, t0);
			append_hydration(div2, t1);
			append_hydration(div2, div1);
			append_hydration(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			append_hydration(div1, t2);
			append_hydration(div1, p);
			append_hydration(p, t3);
			append_hydration(div1, t4);
			append_hydration(div1, a);
			append_hydration(a, t5);
			append_hydration(a, t6);
		},
		p(ctx, [dirty]) {
			if (dirty & /*score, review_stars*/ 3) {
				each_value = /*review_stars*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*reviews_count*/ 4) set_data(t5, /*reviews_count*/ ctx[2]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div2);
			destroy_each(each_blocks, detaching);
		}
	};
}

let index$2 = 0;

function instance$1($$self, $$props, $$invalidate) {
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { review_stars } = $$props;
	let { score } = $$props;
	let { reviews_count } = $$props;

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(3, lec = $$props.lec);
		if ('review_stars' in $$props) $$invalidate(0, review_stars = $$props.review_stars);
		if ('score' in $$props) $$invalidate(1, score = $$props.score);
		if ('reviews_count' in $$props) $$invalidate(2, reviews_count = $$props.reviews_count);
	};

	return [review_stars, score, reviews_count, lec];
}

class Reviews extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			lec: 3,
			review_stars: 0,
			score: 1,
			reviews_count: 2
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/sections/main-product/index.liquivelte generated by Svelte v3.50.0 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[27] = list[i];
	child_ctx[30] = list;
	child_ctx[31] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[31] === 0,
		index: /*index*/ child_ctx[31] + 1,
		index0: /*index*/ child_ctx[31],
		last: /*index*/ child_ctx[31] === /*product*/ child_ctx[0].options_with_values.length - 1,
		rindex: /*product*/ child_ctx[0].options_with_values.length - /*index*/ child_ctx[31],
		rindex0: /*product*/ child_ctx[0].options_with_values.length - /*index*/ child_ctx[31] - 1,
		length: /*product*/ child_ctx[0].options_with_values.length
	};

	child_ctx[28] = constants_0;
	const constants_1 = /*forloop*/ child_ctx[28].index0;
	child_ctx[29] = constants_1;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[32] = list[i];
	child_ctx[31] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[31] === 0,
		index: /*index*/ child_ctx[31] + 1,
		index0: /*index*/ child_ctx[31],
		last: /*index*/ child_ctx[31] === /*option*/ child_ctx[27].values.length - 1,
		rindex: /*option*/ child_ctx[27].values.length - /*index*/ child_ctx[31],
		rindex0: /*option*/ child_ctx[27].values.length - /*index*/ child_ctx[31] - 1,
		length: /*option*/ child_ctx[27].values.length
	};

	child_ctx[28] = constants_0;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[32] = list[i];
	child_ctx[31] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[31] === 0,
		index: /*index*/ child_ctx[31] + 1,
		index0: /*index*/ child_ctx[31],
		last: /*index*/ child_ctx[31] === /*option*/ child_ctx[27].values.length - 1,
		rindex: /*option*/ child_ctx[27].values.length - /*index*/ child_ctx[31],
		rindex0: /*option*/ child_ctx[27].values.length - /*index*/ child_ctx[31] - 1,
		length: /*option*/ child_ctx[27].values.length
	};

	child_ctx[28] = constants_0;
	return child_ctx;
}

// (1090:16) {:else}
function create_else_block_1(ctx) {
	let div;
	let each_value_2 = /*option*/ ctx[27].values;
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "grid grid-cols-4 gap-4 sm:grid-cols-8 lg:grid-cols-4");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*product, selected_options*/ 32769) {
				each_value_2 = /*option*/ ctx[27].values;
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (1063:16) {#if option.name == 'Color' }
function create_if_block(ctx) {
	let div;
	let each_value_1 = /*option*/ ctx[27].values;
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "flex items-center space-x-3");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*product, selected_options*/ 32769) {
				each_value_1 = /*option*/ ctx[27].values;
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (1110:24) {:else}
function create_else_block_2(ctx) {
	let input;
	let input_value_value;
	let mounted;
	let dispose;
	/*$$binding_groups*/ ctx[19][0][/*index*/ ctx[31]] = [];

	function input_change_handler_3() {
		/*input_change_handler_3*/ ctx[22].call(input, /*option*/ ctx[27]);
	}

	return {
		c() {
			input = element("input");
			this.h();
		},
		l(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				name: true,
				class: true,
				"aria-labelledby": true
			});

			this.h();
		},
		h() {
			attr(input, "type", "radio");
			attr(input, "name", "size-choice");
			input.__value = input_value_value = /*value*/ ctx[32];
			input.value = input.__value;
			attr(input, "class", "sr-only");
			attr(input, "aria-labelledby", "size-choice-1-label");
			/*$$binding_groups*/ ctx[19][0][/*index*/ ctx[31]].push(input);
		},
		m(target, anchor) {
			insert_hydration(target, input, anchor);
			input.checked = input.__value === /*selected_options*/ ctx[15][/*option*/ ctx[27].position];

			if (!mounted) {
				dispose = listen(input, "change", input_change_handler_3);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*product*/ 1 && input_value_value !== (input_value_value = /*value*/ ctx[32])) {
				input.__value = input_value_value;
				input.value = input.__value;
			}

			if (dirty[0] & /*selected_options, product*/ 32769) {
				input.checked = input.__value === /*selected_options*/ ctx[15][/*option*/ ctx[27].position];
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			/*$$binding_groups*/ ctx[19][0][/*index*/ ctx[31]].splice(/*$$binding_groups*/ ctx[19][0][/*index*/ ctx[31]].indexOf(input), 1);
			mounted = false;
			dispose();
		}
	};
}

// (1108:24) {#if value == product.selected_or_first_available_variant.options[option_index] }
function create_if_block_2(ctx) {
	let input;
	let input_value_value;
	let mounted;
	let dispose;
	/*$$binding_groups*/ ctx[19][0][/*index*/ ctx[31]] = [];

	function input_change_handler_2() {
		/*input_change_handler_2*/ ctx[21].call(input, /*option*/ ctx[27]);
	}

	return {
		c() {
			input = element("input");
			this.h();
		},
		l(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				name: true,
				class: true,
				"aria-labelledby": true
			});

			this.h();
		},
		h() {
			attr(input, "type", "radio");
			attr(input, "name", "size-choice");
			input.__value = input_value_value = /*value*/ ctx[32];
			input.value = input.__value;
			attr(input, "class", "sr-only");
			attr(input, "aria-labelledby", "size-choice-1-label");
			input.checked = true;
			/*$$binding_groups*/ ctx[19][0][/*index*/ ctx[31]].push(input);
		},
		m(target, anchor) {
			insert_hydration(target, input, anchor);
			input.checked = input.__value === /*selected_options*/ ctx[15][/*option*/ ctx[27].position];

			if (!mounted) {
				dispose = listen(input, "change", input_change_handler_2);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*product*/ 1 && input_value_value !== (input_value_value = /*value*/ ctx[32])) {
				input.__value = input_value_value;
				input.value = input.__value;
			}

			if (dirty[0] & /*selected_options, product*/ 32769) {
				input.checked = input.__value === /*selected_options*/ ctx[15][/*option*/ ctx[27].position];
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			/*$$binding_groups*/ ctx[19][0][/*index*/ ctx[31]].splice(/*$$binding_groups*/ ctx[19][0][/*index*/ ctx[31]].indexOf(input), 1);
			mounted = false;
			dispose();
		}
	};
}

// (1092:18) {#each  option.values as value, index  }
function create_each_block_2(ctx) {
	let label;
	let t0;
	let p;
	let t1_value = /*value*/ ctx[32] + "";
	let t1;
	let t2;
	let div;
	let t3;

	function select_block_type_2(ctx, dirty) {
		if (/*value*/ ctx[32] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[29]]) return create_if_block_2;
		return create_else_block_2;
	}

	let current_block_type = select_block_type_2(ctx, [-1, -1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			label = element("label");
			if_block.c();
			t0 = space();
			p = element("p");
			t1 = text(t1_value);
			t2 = space();
			div = element("div");
			t3 = space();
			this.h();
		},
		l(nodes) {
			label = claim_element(nodes, "LABEL", { class: true });
			var label_nodes = children(label);
			if_block.l(label_nodes);
			t0 = claim_space(label_nodes);
			p = claim_element(label_nodes, "P", { id: true });
			var p_nodes = children(p);
			t1 = claim_text(p_nodes, t1_value);
			p_nodes.forEach(detach);
			t2 = claim_space(label_nodes);
			div = claim_element(label_nodes, "DIV", { class: true, "aria-hidden": true });
			children(div).forEach(detach);
			t3 = claim_space(label_nodes);
			label_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(p, "id", "size-choice-1-label");
			attr(div, "class", "absolute -inset-px rounded-md pointer-events-none");
			attr(div, "aria-hidden", "true");
			attr(label, "class", "group relative border rounded-md py-3 hover:bg-indigo-400 hover:text-white px-4 flex items-center justify-center text-sm font-medium uppercase focus:outline-none sm:flex-1 sm:py-6 bg-white shadow-sm cursor-pointer");
			toggle_class(label, "bg-indigo-600", /*value*/ ctx[32] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[29]]);
			toggle_class(label, "text-white", /*value*/ ctx[32] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[29]]);
			toggle_class(label, "text-gray-900", /*value*/ ctx[32] != /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[29]]);
		},
		m(target, anchor) {
			insert_hydration(target, label, anchor);
			if_block.m(label, null);
			append_hydration(label, t0);
			append_hydration(label, p);
			append_hydration(p, t1);
			append_hydration(label, t2);
			append_hydration(label, div);
			append_hydration(label, t3);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_2(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(label, t0);
				}
			}

			if (dirty[0] & /*product*/ 1 && t1_value !== (t1_value = /*value*/ ctx[32] + "")) set_data(t1, t1_value);

			if (dirty[0] & /*product*/ 1) {
				toggle_class(label, "bg-indigo-600", /*value*/ ctx[32] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[29]]);
			}

			if (dirty[0] & /*product*/ 1) {
				toggle_class(label, "text-white", /*value*/ ctx[32] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[29]]);
			}

			if (dirty[0] & /*product*/ 1) {
				toggle_class(label, "text-gray-900", /*value*/ ctx[32] != /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[29]]);
			}
		},
		d(detaching) {
			if (detaching) detach(label);
			if_block.d();
		}
	};
}

// (1082:22) {:else}
function create_else_block(ctx) {
	let input;
	let input_value_value;
	let mounted;
	let dispose;
	/*$$binding_groups*/ ctx[19][0][/*index*/ ctx[31]] = [];

	function input_change_handler_1() {
		/*input_change_handler_1*/ ctx[20].call(input, /*option*/ ctx[27]);
	}

	return {
		c() {
			input = element("input");
			this.h();
		},
		l(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				name: true,
				class: true,
				"aria-labelledby": true
			});

			this.h();
		},
		h() {
			attr(input, "type", "radio");
			attr(input, "name", "color-choice");
			input.__value = input_value_value = /*value*/ ctx[32];
			input.value = input.__value;
			attr(input, "class", "sr-only");
			attr(input, "aria-labelledby", "color-choice-0-label");
			/*$$binding_groups*/ ctx[19][0][/*index*/ ctx[31]].push(input);
		},
		m(target, anchor) {
			insert_hydration(target, input, anchor);
			input.checked = input.__value === /*selected_options*/ ctx[15][/*option*/ ctx[27].position];

			if (!mounted) {
				dispose = listen(input, "change", input_change_handler_1);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*product*/ 1 && input_value_value !== (input_value_value = /*value*/ ctx[32])) {
				input.__value = input_value_value;
				input.value = input.__value;
			}

			if (dirty[0] & /*selected_options, product*/ 32769) {
				input.checked = input.__value === /*selected_options*/ ctx[15][/*option*/ ctx[27].position];
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			/*$$binding_groups*/ ctx[19][0][/*index*/ ctx[31]].splice(/*$$binding_groups*/ ctx[19][0][/*index*/ ctx[31]].indexOf(input), 1);
			mounted = false;
			dispose();
		}
	};
}

// (1080:22) {#if value == product.selected_or_first_available_variant.options[option_index] }
function create_if_block_1(ctx) {
	let input;
	let input_value_value;
	let mounted;
	let dispose;
	/*$$binding_groups*/ ctx[19][0][/*index*/ ctx[31]] = [];

	function input_change_handler() {
		/*input_change_handler*/ ctx[18].call(input, /*option*/ ctx[27]);
	}

	return {
		c() {
			input = element("input");
			this.h();
		},
		l(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				name: true,
				class: true,
				"aria-labelledby": true
			});

			this.h();
		},
		h() {
			attr(input, "type", "radio");
			attr(input, "name", "color-choice");
			input.__value = input_value_value = /*value*/ ctx[32];
			input.value = input.__value;
			attr(input, "class", "sr-only");
			attr(input, "aria-labelledby", "color-choice-0-label");
			input.checked = true;
			/*$$binding_groups*/ ctx[19][0][/*index*/ ctx[31]].push(input);
		},
		m(target, anchor) {
			insert_hydration(target, input, anchor);
			input.checked = input.__value === /*selected_options*/ ctx[15][/*option*/ ctx[27].position];

			if (!mounted) {
				dispose = listen(input, "change", input_change_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*product*/ 1 && input_value_value !== (input_value_value = /*value*/ ctx[32])) {
				input.__value = input_value_value;
				input.value = input.__value;
			}

			if (dirty[0] & /*selected_options, product*/ 32769) {
				input.checked = input.__value === /*selected_options*/ ctx[15][/*option*/ ctx[27].position];
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			/*$$binding_groups*/ ctx[19][0][/*index*/ ctx[31]].splice(/*$$binding_groups*/ ctx[19][0][/*index*/ ctx[31]].indexOf(input), 1);
			mounted = false;
			dispose();
		}
	};
}

// (1065:18) {#each  option.values as value, index  }
function create_each_block_1(ctx) {
	let label;
	let t0;
	let p;
	let t1_value = /*value*/ ctx[32] + "";
	let t1;
	let t2;
	let span;
	let t3;

	function select_block_type_1(ctx, dirty) {
		if (/*value*/ ctx[32] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[29]]) return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx, [-1, -1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			label = element("label");
			if_block.c();
			t0 = space();
			p = element("p");
			t1 = text(t1_value);
			t2 = space();
			span = element("span");
			t3 = space();
			this.h();
		},
		l(nodes) {
			label = claim_element(nodes, "LABEL", { class: true });
			var label_nodes = children(label);
			if_block.l(label_nodes);
			t0 = claim_space(label_nodes);
			p = claim_element(label_nodes, "P", { id: true, class: true });
			var p_nodes = children(p);
			t1 = claim_text(p_nodes, t1_value);
			p_nodes.forEach(detach);
			t2 = claim_space(label_nodes);
			span = claim_element(label_nodes, "SPAN", { "aria-hidden": true, class: true });
			children(span).forEach(detach);
			t3 = claim_space(label_nodes);
			label_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(p, "id", "color-choice-0-label");
			attr(p, "class", "sr-only");
			attr(span, "aria-hidden", "true");
			attr(span, "class", "h-8 w-8 bg-white border border-black border-opacity-10 rounded-full");
			attr(label, "class", "-m-0.5 relative p-0.5 rounded-full flex items-center justify-center cursor-pointer focus:outline-none ring-gray-400");
			toggle_class(label, "ring", /*value*/ ctx[32] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[29]]);
			toggle_class(label, "ring-offset-1", /*value*/ ctx[32] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[29]]);
		},
		m(target, anchor) {
			insert_hydration(target, label, anchor);
			if_block.m(label, null);
			append_hydration(label, t0);
			append_hydration(label, p);
			append_hydration(p, t1);
			append_hydration(label, t2);
			append_hydration(label, span);
			append_hydration(label, t3);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(label, t0);
				}
			}

			if (dirty[0] & /*product*/ 1 && t1_value !== (t1_value = /*value*/ ctx[32] + "")) set_data(t1, t1_value);

			if (dirty[0] & /*product*/ 1) {
				toggle_class(label, "ring", /*value*/ ctx[32] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[29]]);
			}

			if (dirty[0] & /*product*/ 1) {
				toggle_class(label, "ring-offset-1", /*value*/ ctx[32] == /*product*/ ctx[0].selected_or_first_available_variant.options[/*option_index*/ ctx[29]]);
			}
		},
		d(detaching) {
			if (detaching) detach(label);
			if_block.d();
		}
	};
}

// (1045:12) {#each  product.options_with_values as option, index  }
function create_each_block(ctx) {
	let h3;
	let t0;
	let t1_value = /*option*/ ctx[27].name + "";
	let t1;
	let t2;
	let fieldset;
	let legend;
	let t3;
	let t4_value = /*option*/ ctx[27].name + "";
	let t4;
	let t5;
	let t6;

	function select_block_type(ctx, dirty) {
		if (/*option*/ ctx[27].name == 'Color') return create_if_block;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx, [-1, -1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			h3 = element("h3");
			t0 = text("Choose a ");
			t1 = text(t1_value);
			t2 = space();
			fieldset = element("fieldset");
			legend = element("legend");
			t3 = text("Choose a ");
			t4 = text(t4_value);
			t5 = space();
			if_block.c();
			t6 = space();
			this.h();
		},
		l(nodes) {
			h3 = claim_element(nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, "Choose a ");
			t1 = claim_text(h3_nodes, t1_value);
			h3_nodes.forEach(detach);
			t2 = claim_space(nodes);
			fieldset = claim_element(nodes, "FIELDSET", { class: true });
			var fieldset_nodes = children(fieldset);
			legend = claim_element(fieldset_nodes, "LEGEND", { class: true });
			var legend_nodes = children(legend);
			t3 = claim_text(legend_nodes, "Choose a ");
			t4 = claim_text(legend_nodes, t4_value);
			legend_nodes.forEach(detach);
			t5 = claim_space(fieldset_nodes);
			if_block.l(fieldset_nodes);
			t6 = claim_space(fieldset_nodes);
			fieldset_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(h3, "class", "text-sm text-gray-900 font-medium mt-4");
			attr(legend, "class", "sr-only");
			attr(fieldset, "class", "mt-4");
		},
		m(target, anchor) {
			insert_hydration(target, h3, anchor);
			append_hydration(h3, t0);
			append_hydration(h3, t1);
			insert_hydration(target, t2, anchor);
			insert_hydration(target, fieldset, anchor);
			append_hydration(fieldset, legend);
			append_hydration(legend, t3);
			append_hydration(legend, t4);
			append_hydration(fieldset, t5);
			if_block.m(fieldset, null);
			append_hydration(fieldset, t6);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*product*/ 1 && t1_value !== (t1_value = /*option*/ ctx[27].name + "")) set_data(t1, t1_value);
			if (dirty[0] & /*product*/ 1 && t4_value !== (t4_value = /*option*/ ctx[27].name + "")) set_data(t4, t4_value);

			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(fieldset, t6);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(h3);
			if (detaching) detach(t2);
			if (detaching) detach(fieldset);
			if_block.d();
		}
	};
}

function create_fragment(ctx) {
	let div15;
	let html_tag;
	let raw0_value = /*rawinclude_f5b8cf1c*/ ctx[4][index || 0] + "";
	let t0;
	let div14;
	let div13;
	let div1;
	let imagegallery;
	let t1;
	let div0;
	let t2;
	let h10;
	let t3_value = /*section*/ ctx[16].settings.product_title + "";
	let t3;
	let t4;
	let div5;
	let h11;
	let t5_value = /*product*/ ctx[0].title + "";
	let t5;
	let t6;
	let h20;
	let t7;
	let t8;
	let p0;
	let t9;
	let t10;
	let reviews;
	let t11;
	let form;
	let html_tag_1;
	let raw1_value = /*form_inputs_f58d08b6b*/ ctx[2][index || 0] + "";
	let t12;
	let input;
	let input_value_value;
	let t13;
	let div2;
	let t14;
	let div4;
	let label;
	let t15;
	let t16;
	let quantitybox;
	let updating_quantity;
	let t17;
	let div3;
	let button;
	let t18;
	let t19;
	let div12;
	let div7;
	let h30;
	let t20;
	let t21;
	let div6;
	let p1;
	let raw2_value = (/*product*/ ctx[0].description || '') + "";
	let t22;
	let div9;
	let h31;
	let t23;
	let t24;
	let div8;
	let ul;
	let li0;
	let span0;
	let t25;
	let t26;
	let li1;
	let span1;
	let t27;
	let t28;
	let li2;
	let span2;
	let t29;
	let t30;
	let li3;
	let span3;
	let t31;
	let t32;
	let div11;
	let h21;
	let t33;
	let t34;
	let div10;
	let p2;
	let t35;
	let current;

	imagegallery = new Image_gallery({
			props: {
				review_stars: /*review_stars*/ ctx[8],
				score: /*score*/ ctx[7],
				reviews_count: /*reviews_count*/ ctx[6],
				product: /*product*/ ctx[0],
				inputWidth: /*inputWidth*/ ctx[5],
				breadcrumbs: /*breadcrumbs*/ ctx[9],
				breadcrumbs_size: /*breadcrumbs_size*/ ctx[10],
				price_formatted: /*price_formatted*/ ctx[11],
				product$options_with_values: /*product$options_with_values*/ ctx[12],
				section$settings: /*section$settings*/ ctx[13],
				product$selected_or_first_available_variant: /*product$selected_or_first_available_variant*/ ctx[14],
				form_props_f58d08b6b: /*form_props_f58d08b6b*/ ctx[3],
				form_inputs_f58d08b6b: /*form_inputs_f58d08b6b*/ ctx[2],
				rawinclude_f5b8cf1c: /*rawinclude_f5b8cf1c*/ ctx[4],
				lec: /*lec*/ ctx[1]
			}
		});

	reviews = new Reviews({
			props: {
				review_stars: /*review_stars*/ ctx[8],
				score: /*score*/ ctx[7],
				reviews_count: /*reviews_count*/ ctx[6],
				product: /*product*/ ctx[0],
				inputWidth: /*inputWidth*/ ctx[5],
				breadcrumbs: /*breadcrumbs*/ ctx[9],
				breadcrumbs_size: /*breadcrumbs_size*/ ctx[10],
				price_formatted: /*price_formatted*/ ctx[11],
				product$options_with_values: /*product$options_with_values*/ ctx[12],
				section$settings: /*section$settings*/ ctx[13],
				product$selected_or_first_available_variant: /*product$selected_or_first_available_variant*/ ctx[14],
				form_props_f58d08b6b: /*form_props_f58d08b6b*/ ctx[3],
				form_inputs_f58d08b6b: /*form_inputs_f58d08b6b*/ ctx[2],
				rawinclude_f5b8cf1c: /*rawinclude_f5b8cf1c*/ ctx[4],
				lec: /*lec*/ ctx[1]
			}
		});

	let each_value = /*product*/ ctx[0].options_with_values;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	function quantitybox_quantity_binding(value) {
		/*quantitybox_quantity_binding*/ ctx[23](value);
	}

	let quantitybox_props = {
		review_stars: /*review_stars*/ ctx[8],
		score: /*score*/ ctx[7],
		reviews_count: /*reviews_count*/ ctx[6],
		product: /*product*/ ctx[0],
		inputWidth: /*inputWidth*/ ctx[5],
		breadcrumbs: /*breadcrumbs*/ ctx[9],
		breadcrumbs_size: /*breadcrumbs_size*/ ctx[10],
		price_formatted: /*price_formatted*/ ctx[11],
		product$options_with_values: /*product$options_with_values*/ ctx[12],
		section$settings: /*section$settings*/ ctx[13],
		product$selected_or_first_available_variant: /*product$selected_or_first_available_variant*/ ctx[14],
		form_props_f58d08b6b: /*form_props_f58d08b6b*/ ctx[3],
		form_inputs_f58d08b6b: /*form_inputs_f58d08b6b*/ ctx[2],
		rawinclude_f5b8cf1c: /*rawinclude_f5b8cf1c*/ ctx[4],
		lec: /*lec*/ ctx[1]
	};

	if (/*quantity*/ ctx[17] !== void 0) {
		quantitybox_props.quantity = /*quantity*/ ctx[17];
	}

	quantitybox = new Quantity_box({ props: quantitybox_props });
	binding_callbacks.push(() => bind(quantitybox, 'quantity', quantitybox_quantity_binding));
	let form_levels = [{ class: "mt-10" }, /*form_props_f58d08b6b*/ ctx[3][index || 0]];
	let form_data = {};

	for (let i = 0; i < form_levels.length; i += 1) {
		form_data = assign(form_data, form_levels[i]);
	}

	return {
		c() {
			div15 = element("div");
			html_tag = new HtmlTagHydration(false);
			t0 = space();
			div14 = element("div");
			div13 = element("div");
			div1 = element("div");
			create_component(imagegallery.$$.fragment);
			t1 = space();
			div0 = element("div");
			t2 = space();
			h10 = element("h1");
			t3 = text(t3_value);
			t4 = space();
			div5 = element("div");
			h11 = element("h1");
			t5 = text(t5_value);
			t6 = space();
			h20 = element("h2");
			t7 = text("Product information");
			t8 = space();
			p0 = element("p");
			t9 = text(/*price_formatted*/ ctx[11]);
			t10 = space();
			create_component(reviews.$$.fragment);
			t11 = space();
			form = element("form");
			html_tag_1 = new HtmlTagHydration(false);
			t12 = space();
			input = element("input");
			t13 = space();
			div2 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t14 = space();
			div4 = element("div");
			label = element("label");
			t15 = text("Quantity");
			t16 = space();
			create_component(quantitybox.$$.fragment);
			t17 = space();
			div3 = element("div");
			button = element("button");
			t18 = text("Add to bag");
			t19 = space();
			div12 = element("div");
			div7 = element("div");
			h30 = element("h3");
			t20 = text("Description");
			t21 = space();
			div6 = element("div");
			p1 = element("p");
			t22 = space();
			div9 = element("div");
			h31 = element("h3");
			t23 = text("Highlights");
			t24 = space();
			div8 = element("div");
			ul = element("ul");
			li0 = element("li");
			span0 = element("span");
			t25 = text("Hand cut and sewn locally");
			t26 = space();
			li1 = element("li");
			span1 = element("span");
			t27 = text("Dyed with our proprietary colors");
			t28 = space();
			li2 = element("li");
			span2 = element("span");
			t29 = text("Pre-washed & pre-shrunk");
			t30 = space();
			li3 = element("li");
			span3 = element("span");
			t31 = text("Ultra-soft 100% cotton");
			t32 = space();
			div11 = element("div");
			h21 = element("h2");
			t33 = text("Details");
			t34 = space();
			div10 = element("div");
			p2 = element("p");
			t35 = text("The 6-Pack includes two black, two white, and two heather gray Basic Tees. Sign up for our subscription service and be the first to get new, exciting colors, like our upcoming \"Charcoal Gray\" limited release.");
			this.h();
		},
		l(nodes) {
			div15 = claim_element(nodes, "DIV", { class: true });
			var div15_nodes = children(div15);
			html_tag = claim_html_tag(div15_nodes, false);
			t0 = claim_space(div15_nodes);
			div14 = claim_element(div15_nodes, "DIV", { class: true });
			var div14_nodes = children(div14);
			div13 = claim_element(div14_nodes, "DIV", { class: true });
			var div13_nodes = children(div13);
			div1 = claim_element(div13_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(imagegallery.$$.fragment, div1_nodes);
			t1 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			children(div0).forEach(detach);
			t2 = claim_space(div1_nodes);
			h10 = claim_element(div1_nodes, "H1", { class: true });
			var h10_nodes = children(h10);
			t3 = claim_text(h10_nodes, t3_value);
			h10_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t4 = claim_space(div13_nodes);
			div5 = claim_element(div13_nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			h11 = claim_element(div5_nodes, "H1", { class: true });
			var h11_nodes = children(h11);
			t5 = claim_text(h11_nodes, t5_value);
			h11_nodes.forEach(detach);
			t6 = claim_space(div5_nodes);
			h20 = claim_element(div5_nodes, "H2", { class: true });
			var h20_nodes = children(h20);
			t7 = claim_text(h20_nodes, "Product information");
			h20_nodes.forEach(detach);
			t8 = claim_space(div5_nodes);
			p0 = claim_element(div5_nodes, "P", { class: true });
			var p0_nodes = children(p0);
			t9 = claim_text(p0_nodes, /*price_formatted*/ ctx[11]);
			p0_nodes.forEach(detach);
			t10 = claim_space(div5_nodes);
			claim_component(reviews.$$.fragment, div5_nodes);
			t11 = claim_space(div5_nodes);
			form = claim_element(div5_nodes, "FORM", { class: true });
			var form_nodes = children(form);
			html_tag_1 = claim_html_tag(form_nodes, false);
			t12 = claim_space(form_nodes);
			input = claim_element(form_nodes, "INPUT", { type: true, name: true });
			t13 = claim_space(form_nodes);
			div2 = claim_element(form_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div2_nodes);
			}

			div2_nodes.forEach(detach);
			t14 = claim_space(form_nodes);
			div4 = claim_element(form_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			label = claim_element(div4_nodes, "LABEL", { class: true });
			var label_nodes = children(label);
			t15 = claim_text(label_nodes, "Quantity");
			label_nodes.forEach(detach);
			t16 = claim_space(div4_nodes);
			claim_component(quantitybox.$$.fragment, div4_nodes);
			t17 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", {});
			var div3_nodes = children(div3);
			button = claim_element(div3_nodes, "BUTTON", { type: true, class: true });
			var button_nodes = children(button);
			t18 = claim_text(button_nodes, "Add to bag");
			button_nodes.forEach(detach);
			div3_nodes.forEach(detach);
			div4_nodes.forEach(detach);
			form_nodes.forEach(detach);
			div5_nodes.forEach(detach);
			t19 = claim_space(div13_nodes);
			div12 = claim_element(div13_nodes, "DIV", { class: true });
			var div12_nodes = children(div12);
			div7 = claim_element(div12_nodes, "DIV", {});
			var div7_nodes = children(div7);
			h30 = claim_element(div7_nodes, "H3", { class: true });
			var h30_nodes = children(h30);
			t20 = claim_text(h30_nodes, "Description");
			h30_nodes.forEach(detach);
			t21 = claim_space(div7_nodes);
			div6 = claim_element(div7_nodes, "DIV", { class: true });
			var div6_nodes = children(div6);
			p1 = claim_element(div6_nodes, "P", { class: true });
			var p1_nodes = children(p1);
			p1_nodes.forEach(detach);
			div6_nodes.forEach(detach);
			div7_nodes.forEach(detach);
			t22 = claim_space(div12_nodes);
			div9 = claim_element(div12_nodes, "DIV", { class: true });
			var div9_nodes = children(div9);
			h31 = claim_element(div9_nodes, "H3", { class: true });
			var h31_nodes = children(h31);
			t23 = claim_text(h31_nodes, "Highlights");
			h31_nodes.forEach(detach);
			t24 = claim_space(div9_nodes);
			div8 = claim_element(div9_nodes, "DIV", { class: true });
			var div8_nodes = children(div8);
			ul = claim_element(div8_nodes, "UL", { role: true, class: true });
			var ul_nodes = children(ul);
			li0 = claim_element(ul_nodes, "LI", { class: true });
			var li0_nodes = children(li0);
			span0 = claim_element(li0_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t25 = claim_text(span0_nodes, "Hand cut and sewn locally");
			span0_nodes.forEach(detach);
			li0_nodes.forEach(detach);
			t26 = claim_space(ul_nodes);
			li1 = claim_element(ul_nodes, "LI", { class: true });
			var li1_nodes = children(li1);
			span1 = claim_element(li1_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t27 = claim_text(span1_nodes, "Dyed with our proprietary colors");
			span1_nodes.forEach(detach);
			li1_nodes.forEach(detach);
			t28 = claim_space(ul_nodes);
			li2 = claim_element(ul_nodes, "LI", { class: true });
			var li2_nodes = children(li2);
			span2 = claim_element(li2_nodes, "SPAN", { class: true });
			var span2_nodes = children(span2);
			t29 = claim_text(span2_nodes, "Pre-washed & pre-shrunk");
			span2_nodes.forEach(detach);
			li2_nodes.forEach(detach);
			t30 = claim_space(ul_nodes);
			li3 = claim_element(ul_nodes, "LI", { class: true });
			var li3_nodes = children(li3);
			span3 = claim_element(li3_nodes, "SPAN", { class: true });
			var span3_nodes = children(span3);
			t31 = claim_text(span3_nodes, "Ultra-soft 100% cotton");
			span3_nodes.forEach(detach);
			li3_nodes.forEach(detach);
			ul_nodes.forEach(detach);
			div8_nodes.forEach(detach);
			div9_nodes.forEach(detach);
			t32 = claim_space(div12_nodes);
			div11 = claim_element(div12_nodes, "DIV", { class: true });
			var div11_nodes = children(div11);
			h21 = claim_element(div11_nodes, "H2", { class: true });
			var h21_nodes = children(h21);
			t33 = claim_text(h21_nodes, "Details");
			h21_nodes.forEach(detach);
			t34 = claim_space(div11_nodes);
			div10 = claim_element(div11_nodes, "DIV", { class: true });
			var div10_nodes = children(div10);
			p2 = claim_element(div10_nodes, "P", { class: true });
			var p2_nodes = children(p2);
			t35 = claim_text(p2_nodes, "The 6-Pack includes two black, two white, and two heather gray Basic Tees. Sign up for our subscription service and be the first to get new, exciting colors, like our upcoming \"Charcoal Gray\" limited release.");
			p2_nodes.forEach(detach);
			div10_nodes.forEach(detach);
			div11_nodes.forEach(detach);
			div12_nodes.forEach(detach);
			div13_nodes.forEach(detach);
			div14_nodes.forEach(detach);
			div15_nodes.forEach(detach);
			this.h();
		},
		h() {
			html_tag.a = t0;
			attr(div0, "class", "h-8 md:h-20");
			attr(h10, "class", "text-2xl font-extrabold tracking-tight text-gray-900 sm:text-3xl");
			attr(div1, "class", "lg:col-span-2 lg:border-r lg:border-gray-200 lg:pr-8");
			attr(h11, "class", "text-2xl font-extrabold tracking-tight text-gray-900 sm:text-3xl");
			attr(h20, "class", "sr-only");
			attr(p0, "class", "text-3xl text-gray-900 mt-4");
			html_tag_1.a = t12;
			attr(input, "type", "hidden");
			attr(input, "name", "id");
			input.value = input_value_value = /*product*/ ctx[0].selected_or_first_available_variant.id;
			attr(div2, "class", "");
			attr(label, "class", "text-base");
			attr(button, "type", "submit");
			attr(button, "class", "mt-10 w-full bg-indigo-600 border border-transparent rounded-md py-3 px-8 flex items-center justify-center text-base font-medium text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500");
			attr(div4, "class", "mt-10");
			set_attributes(form, form_data);
			attr(div5, "class", "mt-4 lg:mt-0 lg:row-span-3");
			attr(h30, "class", "sr-only");
			attr(p1, "class", "text-base text-gray-900");
			attr(div6, "class", "space-y-6");
			attr(h31, "class", "text-sm font-medium text-gray-900");
			attr(span0, "class", "text-gray-600");
			attr(li0, "class", "text-gray-400");
			attr(span1, "class", "text-gray-600");
			attr(li1, "class", "text-gray-400");
			attr(span2, "class", "text-gray-600");
			attr(li2, "class", "text-gray-400");
			attr(span3, "class", "text-gray-600");
			attr(li3, "class", "text-gray-400");
			attr(ul, "role", "list");
			attr(ul, "class", "pl-4 list-disc text-sm space-y-2");
			attr(div8, "class", "mt-4");
			attr(div9, "class", "mt-10");
			attr(h21, "class", "text-sm font-medium text-gray-900");
			attr(p2, "class", "text-sm text-gray-600");
			attr(div10, "class", "mt-4 space-y-6");
			attr(div11, "class", "mt-10");
			attr(div12, "class", "py-10 lg:pt-6 lg:pb-16 lg:col-start-1 lg:col-span-2 lg:border-r lg:border-gray-200 lg:pr-8");
			attr(div13, "class", "max-w-2xl mx-auto pt-10 pb-16 px-4 sm:px-6 lg:max-w-7xl lg:pt-16 lg:pb-24 lg:px-8 lg:grid lg:grid-cols-3 lg:grid-rows-[auto,auto,1fr] lg:gap-x-8");
			attr(div14, "class", "pt-6");
			attr(div15, "class", "bg-white");
		},
		m(target, anchor) {
			insert_hydration(target, div15, anchor);
			html_tag.m(raw0_value, div15);
			append_hydration(div15, t0);
			append_hydration(div15, div14);
			append_hydration(div14, div13);
			append_hydration(div13, div1);
			mount_component(imagegallery, div1, null);
			append_hydration(div1, t1);
			append_hydration(div1, div0);
			append_hydration(div1, t2);
			append_hydration(div1, h10);
			append_hydration(h10, t3);
			append_hydration(div13, t4);
			append_hydration(div13, div5);
			append_hydration(div5, h11);
			append_hydration(h11, t5);
			append_hydration(div5, t6);
			append_hydration(div5, h20);
			append_hydration(h20, t7);
			append_hydration(div5, t8);
			append_hydration(div5, p0);
			append_hydration(p0, t9);
			append_hydration(div5, t10);
			mount_component(reviews, div5, null);
			append_hydration(div5, t11);
			append_hydration(div5, form);
			html_tag_1.m(raw1_value, form);
			append_hydration(form, t12);
			append_hydration(form, input);
			append_hydration(form, t13);
			append_hydration(form, div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div2, null);
			}

			append_hydration(form, t14);
			append_hydration(form, div4);
			append_hydration(div4, label);
			append_hydration(label, t15);
			append_hydration(div4, t16);
			mount_component(quantitybox, div4, null);
			append_hydration(div4, t17);
			append_hydration(div4, div3);
			append_hydration(div3, button);
			append_hydration(button, t18);
			append_hydration(div13, t19);
			append_hydration(div13, div12);
			append_hydration(div12, div7);
			append_hydration(div7, h30);
			append_hydration(h30, t20);
			append_hydration(div7, t21);
			append_hydration(div7, div6);
			append_hydration(div6, p1);
			p1.innerHTML = raw2_value;
			append_hydration(div12, t22);
			append_hydration(div12, div9);
			append_hydration(div9, h31);
			append_hydration(h31, t23);
			append_hydration(div9, t24);
			append_hydration(div9, div8);
			append_hydration(div8, ul);
			append_hydration(ul, li0);
			append_hydration(li0, span0);
			append_hydration(span0, t25);
			append_hydration(ul, t26);
			append_hydration(ul, li1);
			append_hydration(li1, span1);
			append_hydration(span1, t27);
			append_hydration(ul, t28);
			append_hydration(ul, li2);
			append_hydration(li2, span2);
			append_hydration(span2, t29);
			append_hydration(ul, t30);
			append_hydration(ul, li3);
			append_hydration(li3, span3);
			append_hydration(span3, t31);
			append_hydration(div12, t32);
			append_hydration(div12, div11);
			append_hydration(div11, h21);
			append_hydration(h21, t33);
			append_hydration(div11, t34);
			append_hydration(div11, div10);
			append_hydration(div10, p2);
			append_hydration(p2, t35);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*rawinclude_f5b8cf1c*/ 16) && raw0_value !== (raw0_value = /*rawinclude_f5b8cf1c*/ ctx[4][index || 0] + "")) html_tag.p(raw0_value);
			const imagegallery_changes = {};
			if (dirty[0] & /*review_stars*/ 256) imagegallery_changes.review_stars = /*review_stars*/ ctx[8];
			if (dirty[0] & /*score*/ 128) imagegallery_changes.score = /*score*/ ctx[7];
			if (dirty[0] & /*reviews_count*/ 64) imagegallery_changes.reviews_count = /*reviews_count*/ ctx[6];
			if (dirty[0] & /*product*/ 1) imagegallery_changes.product = /*product*/ ctx[0];
			if (dirty[0] & /*inputWidth*/ 32) imagegallery_changes.inputWidth = /*inputWidth*/ ctx[5];
			if (dirty[0] & /*breadcrumbs*/ 512) imagegallery_changes.breadcrumbs = /*breadcrumbs*/ ctx[9];
			if (dirty[0] & /*breadcrumbs_size*/ 1024) imagegallery_changes.breadcrumbs_size = /*breadcrumbs_size*/ ctx[10];
			if (dirty[0] & /*price_formatted*/ 2048) imagegallery_changes.price_formatted = /*price_formatted*/ ctx[11];
			if (dirty[0] & /*product$options_with_values*/ 4096) imagegallery_changes.product$options_with_values = /*product$options_with_values*/ ctx[12];
			if (dirty[0] & /*section$settings*/ 8192) imagegallery_changes.section$settings = /*section$settings*/ ctx[13];
			if (dirty[0] & /*product$selected_or_first_available_variant*/ 16384) imagegallery_changes.product$selected_or_first_available_variant = /*product$selected_or_first_available_variant*/ ctx[14];
			if (dirty[0] & /*form_props_f58d08b6b*/ 8) imagegallery_changes.form_props_f58d08b6b = /*form_props_f58d08b6b*/ ctx[3];
			if (dirty[0] & /*form_inputs_f58d08b6b*/ 4) imagegallery_changes.form_inputs_f58d08b6b = /*form_inputs_f58d08b6b*/ ctx[2];
			if (dirty[0] & /*rawinclude_f5b8cf1c*/ 16) imagegallery_changes.rawinclude_f5b8cf1c = /*rawinclude_f5b8cf1c*/ ctx[4];
			if (dirty[0] & /*lec*/ 2) imagegallery_changes.lec = /*lec*/ ctx[1];
			imagegallery.$set(imagegallery_changes);
			if ((!current || dirty[0] & /*section*/ 65536) && t3_value !== (t3_value = /*section*/ ctx[16].settings.product_title + "")) set_data(t3, t3_value);
			if ((!current || dirty[0] & /*product*/ 1) && t5_value !== (t5_value = /*product*/ ctx[0].title + "")) set_data(t5, t5_value);
			if (!current || dirty[0] & /*price_formatted*/ 2048) set_data(t9, /*price_formatted*/ ctx[11]);
			const reviews_changes = {};
			if (dirty[0] & /*review_stars*/ 256) reviews_changes.review_stars = /*review_stars*/ ctx[8];
			if (dirty[0] & /*score*/ 128) reviews_changes.score = /*score*/ ctx[7];
			if (dirty[0] & /*reviews_count*/ 64) reviews_changes.reviews_count = /*reviews_count*/ ctx[6];
			if (dirty[0] & /*product*/ 1) reviews_changes.product = /*product*/ ctx[0];
			if (dirty[0] & /*inputWidth*/ 32) reviews_changes.inputWidth = /*inputWidth*/ ctx[5];
			if (dirty[0] & /*breadcrumbs*/ 512) reviews_changes.breadcrumbs = /*breadcrumbs*/ ctx[9];
			if (dirty[0] & /*breadcrumbs_size*/ 1024) reviews_changes.breadcrumbs_size = /*breadcrumbs_size*/ ctx[10];
			if (dirty[0] & /*price_formatted*/ 2048) reviews_changes.price_formatted = /*price_formatted*/ ctx[11];
			if (dirty[0] & /*product$options_with_values*/ 4096) reviews_changes.product$options_with_values = /*product$options_with_values*/ ctx[12];
			if (dirty[0] & /*section$settings*/ 8192) reviews_changes.section$settings = /*section$settings*/ ctx[13];
			if (dirty[0] & /*product$selected_or_first_available_variant*/ 16384) reviews_changes.product$selected_or_first_available_variant = /*product$selected_or_first_available_variant*/ ctx[14];
			if (dirty[0] & /*form_props_f58d08b6b*/ 8) reviews_changes.form_props_f58d08b6b = /*form_props_f58d08b6b*/ ctx[3];
			if (dirty[0] & /*form_inputs_f58d08b6b*/ 4) reviews_changes.form_inputs_f58d08b6b = /*form_inputs_f58d08b6b*/ ctx[2];
			if (dirty[0] & /*rawinclude_f5b8cf1c*/ 16) reviews_changes.rawinclude_f5b8cf1c = /*rawinclude_f5b8cf1c*/ ctx[4];
			if (dirty[0] & /*lec*/ 2) reviews_changes.lec = /*lec*/ ctx[1];
			reviews.$set(reviews_changes);
			if ((!current || dirty[0] & /*form_inputs_f58d08b6b*/ 4) && raw1_value !== (raw1_value = /*form_inputs_f58d08b6b*/ ctx[2][index || 0] + "")) html_tag_1.p(raw1_value);

			if (!current || dirty[0] & /*product*/ 1 && input_value_value !== (input_value_value = /*product*/ ctx[0].selected_or_first_available_variant.id)) {
				input.value = input_value_value;
			}

			if (dirty[0] & /*product, selected_options*/ 32769) {
				each_value = /*product*/ ctx[0].options_with_values;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div2, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			const quantitybox_changes = {};
			if (dirty[0] & /*review_stars*/ 256) quantitybox_changes.review_stars = /*review_stars*/ ctx[8];
			if (dirty[0] & /*score*/ 128) quantitybox_changes.score = /*score*/ ctx[7];
			if (dirty[0] & /*reviews_count*/ 64) quantitybox_changes.reviews_count = /*reviews_count*/ ctx[6];
			if (dirty[0] & /*product*/ 1) quantitybox_changes.product = /*product*/ ctx[0];
			if (dirty[0] & /*inputWidth*/ 32) quantitybox_changes.inputWidth = /*inputWidth*/ ctx[5];
			if (dirty[0] & /*breadcrumbs*/ 512) quantitybox_changes.breadcrumbs = /*breadcrumbs*/ ctx[9];
			if (dirty[0] & /*breadcrumbs_size*/ 1024) quantitybox_changes.breadcrumbs_size = /*breadcrumbs_size*/ ctx[10];
			if (dirty[0] & /*price_formatted*/ 2048) quantitybox_changes.price_formatted = /*price_formatted*/ ctx[11];
			if (dirty[0] & /*product$options_with_values*/ 4096) quantitybox_changes.product$options_with_values = /*product$options_with_values*/ ctx[12];
			if (dirty[0] & /*section$settings*/ 8192) quantitybox_changes.section$settings = /*section$settings*/ ctx[13];
			if (dirty[0] & /*product$selected_or_first_available_variant*/ 16384) quantitybox_changes.product$selected_or_first_available_variant = /*product$selected_or_first_available_variant*/ ctx[14];
			if (dirty[0] & /*form_props_f58d08b6b*/ 8) quantitybox_changes.form_props_f58d08b6b = /*form_props_f58d08b6b*/ ctx[3];
			if (dirty[0] & /*form_inputs_f58d08b6b*/ 4) quantitybox_changes.form_inputs_f58d08b6b = /*form_inputs_f58d08b6b*/ ctx[2];
			if (dirty[0] & /*rawinclude_f5b8cf1c*/ 16) quantitybox_changes.rawinclude_f5b8cf1c = /*rawinclude_f5b8cf1c*/ ctx[4];
			if (dirty[0] & /*lec*/ 2) quantitybox_changes.lec = /*lec*/ ctx[1];

			if (!updating_quantity && dirty[0] & /*quantity*/ 131072) {
				updating_quantity = true;
				quantitybox_changes.quantity = /*quantity*/ ctx[17];
				add_flush_callback(() => updating_quantity = false);
			}

			quantitybox.$set(quantitybox_changes);

			set_attributes(form, form_data = get_spread_update(form_levels, [
				{ class: "mt-10" },
				dirty[0] & /*form_props_f58d08b6b*/ 8 && /*form_props_f58d08b6b*/ ctx[3][index || 0]
			]));

			if ((!current || dirty[0] & /*product*/ 1) && raw2_value !== (raw2_value = (/*product*/ ctx[0].description || '') + "")) p1.innerHTML = raw2_value;;
		},
		i(local) {
			if (current) return;
			transition_in(imagegallery.$$.fragment, local);
			transition_in(reviews.$$.fragment, local);
			transition_in(quantitybox.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(imagegallery.$$.fragment, local);
			transition_out(reviews.$$.fragment, local);
			transition_out(quantitybox.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div15);
			destroy_component(imagegallery);
			destroy_component(reviews);
			destroy_each(each_blocks, detaching);
			destroy_component(quantitybox);
		}
	};
}

let index = 0;

function instance($$self, $$props, $$invalidate) {
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { form_inputs_f58d08b6b } = $$props;
	let { form_props_f58d08b6b } = $$props;
	let { rawinclude_f5b8cf1c } = $$props;
	let { inputWidth } = $$props;
	let { reviews_count } = $$props;
	let { score } = $$props;
	let { review_stars } = $$props;
	let { breadcrumbs } = $$props;
	let { breadcrumbs_size } = $$props;
	let { price_formatted } = $$props;
	let { product } = $$props;
	let { product$options_with_values } = $$props;
	product.options_with_values = product$options_with_values;
	let section = {};
	let { section$settings } = $$props;
	section.settings = section$settings;
	let { product$selected_or_first_available_variant } = $$props;
	product.selected_or_first_available_variant = product$selected_or_first_available_variant;
	const JSTRFY = JSON.stringify;
	let selected_options = [null, ...product.selected_or_first_available_variant.options];
	let quantity;
	let checked_size = product.options_with_values[0].values[0];
	const $$binding_groups = [[]];

	function input_change_handler(option) {
		selected_options[option.position] = this.__value;
		$$invalidate(15, selected_options);
	}

	function input_change_handler_1(option) {
		selected_options[option.position] = this.__value;
		$$invalidate(15, selected_options);
	}

	function input_change_handler_2(option) {
		selected_options[option.position] = this.__value;
		$$invalidate(15, selected_options);
	}

	function input_change_handler_3(option) {
		selected_options[option.position] = this.__value;
		$$invalidate(15, selected_options);
	}

	function quantitybox_quantity_binding(value) {
		quantity = value;
		$$invalidate(17, quantity);
	}

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(1, lec = $$props.lec);
		if ('form_inputs_f58d08b6b' in $$props) $$invalidate(2, form_inputs_f58d08b6b = $$props.form_inputs_f58d08b6b);
		if ('form_props_f58d08b6b' in $$props) $$invalidate(3, form_props_f58d08b6b = $$props.form_props_f58d08b6b);
		if ('rawinclude_f5b8cf1c' in $$props) $$invalidate(4, rawinclude_f5b8cf1c = $$props.rawinclude_f5b8cf1c);
		if ('inputWidth' in $$props) $$invalidate(5, inputWidth = $$props.inputWidth);
		if ('reviews_count' in $$props) $$invalidate(6, reviews_count = $$props.reviews_count);
		if ('score' in $$props) $$invalidate(7, score = $$props.score);
		if ('review_stars' in $$props) $$invalidate(8, review_stars = $$props.review_stars);
		if ('breadcrumbs' in $$props) $$invalidate(9, breadcrumbs = $$props.breadcrumbs);
		if ('breadcrumbs_size' in $$props) $$invalidate(10, breadcrumbs_size = $$props.breadcrumbs_size);
		if ('price_formatted' in $$props) $$invalidate(11, price_formatted = $$props.price_formatted);
		if ('product' in $$props) $$invalidate(0, product = $$props.product);
		if ('product$options_with_values' in $$props) $$invalidate(12, product$options_with_values = $$props.product$options_with_values);
		if ('section$settings' in $$props) $$invalidate(13, section$settings = $$props.section$settings);
		if ('product$selected_or_first_available_variant' in $$props) $$invalidate(14, product$selected_or_first_available_variant = $$props.product$selected_or_first_available_variant);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*product, selected_options*/ 32769) {
			$: $$invalidate(0, product = {
				...product,
				selected_or_first_available_variant: product.variants.find(v => JSTRFY(v.options) == JSTRFY(selected_options.slice(1)))
			});
		}

		if ($$self.$$.dirty[0] & /*product*/ 1) {
			$: console.log('product ', product);
		}

		if ($$self.$$.dirty[0] & /*selected_options*/ 32768) {
			$: console.log('selected_options ', selected_options);
		}

		if ($$self.$$.dirty[0] & /*product*/ 1) {
			$: console.log('checked_size ', product.selected_or_first_available_variant);
		}
	};

	return [
		product,
		lec,
		form_inputs_f58d08b6b,
		form_props_f58d08b6b,
		rawinclude_f5b8cf1c,
		inputWidth,
		reviews_count,
		score,
		review_stars,
		breadcrumbs,
		breadcrumbs_size,
		price_formatted,
		product$options_with_values,
		section$settings,
		product$selected_or_first_available_variant,
		selected_options,
		section,
		quantity,
		input_change_handler,
		$$binding_groups,
		input_change_handler_1,
		input_change_handler_2,
		input_change_handler_3,
		quantitybox_quantity_binding
	];
}

class Main_product extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				lec: 1,
				form_inputs_f58d08b6b: 2,
				form_props_f58d08b6b: 3,
				rawinclude_f5b8cf1c: 4,
				inputWidth: 5,
				reviews_count: 6,
				score: 7,
				review_stars: 8,
				breadcrumbs: 9,
				breadcrumbs_size: 10,
				price_formatted: 11,
				product: 0,
				product$options_with_values: 12,
				section$settings: 13,
				product$selected_or_first_available_variant: 14
			},
			null,
			[-1, -1]
		);
	}
}

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': Main_product
});

export { Main_product, Quantity_box, index$1 as index };
