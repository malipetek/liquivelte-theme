import { create_slot, assign, element, claim_element, children, detach, set_attributes, insert_hydration, update_slot_base, get_all_dirty_from_scope, get_slot_changes, get_spread_update, transition_in, transition_out, compute_rest_props, createEventDispatcher, onMount, onDestroy, binding_callbacks, exclude_internal_props, SvelteComponent, init, safe_not_equal, setContext, create_component, space, claim_component, claim_space, mount_component, get_spread_object, group_outros, destroy_component, check_outros, empty, attr, append_hydration, update_keyed_each, outro_and_destroy_block, tick, afterUpdate, listen, compute_slots, svg_element, claim_svg_element, destroy_each, text, claim_text, set_data, action_destroyer, is_function, noop, run_all, select_options, select_option, getContext, toggle_class, beforeUpdate, src_url_equal, HtmlTagHydration, claim_html_tag, set_style, destroy_block, SkeletonAvatar, SkeletonBlock, SkeletonImage, SkeletonText, Swiper_slide, Swiper_1, bind, add_flush_callback } from './liquivelte-svelte-hs623f7d73.liquivelte.js';
import { cachedLiquid } from './liquivelte-liquid-hs6dbc6cca.liquivelte.js';
import './store.js-hs80deeb5c.liquivelte.js';

function noUndefinedProps(obj) {
  const o = {};
  Object.keys(obj).forEach(key => {
    if (typeof obj[key] !== 'undefined') o[key] = obj[key];
  });
  return o;
}
function isStringProp(val) {
  return typeof val === 'string' && val !== '';
}
function isObject(o) {
  return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
}
function now() {
  return Date.now();
}
function extend() {
  let deep = true;
  let to;
  let from;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (typeof args[0] === 'boolean') {
    [deep, to] = args;
    args.splice(0, 2);
    from = args;
  } else {
    [to] = args;
    args.splice(0, 1);
    from = args;
  }
  for (let i = 0; i < from.length; i += 1) {
    const nextSource = args[i];
    if (nextSource !== undefined && nextSource !== null) {
      const keysArray = Object.keys(Object(nextSource));
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== undefined && desc.enumerable) {
          if (!deep) {
            to[nextKey] = nextSource[nextKey];
          } else if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            extend(to[nextKey], nextSource[nextKey]);
          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            to[nextKey] = {};
            extend(to[nextKey], nextSource[nextKey]);
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function classNames() {
  const classes = [];
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  args.forEach(arg => {
    if (typeof arg === 'object' && arg.constructor === Object) {
      Object.keys(arg).forEach(key => {
        if (arg[key]) classes.push(key);
      });
    } else if (arg) classes.push(arg);
  });
  const uniqueClasses = [];
  classes.forEach(c => {
    if (uniqueClasses.indexOf(c) < 0) uniqueClasses.push(c);
  });
  return uniqueClasses.join(' ');
}
function createEmitter(createEventDispatcher, props) {
  const dispatch = createEventDispatcher();
  const emit = (events, argsArray) => {
    if (!events || !events.trim().length || typeof events !== 'string') return;
    events.trim().split(' ').forEach(event => {
      const eventName = (event || '').trim();
      if (!eventName) return;
      const propName = `on${eventName.charAt(0).toUpperCase() + eventName.slice(1)}`;
      dispatch(eventName, argsArray);
      if (typeof props[propName] === 'function') {
        if (!Array.isArray(argsArray)) props[propName](...[argsArray]);else props[propName](...(argsArray || []));
      }
    });
  };
  return emit;
}
let routerIdCounter = 0;
let routerComponentIdCounter = 0;
function unsetRouterIds() {
  routerIdCounter = 0;
  routerComponentIdCounter = 0;
}
function getRouterId() {
  routerIdCounter += 1;
  return `${now()}_${routerIdCounter}`;
}
function getComponentId() {
  routerComponentIdCounter += 1;
  return `${now()}_${routerComponentIdCounter}`;
}
function plainText(text) {
  if (typeof text === 'undefined' || text === null) return '';
  return text;
}

/* eslint-disable import/no-mutable-exports */
let f7;
const theme$1 = {};

/* eslint-disable no-restricted-globals */
const app = typeof window !== 'undefined' && window.Framework7ComponentsApp ? window.Framework7ComponentsApp : {
  Framework7: undefined,
  f7: undefined,
  f7events: undefined,
  theme: {},
  f7routers: {
    views: [],
    tabs: [],
    modals: null
  }
};
if (typeof window !== 'undefined') {
  window.Framework7ComponentsApp = app;
}
/* eslint-enable no-restricted-globals */

app.setInstance = instance => {
  f7 = instance;
};
const setTheme = () => {
  if (!app.f7) return;
  app.theme.ios = app.f7.theme === 'ios';
  theme$1.ios = app.f7.theme === 'ios';
  app.theme.md = app.f7.theme === 'md';
  theme$1.md = app.f7.theme === 'md';
  app.theme.aurora = app.f7.theme === 'aurora';
  theme$1.aurora = app.f7.theme === 'aurora';
};
const cleanup = () => {
  unsetRouterIds();
  delete app.theme.ios;
  delete theme$1.ios;
  delete app.theme.md;
  delete theme$1.md;
  delete app.theme.aurora;
  delete theme$1.aurora;
  app.f7routers.views = [];
  app.f7routers.tabs = [];
  app.f7routers.modals = null;
};
const f7initEvents = () => {
  app.f7events = new app.Framework7.Events();
};
const f7init = function (rootEl, params, init) {
  if (params === void 0) {
    params = {};
  }
  if (init === void 0) {
    init = true;
  }
  const f7Params = extend({}, params, {
    el: rootEl,
    init
  });
  if (typeof params.store !== 'undefined') f7Params.store = params.store;
  if (!f7Params.routes) f7Params.routes = [];
  if (f7Params.userAgent && (f7Params.theme === 'auto' || !f7Params.theme)) {
    const device = app.Framework7.getDevice({
      userAgent: f7Params.userAgent
    }, true);
    app.theme.ios = !!device.ios;
    app.theme.aurora = device.desktop && device.electron;
    app.theme.md = !app.theme.ios && !app.theme.aurora;
  }
  // eslint-disable-next-line
  if (app.f7 && typeof window !== 'undefined') return;

  // eslint-disable-next-line
  if (typeof window === 'undefined') cleanup();
  const instance = new app.Framework7(f7Params);
  app.f7 = instance;
  f7 = instance;
  app.setInstance(instance);
  setTheme();
  if (instance.initialized) {
    app.f7 = instance;
    f7 = instance;
    app.setInstance(instance);
    app.f7events.emit('ready', app.f7);
  } else {
    instance.on('init', () => {
      app.f7 = instance;
      f7 = instance;
      app.setInstance(instance);
      app.f7events.emit('ready', app.f7);
    });
  }
};
const f7ready = callback => {
  if (!callback) return;
  if (app.f7 && app.f7.initialized) callback(app.f7);else {
    app.f7events.once('ready', callback);
  }
};

function colorClasses(props) {
  const {
    color,
    colorTheme,
    textColor,
    bgColor,
    borderColor,
    rippleColor,
    dark
  } = props;
  return {
    dark,
    [`color-${color}`]: color,
    [`color-theme-${colorTheme}`]: colorTheme,
    [`text-color-${textColor}`]: textColor,
    [`bg-color-${bgColor}`]: bgColor,
    [`border-color-${borderColor}`]: borderColor,
    [`ripple-color-${rippleColor}`]: rippleColor
  };
}
function routerAttrs(props) {
  const {
    force,
    reloadCurrent,
    reloadPrevious,
    reloadAll,
    reloadDetail,
    animate,
    ignoreCache,
    routeTabId,
    view,
    transition,
    openIn
  } = props;
  let dataAnimate;
  if ('animate' in props && typeof animate !== 'undefined') {
    dataAnimate = animate.toString();
  }
  let dataReloadDetail;
  if ('reloadDetail' in props && typeof reloadDetail !== 'undefined') {
    dataReloadDetail = reloadDetail.toString();
  }
  return {
    'data-force': force || undefined,
    'data-reload-current': reloadCurrent || undefined,
    'data-reload-all': reloadAll || undefined,
    'data-reload-previous': reloadPrevious || undefined,
    'data-reload-detail': dataReloadDetail,
    'data-animate': dataAnimate,
    'data-ignore-cache': ignoreCache || undefined,
    'data-route-tab-id': routeTabId || undefined,
    'data-view': isStringProp(view) ? view : undefined,
    'data-transition': isStringProp(transition) ? transition : undefined,
    'data-open-in': isStringProp(openIn) ? openIn : undefined
  };
}
function routerClasses(props) {
  const {
    back,
    linkBack,
    external,
    preventRouter
  } = props;
  return {
    back: back || linkBack,
    external,
    'prevent-router': preventRouter
  };
}
function actionsAttrs(props) {
  const {
    searchbarEnable,
    searchbarDisable,
    searchbarClear,
    searchbarToggle,
    panelOpen,
    panelClose,
    panelToggle,
    popupOpen,
    popupClose,
    actionsOpen,
    actionsClose,
    popoverOpen,
    popoverClose,
    loginScreenOpen,
    loginScreenClose,
    sheetOpen,
    sheetClose,
    sortableEnable,
    sortableDisable,
    sortableToggle,
    cardOpen,
    cardClose
  } = props;
  return {
    'data-searchbar': isStringProp(searchbarEnable) && searchbarEnable || isStringProp(searchbarDisable) && searchbarDisable || isStringProp(searchbarClear) && searchbarClear || isStringProp(searchbarToggle) && searchbarToggle || undefined,
    'data-panel': isStringProp(panelOpen) && panelOpen || isStringProp(panelClose) && panelClose || isStringProp(panelToggle) && panelToggle || undefined,
    'data-popup': isStringProp(popupOpen) && popupOpen || isStringProp(popupClose) && popupClose || undefined,
    'data-actions': isStringProp(actionsOpen) && actionsOpen || isStringProp(actionsClose) && actionsClose || undefined,
    'data-popover': isStringProp(popoverOpen) && popoverOpen || isStringProp(popoverClose) && popoverClose || undefined,
    'data-sheet': isStringProp(sheetOpen) && sheetOpen || isStringProp(sheetClose) && sheetClose || undefined,
    'data-login-screen': isStringProp(loginScreenOpen) && loginScreenOpen || isStringProp(loginScreenClose) && loginScreenClose || undefined,
    'data-sortable': isStringProp(sortableEnable) && sortableEnable || isStringProp(sortableDisable) && sortableDisable || isStringProp(sortableToggle) && sortableToggle || undefined,
    'data-card': isStringProp(cardOpen) && cardOpen || isStringProp(cardClose) && cardClose || undefined
  };
}
function actionsClasses(props) {
  const {
    searchbarEnable,
    searchbarDisable,
    searchbarClear,
    searchbarToggle,
    panelOpen,
    panelClose,
    panelToggle,
    popupOpen,
    popupClose,
    actionsClose,
    actionsOpen,
    popoverOpen,
    popoverClose,
    loginScreenOpen,
    loginScreenClose,
    sheetOpen,
    sheetClose,
    sortableEnable,
    sortableDisable,
    sortableToggle,
    cardOpen,
    cardPreventOpen,
    cardClose,
    menuClose
  } = props;
  return {
    'searchbar-enable': searchbarEnable || searchbarEnable === '',
    'searchbar-disable': searchbarDisable || searchbarDisable === '',
    'searchbar-clear': searchbarClear || searchbarClear === '',
    'searchbar-toggle': searchbarToggle || searchbarToggle === '',
    'panel-close': panelClose || panelClose === '',
    'panel-open': panelOpen || panelOpen === '',
    'panel-toggle': panelToggle || panelToggle === '',
    'popup-close': popupClose || popupClose === '',
    'popup-open': popupOpen || popupOpen === '',
    'actions-close': actionsClose || actionsClose === '',
    'actions-open': actionsOpen || actionsOpen === '',
    'popover-close': popoverClose || popoverClose === '',
    'popover-open': popoverOpen || popoverOpen === '',
    'sheet-close': sheetClose || sheetClose === '',
    'sheet-open': sheetOpen || sheetOpen === '',
    'login-screen-close': loginScreenClose || loginScreenClose === '',
    'login-screen-open': loginScreenOpen || loginScreenOpen === '',
    'sortable-enable': sortableEnable || sortableEnable === '',
    'sortable-disable': sortableDisable || sortableDisable === '',
    'sortable-toggle': sortableToggle || sortableToggle === '',
    'card-close': cardClose || cardClose === '',
    'card-open': cardOpen || cardOpen === '',
    'card-prevent-open': cardPreventOpen || cardPreventOpen === '',
    'menu-close': menuClose || menuClose === ''
  };
}

const ignoreProps = ['color', 'colorTheme', 'textColor', 'bgColor', 'borderColor', 'rippleColor', 'dark', 'force', 'reloadCurrent', 'reloadPrevious', 'reloadAll', 'reloadDetail', 'animate', 'ignoreCache', 'routeTabId', 'view', 'transition', 'openIn', 'back', 'linkBack', 'external', 'preventRouter', 'searchbarEnable', 'searchbarDisable', 'searchbarClear', 'searchbarToggle', 'panelOpen', 'panelClose', 'panelToggle', 'popupOpen', 'popupClose', 'actionsOpen', 'actionsClose', 'popoverOpen', 'popoverClose', 'loginScreenOpen', 'loginScreenClose', 'sheetOpen', 'sheetClose', 'sortableEnable', 'sortableDisable', 'sortableToggle', 'cardOpen', 'cardClose'];
function restProps(rest) {
  if (rest === void 0) {
    rest = {};
  }
  const props = {};
  Object.keys(rest).filter(prop => !ignoreProps.includes(prop)).forEach(key => {
    if (key.indexOf('on') !== 0) {
      props[key] = rest[key];
    }
  });
  return props;
}

const modalStateClasses = function (_temp) {
  let {
    isOpened,
    isClosing
  } = _temp === void 0 ? {} : _temp;
  return {
    'modal-in': isOpened && !isClosing,
    'modal-out': isClosing
  };
};

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/popup.liquivelte generated by Svelte v3.50.0 */
const get_default_slot_changes$c = dirty => ({ popup: dirty[0] & /*f7Popup*/ 2 });
const get_default_slot_context$c = ctx => ({ popup: /*f7Popup*/ ctx[1] });

function create_fragment$1B(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[19].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], get_default_slot_context$c);
	let div_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[20](div);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope, f7Popup*/ 262146)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[18],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, get_default_slot_changes$c),
						get_default_slot_context$c
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty[0] & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[20](null);
		}
	};
}

let index$1D = 0;

function instance_1$f($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"lec","class","tabletFullscreen","opened","animate","backdrop","backdropEl","closeByBackdropClick","closeOnEscape","swipeToClose","swipeHandler","push","containerEl","instance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { tabletFullscreen = undefined } = $$props;
	let { opened = undefined } = $$props;
	let { animate = undefined } = $$props;
	let { backdrop = undefined } = $$props;
	let { backdropEl = undefined } = $$props;
	let { closeByBackdropClick = undefined } = $$props;
	let { closeOnEscape = undefined } = $$props;
	let { swipeToClose = false } = $$props;
	let { swipeHandler = undefined } = $$props;
	let { push = undefined } = $$props;
	let { containerEl = undefined } = $$props;
	let el;
	let f7Popup;
	const state = { isOpened: opened, isClosing: false };

	function instance() {
		return f7Popup;
	}

	function onSwipeStart(instance) {
		emit('popupSwipeStart', [instance]);
	}

	function onSwipeMove(instance) {
		emit('popupSwipeMove', [instance]);
	}

	function onSwipeEnd(instance) {
		emit('popupSwipeEnd', [instance]);
	}

	function onSwipeClose(instance) {
		emit('popupSwipeClose', [instance]);
	}

	function onOpen(instance) {
		Object.assign(state, { isOpened: true, isClosing: false });
		emit('popupOpen', [instance]);
		$$invalidate(4, opened = true);
	}

	function onOpened(instance) {
		emit('popupOpened', [instance]);
	}

	function onClose(instance) {
		Object.assign(state, { isOpened: false, isClosing: true });
		emit('popupClose', [instance]);
	}

	function onClosed(instance) {
		Object.assign(state, { isClosing: false });
		emit('popupClosed', [instance]);
		$$invalidate(4, opened = false);
	}

	let initialWatched = false;

	function watchOpened(openedPassed) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7Popup) return;
		if (openedPassed) f7Popup.open(); else f7Popup.close();
	}

	onMount(() => {
		const popupParams = {
			el,
			on: {
				swipeStart: onSwipeStart,
				swipeMove: onSwipeMove,
				swipeEnd: onSwipeEnd,
				swipeClose: onSwipeClose,
				open: onOpen,
				opened: onOpened,
				close: onClose,
				closed: onClosed
			}
		};

		if (typeof closeByBackdropClick !== 'undefined') popupParams.closeByBackdropClick = closeByBackdropClick;
		if (typeof closeOnEscape !== 'undefined') popupParams.closeOnEscape = closeOnEscape;
		if (typeof animate !== 'undefined') popupParams.animate = animate;
		if (typeof backdrop !== 'undefined') popupParams.backdrop = backdrop;
		if (typeof backdropEl !== 'undefined') popupParams.backdropEl = backdropEl;
		if (typeof swipeToClose !== 'undefined') popupParams.swipeToClose = swipeToClose;
		if (typeof swipeHandler !== 'undefined') popupParams.swipeHandler = swipeHandler;
		if (typeof containerEl !== 'undefined') popupParams.containerEl = containerEl;

		f7ready(() => {
			$$invalidate(1, f7Popup = app.f7.popup.create(popupParams));

			if (opened) {
				f7Popup.open(false);
			}
		});
	});

	onDestroy(() => {
		if (f7Popup) f7Popup.destroy();
		$$invalidate(1, f7Popup = null);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(34, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(5, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('tabletFullscreen' in $$new_props) $$invalidate(7, tabletFullscreen = $$new_props.tabletFullscreen);
		if ('opened' in $$new_props) $$invalidate(4, opened = $$new_props.opened);
		if ('animate' in $$new_props) $$invalidate(8, animate = $$new_props.animate);
		if ('backdrop' in $$new_props) $$invalidate(9, backdrop = $$new_props.backdrop);
		if ('backdropEl' in $$new_props) $$invalidate(10, backdropEl = $$new_props.backdropEl);
		if ('closeByBackdropClick' in $$new_props) $$invalidate(11, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ('closeOnEscape' in $$new_props) $$invalidate(12, closeOnEscape = $$new_props.closeOnEscape);
		if ('swipeToClose' in $$new_props) $$invalidate(13, swipeToClose = $$new_props.swipeToClose);
		if ('swipeHandler' in $$new_props) $$invalidate(14, swipeHandler = $$new_props.swipeHandler);
		if ('push' in $$new_props) $$invalidate(15, push = $$new_props.push);
		if ('containerEl' in $$new_props) $$invalidate(16, containerEl = $$new_props.containerEl);
		if ('$$scope' in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(2, classes = classNames(
			className,
			'popup',
			{
				'popup-tablet-fullscreen': tabletFullscreen,
				'popup-push': push
			},
			modalStateClasses(state),
			colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*opened*/ 16) {
			$: watchOpened(opened);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		f7Popup,
		classes,
		$$restProps,
		opened,
		lec,
		className,
		tabletFullscreen,
		animate,
		backdrop,
		backdropEl,
		closeByBackdropClick,
		closeOnEscape,
		swipeToClose,
		swipeHandler,
		push,
		containerEl,
		instance,
		$$scope,
		slots,
		div_binding
	];
}

class Popup extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance_1$f,
			create_fragment$1B,
			safe_not_equal,
			{
				lec: 5,
				class: 6,
				tabletFullscreen: 7,
				opened: 4,
				animate: 8,
				backdrop: 9,
				backdropEl: 10,
				closeByBackdropClick: 11,
				closeOnEscape: 12,
				swipeToClose: 13,
				swipeHandler: 14,
				push: 15,
				containerEl: 16,
				instance: 17
			},
			null,
			[-1, -1]
		);
	}

	get instance() {
		return this.$$.ctx[17];
	}
}

const getRouterInitialComponent = (router, initialComponent) => {
  let initialComponentData;
  const {
    initialUrl
  } = router.getInitialUrl();
  const initialRoute = router.findMatchingRoute(initialUrl);
  let routeProps = {};
  if (initialRoute && initialRoute.route && initialRoute.route.options) {
    routeProps = initialRoute.route.options.props;
  }
  const isMasterRoute = route => {
    if (route.master === true) return true;
    if (typeof route.master === 'function') return route.master(router.app);
    return false;
  };
  if (initialRoute && initialRoute.route && (initialRoute.route.component || initialRoute.route.asyncComponent) && !isMasterRoute(initialRoute.route)) {
    initialComponentData = {
      component: initialRoute.route.component || initialRoute.route.asyncComponent,
      initialComponent,
      id: getComponentId(),
      isAsync: !!initialRoute.route.asyncComponent,
      props: {
        f7route: initialRoute,
        f7router: router,
        ...initialRoute.params,
        ...routeProps
      }
    };
  }
  return {
    initialPage: initialComponentData,
    initialRoute
  };
};

// eslint-disable-next-line
const useTab = (getEl, emit) => {
  const onTabShow = el => {
    if (getEl() !== el) return;
    emit('tabShow', [el]);
  };
  const onTabHide = el => {
    if (getEl() !== el) return;
    emit('tabHide', [el]);
  };
  const attachEvents = () => {
    if (!getEl()) return;
    f7ready(() => {
      f7.on('tabShow', onTabShow);
      f7.on('tabHide', onTabHide);
    });
  };
  const detachEvents = () => {
    if (!f7) return;
    f7.off('tabShow', onTabShow);
    f7.off('tabHide', onTabHide);
  };
  onMount(() => {
    attachEvents();
  });
  onDestroy(() => {
    detachEvents();
  });
};

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/router-context-provider.liquivelte generated by Svelte v3.50.0 */

function create_fragment$1A(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$1C = 0;

function instance$1m($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { route = undefined } = $$props;
	let { router = undefined } = $$props;
	setContext('RouterContext', { route, router });

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(0, lec = $$props.lec);
		if ('route' in $$props) $$invalidate(1, route = $$props.route);
		if ('router' in $$props) $$invalidate(2, router = $$props.router);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [lec, route, router, $$scope, slots];
}

class Router_context_provider extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1m, create_fragment$1A, safe_not_equal, { lec: 0, route: 1, router: 2 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/view.liquivelte generated by Svelte v3.50.0 */

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i];
	return child_ctx;
}

const get_default_slot_changes$b = dirty => ({ view: dirty[0] & /*f7View*/ 16 });
const get_default_slot_context$b = ctx => ({ view: /*f7View*/ ctx[4] });

// (201:4) <RouterContextProvider  route={page.props.f7route} router={page.props.f7router}     lec={lec} >
function create_default_slot$a(ctx) {
	let switch_instance;
	let t;
	let current;
	const switch_instance_spread_levels = [/*page*/ ctx[33].props];
	var switch_value = /*page*/ ctx[33].component;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			t = space();
		},
		l(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			t = claim_space(nodes);
		},
		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_hydration(target, t, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = (dirty[0] & /*pages*/ 32)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*page*/ ctx[33].props)])
			: {};

			if (switch_value !== (switch_value = /*page*/ ctx[33].component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, t.parentNode, t);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (switch_instance) destroy_component(switch_instance, detaching);
			if (detaching) detach(t);
		}
	};
}

// (200:2) {#each pages as page (page.id)}
function create_each_block$4(key_1, ctx) {
	let first;
	let routercontextprovider;
	let current;

	routercontextprovider = new Router_context_provider({
			props: {
				route: /*page*/ ctx[33].props.f7route,
				router: /*page*/ ctx[33].props.f7router,
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot$a] },
				$$scope: { ctx }
			}
		});

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			create_component(routercontextprovider.$$.fragment);
			this.h();
		},
		l(nodes) {
			first = empty();
			claim_component(routercontextprovider.$$.fragment, nodes);
			this.h();
		},
		h() {
			this.first = first;
		},
		m(target, anchor) {
			insert_hydration(target, first, anchor);
			mount_component(routercontextprovider, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const routercontextprovider_changes = {};
			if (dirty[0] & /*pages*/ 32) routercontextprovider_changes.route = /*page*/ ctx[33].props.f7route;
			if (dirty[0] & /*pages*/ 32) routercontextprovider_changes.router = /*page*/ ctx[33].props.f7router;
			if (dirty[0] & /*lec*/ 1) routercontextprovider_changes.lec = /*lec*/ ctx[0];

			if (dirty[0] & /*$$scope, pages*/ 8224) {
				routercontextprovider_changes.$$scope = { dirty, ctx };
			}

			routercontextprovider.$set(routercontextprovider_changes);
		},
		i(local) {
			if (current) return;
			transition_in(routercontextprovider.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(routercontextprovider.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			destroy_component(routercontextprovider, detaching);
		}
	};
}

function create_fragment$1z(ctx) {
	let div;
	let t;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], get_default_slot_context$b);
	let each_value = /*pages*/ ctx[5];
	const get_key = ctx => /*page*/ ctx[33].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$4(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$4(key, child_ctx));
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true, id: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			t = claim_space(div_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", /*classes*/ ctx[6]);
			attr(div, "style", /*style*/ ctx[2]);
			attr(div, "id", /*id*/ ctx[1]);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_hydration(div, t);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			/*div_binding*/ ctx[12](div);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope, f7View*/ 8208)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, get_default_slot_changes$b),
						get_default_slot_context$b
					);
				}
			}

			if (dirty[0] & /*pages, lec*/ 33) {
				each_value = /*pages*/ ctx[5];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$4, null, get_each_context$4);
				check_outros();
			}

			if (!current || dirty[0] & /*classes*/ 64) {
				attr(div, "class", /*classes*/ ctx[6]);
			}

			if (!current || dirty[0] & /*style*/ 4) {
				attr(div, "style", /*style*/ ctx[2]);
			}

			if (!current || dirty[0] & /*id*/ 2) {
				attr(div, "id", /*id*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			transition_out(default_slot, local);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*div_binding*/ ctx[12](null);
		}
	};
}

let index$1B = 0;

function instance_1$e($$self, $$props, $$invalidate) {
	let classes;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { id = undefined } = $$props;
	let { style = undefined } = $$props;
	let { init = true } = $$props;
	let { url = undefined } = $$props;
	let { class: className = undefined } = $$props;
	const emit = createEmitter(createEventDispatcher, $$props);
	const { main, tab, tabActive, browserHistoryInitialMatch = true, initRouterOnTabShow } = $$props;
	const shouldInitRouter = !(initRouterOnTabShow && tab && !tabActive);
	let initialPage;
	let initialRoute;
	let el;
	let routerData;
	let f7View;

	function instance() {
		return f7View;
	}

	function onViewInit(view) {
		emit('viewInit', [view]);

		if (!init) {
			$$invalidate(4, f7View = view);
			routerData.instance = view;
		}
	}

	if (app.f7 && !f7View && init) {
		const routerId = getRouterId();

		f7View = app.f7.views.create(el, {
			routerId,
			init: false,
			...noUndefinedProps($$props),
			browserHistoryInitialMatch,
			on: { init: onViewInit }
		});

		routerData = { routerId, instance: f7View };
		app.f7routers.views.push(routerData);

		if (shouldInitRouter && f7View && f7View.router && (url || main)) {
			const initialData = getRouterInitialComponent(f7View.router);
			initialPage = initialData.initialPage;
			initialRoute = initialData.initialRoute;

			if (initialRoute && initialRoute.route && initialRoute.route.masterRoute) {
				initialPage = undefined;
				initialRoute = undefined;
			}
		}
	}

	let pages = initialPage ? [initialPage] : [];

	function onResize(view, width) {
		emit('viewResize', [width]);
	}

	function onSwipeBackMove(data) {
		emit('swipeBackMove', [data]);
	}

	function onSwipeBackBeforeChange(data) {
		emit('swipeBackBeforeChange', [data]);
	}

	function onSwipeBackAfterChange(data) {
		emit('swipeBackAfterChange', [data]);
	}

	function onSwipeBackBeforeReset(data) {
		emit('swipeBackBeforeReset', [data]);
	}

	function onSwipeBackAfterReset(data) {
		emit('swipeBackAfterReset', [data]);
	}

	useTab(() => el, emit);

	onMount(() => {
		f7ready(() => {
			if (f7View) {
				routerData.el = el;
				routerData.pages = pages;

				routerData.setPages = newPages => {
					tick().then(() => {
						$$invalidate(5, pages = newPages);
					});
				};

				if (initialPage && initialPage.isAsync && !initialPage.initialComponent) {
					initialPage.component().then(() => {
						setTimeout(
							() => {
								f7View.init(el);

								if (initialPage) {
									initialPage.el = f7View.router.currentPageEl;

									if (initialRoute && initialRoute.route && initialRoute.route.keepAlive) {
										initialRoute.route.keepAliveData = { pageEl: initialPage.el };
									}
								}
							},
							100
						);
					});
				} else {
					f7View.init(el);

					if (initialPage) {
						initialPage.el = f7View.router.currentPageEl;

						if (initialRoute && initialRoute.route && initialRoute.route.keepAlive) {
							initialRoute.route.keepAliveData = { pageEl: initialPage.el };
						}
					}
				}
			} else {
				const routerId = getRouterId();

				routerData = {
					el,
					routerId,
					pages,
					instance: f7View,
					setPages(newPages) {
						tick().then(() => {
							$$invalidate(5, pages = newPages);
						});
					}
				};

				app.f7routers.views.push(routerData);

				routerData.instance = app.f7.views.create(el, {
					routerId,
					...noUndefinedProps($$props),
					browserHistoryInitialMatch,
					on: { init: onViewInit }
				});

				$$invalidate(4, f7View = routerData.instance);
			}

			if (!init) return;
			f7View.on('resize', onResize);
			f7View.on('swipebackMove', onSwipeBackMove);
			f7View.on('swipebackBeforeChange', onSwipeBackBeforeChange);
			f7View.on('swipebackAfterChange', onSwipeBackAfterChange);
			f7View.on('swipebackBeforeReset', onSwipeBackBeforeReset);
			f7View.on('swipebackAfterReset', onSwipeBackAfterReset);
		});
	});

	afterUpdate(() => {
		if (!routerData) return;
		app.f7events.emit('viewRouterDidUpdate', routerData);
	});

	onDestroy(() => {
		if (f7View) {
			f7View.off('resize', onResize);
			f7View.off('swipebackMove', onSwipeBackMove);
			f7View.off('swipebackBeforeChange', onSwipeBackBeforeChange);
			f7View.off('swipebackAfterChange', onSwipeBackAfterChange);
			f7View.off('swipebackBeforeReset', onSwipeBackBeforeReset);
			f7View.off('swipebackAfterReset', onSwipeBackAfterReset);
			if (f7View.destroy) f7View.destroy();
			$$invalidate(4, f7View = null);
		}

		app.f7routers.views.splice(app.f7routers.views.indexOf(routerData), 1);
		routerData = null;
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('lec' in $$new_props) $$invalidate(0, lec = $$new_props.lec);
		if ('id' in $$new_props) $$invalidate(1, id = $$new_props.id);
		if ('style' in $$new_props) $$invalidate(2, style = $$new_props.style);
		if ('init' in $$new_props) $$invalidate(7, init = $$new_props.init);
		if ('url' in $$new_props) $$invalidate(8, url = $$new_props.url);
		if ('class' in $$new_props) $$invalidate(9, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(6, classes = classNames(
			className,
			'view',
			{
				'view-main': main,
				'tab-active': tabActive,
				tab
			},
			colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		lec,
		id,
		style,
		el,
		f7View,
		pages,
		classes,
		init,
		url,
		className,
		instance,
		slots,
		div_binding,
		$$scope
	];
}

class View extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance_1$e,
			create_fragment$1z,
			safe_not_equal,
			{
				lec: 0,
				id: 1,
				style: 2,
				init: 7,
				url: 8,
				class: 9,
				instance: 10
			},
			null,
			[-1, -1]
		);
	}

	get instance() {
		return this.$$.ctx[10];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/login-screen.liquivelte generated by Svelte v3.50.0 */
const get_default_slot_changes$a = dirty => ({ loginScreen: dirty & /*f7LoginScreen*/ 2 });
const get_default_slot_context$a = ctx => ({ loginScreen: /*f7LoginScreen*/ ctx[1] });

function create_fragment$1y(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], get_default_slot_context$a);
	let div_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[12](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope, f7LoginScreen*/ 1026)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[10],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, get_default_slot_changes$a),
						get_default_slot_context$a
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[12](null);
		}
	};
}

let index$1A = 0;

function instance_1$d($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class","opened","animate","containerEl","instance"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { opened = undefined } = $$props;
	let { animate = undefined } = $$props;
	let { containerEl = undefined } = $$props;
	let el;
	let f7LoginScreen;
	const state = { isOpened: opened, isClosing: false };

	function instance() {
		return f7LoginScreen;
	}

	function onOpen(instance) {
		Object.assign(state, { isOpened: true, isClosing: false });
		emit('loginscreenOpen loginScreenOpen', [instance]);
		$$invalidate(4, opened = true);
	}

	function onOpened(instance) {
		emit('loginscreenOpened loginScreenOpened', [instance]);
	}

	function onClose(instance) {
		Object.assign(state, { isOpened: false, isClosing: true });
		emit('loginscreenClose loginScreenClose', [instance]);
	}

	function onClosed(instance) {
		Object.assign(state, { isClosing: false });
		emit('loginscreenClosed loginScreenClosed', [instance]);
		$$invalidate(4, opened = false);
	}

	let initialWatched = false;

	function watchOpened(openedPassed) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7LoginScreen) return;
		if (openedPassed) f7LoginScreen.open(); else f7LoginScreen.close();
	}

	onMount(() => {
		const params = {
			el,
			on: {
				open: onOpen,
				opened: onOpened,
				close: onClose,
				closed: onClosed
			}
		};

		if (typeof animate !== 'undefined') params.animate = animate;
		if (typeof containerEl !== 'undefined') params.containerEl = animate;

		f7ready(() => {
			$$invalidate(1, f7LoginScreen = app.f7.loginScreen.create(params));

			if (opened) {
				f7LoginScreen.open(false);
			}
		});
	});

	onDestroy(() => {
		if (f7LoginScreen) f7LoginScreen.destroy();
		$$invalidate(1, f7LoginScreen = null);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(5, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('opened' in $$new_props) $$invalidate(4, opened = $$new_props.opened);
		if ('animate' in $$new_props) $$invalidate(7, animate = $$new_props.animate);
		if ('containerEl' in $$new_props) $$invalidate(8, containerEl = $$new_props.containerEl);
		if ('$$scope' in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(2, classes = classNames(className, 'login-screen', modalStateClasses(state), colorClasses($$props)));

		if ($$self.$$.dirty & /*opened*/ 16) {
			$: watchOpened(opened);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		f7LoginScreen,
		classes,
		$$restProps,
		opened,
		lec,
		className,
		animate,
		containerEl,
		instance,
		$$scope,
		slots,
		div_binding
	];
}

class Login_screen extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance_1$d, create_fragment$1y, safe_not_equal, {
			lec: 5,
			class: 6,
			opened: 4,
			animate: 7,
			containerEl: 8,
			instance: 9
		});
	}

	get instance() {
		return this.$$.ctx[9];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/sheet.liquivelte generated by Svelte v3.50.0 */
const get_static_slot_changes$1 = dirty => ({ sheet: dirty[0] & /*f7Sheet*/ 4 });
const get_static_slot_context$1 = ctx => ({ sheet: /*f7Sheet*/ ctx[2] });
const get_default_slot_changes$9 = dirty => ({ sheet: dirty[0] & /*f7Sheet*/ 4 });
const get_default_slot_context$9 = ctx => ({ sheet: /*f7Sheet*/ ctx[2] });
const get_fixed_slot_changes$1 = dirty => ({ sheet: dirty[0] & /*f7Sheet*/ 4 });
const get_fixed_slot_context$1 = ctx => ({ sheet: /*f7Sheet*/ ctx[2] });

function create_fragment$1x(ctx) {
	let div1;
	let t0;
	let div0;
	let t1;
	let current;
	const fixed_slot_template = /*#slots*/ ctx[26].fixed;
	const fixed_slot = create_slot(fixed_slot_template, ctx, /*$$scope*/ ctx[25], get_fixed_slot_context$1);
	const default_slot_template = /*#slots*/ ctx[26].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[25], get_default_slot_context$9);
	const static_slot_template = /*#slots*/ ctx[26].static;
	const static_slot = create_slot(static_slot_template, ctx, /*$$scope*/ ctx[25], get_static_slot_context$1);
	let div1_levels = [{ class: /*classes*/ ctx[3] }, restProps(/*$$restProps*/ ctx[4])];
	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	return {
		c() {
			div1 = element("div");
			if (fixed_slot) fixed_slot.c();
			t0 = space();
			div0 = element("div");
			if (default_slot) default_slot.c();
			t1 = space();
			if (static_slot) static_slot.c();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (fixed_slot) fixed_slot.l(div1_nodes);
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (default_slot) default_slot.l(div0_nodes);
			t1 = claim_space(div0_nodes);
			if (static_slot) static_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "sheet-modal-inner");
			set_attributes(div1, div1_data);
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);

			if (fixed_slot) {
				fixed_slot.m(div1, null);
			}

			append_hydration(div1, t0);
			append_hydration(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			append_hydration(div0, t1);

			if (static_slot) {
				static_slot.m(div0, null);
			}

			/*div0_binding*/ ctx[27](div0);
			/*div1_binding*/ ctx[28](div1);
			current = true;
		},
		p(ctx, dirty) {
			if (fixed_slot) {
				if (fixed_slot.p && (!current || dirty[0] & /*$$scope, f7Sheet*/ 33554436)) {
					update_slot_base(
						fixed_slot,
						fixed_slot_template,
						ctx,
						/*$$scope*/ ctx[25],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[25])
						: get_slot_changes(fixed_slot_template, /*$$scope*/ ctx[25], dirty, get_fixed_slot_changes$1),
						get_fixed_slot_context$1
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope, f7Sheet*/ 33554436)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[25],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[25])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[25], dirty, get_default_slot_changes$9),
						get_default_slot_context$9
					);
				}
			}

			if (static_slot) {
				if (static_slot.p && (!current || dirty[0] & /*$$scope, f7Sheet*/ 33554436)) {
					update_slot_base(
						static_slot,
						static_slot_template,
						ctx,
						/*$$scope*/ ctx[25],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[25])
						: get_slot_changes(static_slot_template, /*$$scope*/ ctx[25], dirty, get_static_slot_changes$1),
						get_static_slot_context$1
					);
				}
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty[0] & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				dirty[0] & /*$$restProps*/ 16 && restProps(/*$$restProps*/ ctx[4])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(fixed_slot, local);
			transition_in(default_slot, local);
			transition_in(static_slot, local);
			current = true;
		},
		o(local) {
			transition_out(fixed_slot, local);
			transition_out(default_slot, local);
			transition_out(static_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (fixed_slot) fixed_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (static_slot) static_slot.d(detaching);
			/*div0_binding*/ ctx[27](null);
			/*div1_binding*/ ctx[28](null);
		}
	};
}

let index$1z = 0;

function instance_1$c($$self, $$props, $$invalidate) {
	let positionComputed;
	let classes;

	const omit_props_names = [
		"lec","class","opened","animate","top","bottom","position","backdrop","backdropEl","closeByBackdropClick","closeByOutsideClick","closeOnEscape","push","swipeToClose","swipeToStep","swipeHandler","containerEl","instance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { opened = undefined } = $$props;
	let { animate = undefined } = $$props;
	let { top = undefined } = $$props;
	let { bottom = undefined } = $$props;
	let { position = undefined } = $$props;
	let { backdrop = undefined } = $$props;
	let { backdropEl = undefined } = $$props;
	let { closeByBackdropClick = undefined } = $$props;
	let { closeByOutsideClick = undefined } = $$props;
	let { closeOnEscape = undefined } = $$props;
	let { push = undefined } = $$props;
	let { swipeToClose = undefined } = $$props;
	let { swipeToStep = undefined } = $$props;
	let { swipeHandler = undefined } = $$props;
	let { containerEl = undefined } = $$props;
	let el;
	let innerEl;
	let f7Sheet;

	const state = {
		isOpened: opened,
		isClosing: false,
		swipeStep: false
	};

	function instance() {
		return f7Sheet;
	}

	function onOpen(instance) {
		Object.assign(state, { isOpened: true, isClosing: false });
		emit('sheetOpen', [instance]);
		$$invalidate(5, opened = true);
	}

	function onOpened(instance) {
		emit('sheetOpened', [instance]);
	}

	function onClose(instance) {
		Object.assign(state, { isOpened: false, isClosing: true });
		emit('sheetClose', [instance]);
	}

	function onClosed(instance) {
		Object.assign(state, { isClosing: false });
		emit('sheetClosed', [instance]);
		$$invalidate(5, opened = false);
	}

	function onStepProgress(instance, progress) {
		emit('sheetStepProgress', [instance, progress]);
	}

	function onStepOpen(instance) {
		emit('sheetStepOpen', [instance]);
	}

	function onStepClose(instance) {
		emit('sheetStepClose', [instance]);
	}

	let initialWatched = false;

	function watchOpened(openedPassed) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7Sheet) return;
		if (openedPassed) f7Sheet.open(); else f7Sheet.close();
	}

	onMount(() => {
		const params = {
			el,
			on: {
				open: onOpen,
				opened: onOpened,
				close: onClose,
				closed: onClosed,
				stepOpen: onStepOpen,
				stepClose: onStepClose,
				stepProgress: onStepProgress,
				// eslint-disable-next-line
				_swipeStep(isSwipeStep) {
					$$invalidate(23, state.swipeStep = isSwipeStep, state);
				}
			}
		};

		if (typeof backdrop !== 'undefined') params.backdrop = backdrop;
		if (typeof animate !== 'undefined') params.animate = animate;
		if (typeof backdropEl !== 'undefined') params.backdropEl = backdropEl;
		if (typeof closeByBackdropClick !== 'undefined') params.closeByBackdropClick = closeByBackdropClick;
		if (typeof closeByOutsideClick !== 'undefined') params.closeByOutsideClick = closeByOutsideClick;
		if (typeof closeOnEscape !== 'undefined') params.closeOnEscape = closeOnEscape;
		if (typeof swipeToClose !== 'undefined') params.swipeToClose = swipeToClose;
		if (typeof swipeToStep !== 'undefined') params.swipeToStep = swipeToStep;
		if (typeof swipeHandler !== 'undefined') params.swipeHandler = swipeHandler;
		if (typeof containerEl !== 'undefined') params.containerEl = containerEl;

		f7ready(() => {
			if (el && innerEl) {
				const dom7 = app.f7.$;
				const fixedEls = dom7(innerEl).children('.navbar, .toolbar, .tabbar, .searchbar');

				if (fixedEls.length) {
					dom7(el).prepend(fixedEls);
				}
			}

			$$invalidate(2, f7Sheet = app.f7.sheet.create(params));

			if (opened) {
				f7Sheet.open(false);
			}
		});
	});

	onDestroy(() => {
		if (f7Sheet) f7Sheet.destroy();
		$$invalidate(2, f7Sheet = null);
	});

	function div0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			innerEl = $$value;
			$$invalidate(1, innerEl);
		});
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(40, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(6, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(7, className = $$new_props.class);
		if ('opened' in $$new_props) $$invalidate(5, opened = $$new_props.opened);
		if ('animate' in $$new_props) $$invalidate(8, animate = $$new_props.animate);
		if ('top' in $$new_props) $$invalidate(9, top = $$new_props.top);
		if ('bottom' in $$new_props) $$invalidate(10, bottom = $$new_props.bottom);
		if ('position' in $$new_props) $$invalidate(11, position = $$new_props.position);
		if ('backdrop' in $$new_props) $$invalidate(12, backdrop = $$new_props.backdrop);
		if ('backdropEl' in $$new_props) $$invalidate(13, backdropEl = $$new_props.backdropEl);
		if ('closeByBackdropClick' in $$new_props) $$invalidate(14, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ('closeByOutsideClick' in $$new_props) $$invalidate(15, closeByOutsideClick = $$new_props.closeByOutsideClick);
		if ('closeOnEscape' in $$new_props) $$invalidate(16, closeOnEscape = $$new_props.closeOnEscape);
		if ('push' in $$new_props) $$invalidate(17, push = $$new_props.push);
		if ('swipeToClose' in $$new_props) $$invalidate(18, swipeToClose = $$new_props.swipeToClose);
		if ('swipeToStep' in $$new_props) $$invalidate(19, swipeToStep = $$new_props.swipeToStep);
		if ('swipeHandler' in $$new_props) $$invalidate(20, swipeHandler = $$new_props.swipeHandler);
		if ('containerEl' in $$new_props) $$invalidate(21, containerEl = $$new_props.containerEl);
		if ('$$scope' in $$new_props) $$invalidate(25, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*position, top, bottom*/ 3584) {
			$: $$invalidate(24, positionComputed = (() => {
				if (position) return position;
				if (top) return 'top';
				if (bottom) return 'bottom';
				return 'bottom';
			})());
		}

		$: $$invalidate(3, classes = classNames(
			className,
			'sheet-modal',
			`sheet-modal-${positionComputed}`,
			{
				'sheet-modal-push': push,
				'modal-in-swipe-step': state.swipeStep
			},
			modalStateClasses(state),
			colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*opened*/ 32) {
			$: watchOpened(opened);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		innerEl,
		f7Sheet,
		classes,
		$$restProps,
		opened,
		lec,
		className,
		animate,
		top,
		bottom,
		position,
		backdrop,
		backdropEl,
		closeByBackdropClick,
		closeByOutsideClick,
		closeOnEscape,
		push,
		swipeToClose,
		swipeToStep,
		swipeHandler,
		containerEl,
		instance,
		state,
		positionComputed,
		$$scope,
		slots,
		div0_binding,
		div1_binding
	];
}

class Sheet extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance_1$c,
			create_fragment$1x,
			safe_not_equal,
			{
				lec: 6,
				class: 7,
				opened: 5,
				animate: 8,
				top: 9,
				bottom: 10,
				position: 11,
				backdrop: 12,
				backdropEl: 13,
				closeByBackdropClick: 14,
				closeByOutsideClick: 15,
				closeOnEscape: 16,
				push: 17,
				swipeToClose: 18,
				swipeToStep: 19,
				swipeHandler: 20,
				containerEl: 21,
				instance: 22
			},
			null,
			[-1, -1]
		);
	}

	get instance() {
		return this.$$.ctx[22];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/popover.liquivelte generated by Svelte v3.50.0 */
const get_default_slot_changes$8 = dirty => ({ popover: dirty & /*f7Popover*/ 2 });
const get_default_slot_context$8 = ctx => ({ popover: /*f7Popover*/ ctx[1] });

function create_fragment$1w(ctx) {
	let div2;
	let div0;
	let t;
	let div1;
	let current;
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], get_default_slot_context$8);
	let div2_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			t = space();
			div1 = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			children(div0).forEach(detach);
			t = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (default_slot) default_slot.l(div1_nodes);
			div1_nodes.forEach(detach);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "popover-angle");
			attr(div1, "class", "popover-inner");
			set_attributes(div2, div2_data);
		},
		m(target, anchor) {
			insert_hydration(target, div2, anchor);
			append_hydration(div2, div0);
			append_hydration(div2, t);
			append_hydration(div2, div1);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			/*div2_binding*/ ctx[19](div2);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope, f7Popover*/ 131074)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[17],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, get_default_slot_changes$8),
						get_default_slot_context$8
					);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			if (default_slot) default_slot.d(detaching);
			/*div2_binding*/ ctx[19](null);
		}
	};
}

let index$1y = 0;

function instance_1$b($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"lec","class","opened","animate","targetEl","backdrop","backdropEl","closeByBackdropClick","closeByOutsideClick","closeOnEscape","containerEl","verticalPosition","instance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { opened = undefined } = $$props;
	let { animate = undefined } = $$props;
	let { targetEl = undefined } = $$props;
	let { backdrop = undefined } = $$props;
	let { backdropEl = undefined } = $$props;
	let { closeByBackdropClick = undefined } = $$props;
	let { closeByOutsideClick = undefined } = $$props;
	let { closeOnEscape = undefined } = $$props;
	let { containerEl = undefined } = $$props;
	let { verticalPosition = undefined } = $$props;
	let el;
	let f7Popover;
	const state = { isOpened: opened, isClosing: false };

	function instance() {
		return f7Popover;
	}

	function onOpen(instance) {
		Object.assign(state, { isOpened: true, isClosing: false });
		emit('popoverOpen', [instance]);
		$$invalidate(4, opened = true);
	}

	function onOpened(instance) {
		emit('popoverOpened', [instance]);
	}

	function onClose(instance) {
		Object.assign(state, { isOpened: false, isClosing: true });
		emit('popoverClose', [instance]);
	}

	function onClosed(instance) {
		Object.assign(state, { isClosing: false });
		emit('popoverClosed', [instance]);
		$$invalidate(4, opened = false);
	}

	let initialWatched = false;

	function watchOpened(openedPassed) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7Popover) return;
		if (openedPassed) f7Popover.open(); else f7Popover.close();
	}

	onMount(() => {
		const params = {
			el,
			on: {
				open: onOpen,
				opened: onOpened,
				close: onClose,
				closed: onClosed
			}
		};

		if (targetEl) params.targetEl = targetEl;
		if (typeof animate !== 'undefined') params.animate = animate;
		if (typeof closeByBackdropClick !== 'undefined') params.closeByBackdropClick = closeByBackdropClick;
		if (typeof closeByOutsideClick !== 'undefined') params.closeByOutsideClick = closeByOutsideClick;
		if (typeof closeOnEscape !== 'undefined') params.closeOnEscape = closeOnEscape;
		if (typeof backdrop !== 'undefined') params.backdrop = backdrop;
		if (typeof backdropEl !== 'undefined') params.backdropEl = backdropEl;
		if (typeof containerEl !== 'undefined') params.containerEl = containerEl;
		if (typeof verticalPosition !== 'undefined') params.verticalPosition = verticalPosition;

		f7ready(() => {
			$$invalidate(1, f7Popover = app.f7.popover.create(params));

			if (opened) {
				f7Popover.open(targetEl, false);
			}
		});
	});

	onDestroy(() => {
		if (f7Popover) f7Popover.destroy();
		$$invalidate(1, f7Popover = null);
	});

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(29, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(5, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('opened' in $$new_props) $$invalidate(4, opened = $$new_props.opened);
		if ('animate' in $$new_props) $$invalidate(7, animate = $$new_props.animate);
		if ('targetEl' in $$new_props) $$invalidate(8, targetEl = $$new_props.targetEl);
		if ('backdrop' in $$new_props) $$invalidate(9, backdrop = $$new_props.backdrop);
		if ('backdropEl' in $$new_props) $$invalidate(10, backdropEl = $$new_props.backdropEl);
		if ('closeByBackdropClick' in $$new_props) $$invalidate(11, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ('closeByOutsideClick' in $$new_props) $$invalidate(12, closeByOutsideClick = $$new_props.closeByOutsideClick);
		if ('closeOnEscape' in $$new_props) $$invalidate(13, closeOnEscape = $$new_props.closeOnEscape);
		if ('containerEl' in $$new_props) $$invalidate(14, containerEl = $$new_props.containerEl);
		if ('verticalPosition' in $$new_props) $$invalidate(15, verticalPosition = $$new_props.verticalPosition);
		if ('$$scope' in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(2, classes = classNames(className, 'popover', modalStateClasses(state), colorClasses($$props)));

		if ($$self.$$.dirty & /*opened*/ 16) {
			$: watchOpened(opened);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		f7Popover,
		classes,
		$$restProps,
		opened,
		lec,
		className,
		animate,
		targetEl,
		backdrop,
		backdropEl,
		closeByBackdropClick,
		closeByOutsideClick,
		closeOnEscape,
		containerEl,
		verticalPosition,
		instance,
		$$scope,
		slots,
		div2_binding
	];
}

class Popover extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance_1$b, create_fragment$1w, safe_not_equal, {
			lec: 5,
			class: 6,
			opened: 4,
			animate: 7,
			targetEl: 8,
			backdrop: 9,
			backdropEl: 10,
			closeByBackdropClick: 11,
			closeByOutsideClick: 12,
			closeOnEscape: 13,
			containerEl: 14,
			verticalPosition: 15,
			instance: 16
		});
	}

	get instance() {
		return this.$$.ctx[16];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/panel.liquivelte generated by Svelte v3.50.0 */
const get_default_slot_changes$7 = dirty => ({ panel: dirty[0] & /*f7Panel*/ 8 });
const get_default_slot_context$7 = ctx => ({ panel: /*f7Panel*/ ctx[3] });

// (210:2) {#if resizable}
function create_if_block$F(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "panel-resize-handler");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$1v(ctx) {
	let div;
	let t;
	let current;
	const default_slot_template = /*#slots*/ ctx[31].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[30], get_default_slot_context$7);
	let if_block = /*resizable*/ ctx[0] && create_if_block$F(ctx);

	let div_levels = [
		{ class: /*classes*/ ctx[4] },
		{ "data-f7-slot": /*f7Slot*/ ctx[1] },
		restProps(/*$$restProps*/ ctx[5])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true, "data-f7-slot": true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			t = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_hydration(div, t);
			if (if_block) if_block.m(div, null);
			/*div_binding*/ ctx[32](div);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope, f7Panel*/ 1073741832)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[30],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[30])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[30], dirty, get_default_slot_changes$7),
						get_default_slot_context$7
					);
				}
			}

			if (/*resizable*/ ctx[0]) {
				if (if_block) {
					
				} else {
					if_block = create_if_block$F(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				(!current || dirty[0] & /*f7Slot*/ 2) && { "data-f7-slot": /*f7Slot*/ ctx[1] },
				dirty[0] & /*$$restProps*/ 32 && restProps(/*$$restProps*/ ctx[5])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			/*div_binding*/ ctx[32](null);
		}
	};
}

let index$1x = 0;

function instance_1$a($$self, $$props, $$invalidate) {
	let sideComputed;
	let effectComputed;
	let classes;

	const omit_props_names = [
		"lec","class","side","effect","cover","reveal","push","left","right","opened","resizable","backdrop","backdropEl","containerEl","closeByBackdropClick","visibleBreakpoint","collapsedBreakpoint","swipe","swipeNoFollow","swipeOnlyClose","swipeActiveArea","swipeThreshold","f7Slot","instance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { side = undefined } = $$props;
	let { effect = undefined } = $$props;
	let { cover = false } = $$props;
	let { reveal = false } = $$props;
	let { push = false } = $$props;
	let { left = false } = $$props;
	let { right = false } = $$props;
	let { opened = false } = $$props;
	let { resizable = false } = $$props;
	let { backdrop = true } = $$props;
	let { backdropEl = undefined } = $$props;
	let { containerEl = undefined } = $$props;
	let { closeByBackdropClick = undefined } = $$props;
	let { visibleBreakpoint = undefined } = $$props;
	let { collapsedBreakpoint = undefined } = $$props;
	let { swipe = false } = $$props;
	let { swipeNoFollow = false } = $$props;
	let { swipeOnlyClose = false } = $$props;
	let { swipeActiveArea = 0 } = $$props;
	let { swipeThreshold = 0 } = $$props;
	let { f7Slot = 'fixed' } = $$props;
	let el;
	let f7Panel;

	const state = {
		isOpened: false,
		isClosing: false,
		isCollapsed: false,
		isBreakpoint: false
	};

	function instance() {
		return f7Panel;
	}

	let resizableOld = resizable;
	let initialWatchedResizable = false;

	function watchResizable(r) {
		if (!initialWatchedResizable) {
			initialWatchedResizable = true;
			return;
		}

		if (f7Panel && r && !resizableOld) {
			f7Panel.enableResizable();
		} else if (f7Panel && !r && resizableOld) {
			f7Panel.disableResizable();
		}

		resizableOld = r;
	}

	let openedOld = opened;
	let initialWatchedOpened = false;

	function watchOpened(o) {
		if (!initialWatchedOpened) {
			initialWatchedOpened = true;
			return;
		}

		if (f7Panel && o && !openedOld) {
			f7Panel.open();
		} else if (f7Panel && !o && openedOld) {
			f7Panel.close();
		}

		openedOld = o;
	}

	function onOpen(...args) {
		Object.assign(state, { isOpened: true, isClosing: false });
		emit('panelOpen', args);
		$$invalidate(6, opened = true);
	}

	function onOpened(...args) {
		emit('panelOpened', args);
	}

	function onClose(...args) {
		Object.assign(state, { isOpened: false, isClosing: true });
		emit('panelClose', args);
	}

	function onClosed(...args) {
		Object.assign(state, { isClosing: false });
		emit('panelClosed', args);
		$$invalidate(6, opened = false);
	}

	function onBackdropClick(...args) {
		emit('panelBackdropClick', args);
	}

	function onSwipe(...args) {
		emit('panelSwipe', args);
	}

	function onSwipeOpen(...args) {
		emit('panelSwipeOpen', args);
	}

	function onBreakpoint(...args) {
		Object.assign(state, { isBreakpoint: true, isCollapsed: false });
		emit('panelBreakpoint', args);
	}

	function onCollapsedBreakpoint(...args) {
		Object.assign(state, { isBreakpoint: false, isCollapsed: true });
		emit('panelCollapsedBreakpoint', args);
	}

	function onResize(...args) {
		emit('panelResize', args);
	}

	onMount(() => {
		f7ready(() => {
			const dom7 = app.f7.$;

			if (dom7('.panel-backdrop').length === 0) {
				dom7('<div class="panel-backdrop"></div>').insertBefore(el);
			}

			const params = noUndefinedProps({
				el,
				resizable,
				backdrop,
				backdropEl,
				containerEl,
				closeByBackdropClick,
				visibleBreakpoint,
				collapsedBreakpoint,
				swipe,
				swipeNoFollow,
				swipeOnlyClose,
				swipeActiveArea,
				swipeThreshold,
				on: {
					open: onOpen,
					opened: onOpened,
					close: onClose,
					closed: onClosed,
					backdropClick: onBackdropClick,
					swipe: onSwipe,
					swipeOpen: onSwipeOpen,
					collapsedBreakpoint: onCollapsedBreakpoint,
					breakpoint: onBreakpoint,
					resize: onResize
				}
			});

			$$invalidate(3, f7Panel = app.f7.panel.create(params));

			if (opened) {
				f7Panel.open(false);
			}
		});
	});

	onDestroy(() => {
		if (f7Panel && f7Panel.destroy) {
			f7Panel.destroy();
		}

		$$invalidate(3, f7Panel = null);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(52, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(7, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ('side' in $$new_props) $$invalidate(9, side = $$new_props.side);
		if ('effect' in $$new_props) $$invalidate(10, effect = $$new_props.effect);
		if ('cover' in $$new_props) $$invalidate(11, cover = $$new_props.cover);
		if ('reveal' in $$new_props) $$invalidate(12, reveal = $$new_props.reveal);
		if ('push' in $$new_props) $$invalidate(13, push = $$new_props.push);
		if ('left' in $$new_props) $$invalidate(14, left = $$new_props.left);
		if ('right' in $$new_props) $$invalidate(15, right = $$new_props.right);
		if ('opened' in $$new_props) $$invalidate(6, opened = $$new_props.opened);
		if ('resizable' in $$new_props) $$invalidate(0, resizable = $$new_props.resizable);
		if ('backdrop' in $$new_props) $$invalidate(16, backdrop = $$new_props.backdrop);
		if ('backdropEl' in $$new_props) $$invalidate(17, backdropEl = $$new_props.backdropEl);
		if ('containerEl' in $$new_props) $$invalidate(18, containerEl = $$new_props.containerEl);
		if ('closeByBackdropClick' in $$new_props) $$invalidate(19, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ('visibleBreakpoint' in $$new_props) $$invalidate(20, visibleBreakpoint = $$new_props.visibleBreakpoint);
		if ('collapsedBreakpoint' in $$new_props) $$invalidate(21, collapsedBreakpoint = $$new_props.collapsedBreakpoint);
		if ('swipe' in $$new_props) $$invalidate(22, swipe = $$new_props.swipe);
		if ('swipeNoFollow' in $$new_props) $$invalidate(23, swipeNoFollow = $$new_props.swipeNoFollow);
		if ('swipeOnlyClose' in $$new_props) $$invalidate(24, swipeOnlyClose = $$new_props.swipeOnlyClose);
		if ('swipeActiveArea' in $$new_props) $$invalidate(25, swipeActiveArea = $$new_props.swipeActiveArea);
		if ('swipeThreshold' in $$new_props) $$invalidate(26, swipeThreshold = $$new_props.swipeThreshold);
		if ('f7Slot' in $$new_props) $$invalidate(1, f7Slot = $$new_props.f7Slot);
		if ('$$scope' in $$new_props) $$invalidate(30, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*side, left, right*/ 49664) {
			// eslint-disable-next-line
			$: $$invalidate(29, sideComputed = side || (left ? 'left' : right ? 'right' : 'left'));
		}

		if ($$self.$$.dirty[0] & /*effect, reveal, push*/ 13312) {
			// eslint-disable-next-line
			$: $$invalidate(28, effectComputed = effect || (reveal ? 'reveal' : push ? 'push' : 'cover'));
		}

		$: $$invalidate(4, classes = classNames(
			className,
			'panel',
			{
				'panel-in': state.isOpened && !state.isClosing && !state.isBreakpoint,
				'panel-in-breakpoint': state.isBreakpoint,
				'panel-in-collapsed': state.isCollapsed,
				'panel-resizable': resizable,
				[`panel-${sideComputed}`]: sideComputed,
				[`panel-${effectComputed}`]: effectComputed
			},
			colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*resizable*/ 1) {
			$: watchResizable(resizable);
		}

		if ($$self.$$.dirty[0] & /*opened*/ 64) {
			$: watchOpened(opened);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		resizable,
		f7Slot,
		el,
		f7Panel,
		classes,
		$$restProps,
		opened,
		lec,
		className,
		side,
		effect,
		cover,
		reveal,
		push,
		left,
		right,
		backdrop,
		backdropEl,
		containerEl,
		closeByBackdropClick,
		visibleBreakpoint,
		collapsedBreakpoint,
		swipe,
		swipeNoFollow,
		swipeOnlyClose,
		swipeActiveArea,
		swipeThreshold,
		instance,
		effectComputed,
		sideComputed,
		$$scope,
		slots,
		div_binding
	];
}

class Panel extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance_1$a,
			create_fragment$1v,
			safe_not_equal,
			{
				lec: 7,
				class: 8,
				side: 9,
				effect: 10,
				cover: 11,
				reveal: 12,
				push: 13,
				left: 14,
				right: 15,
				opened: 6,
				resizable: 0,
				backdrop: 16,
				backdropEl: 17,
				containerEl: 18,
				closeByBackdropClick: 19,
				visibleBreakpoint: 20,
				collapsedBreakpoint: 21,
				swipe: 22,
				swipeNoFollow: 23,
				swipeOnlyClose: 24,
				swipeActiveArea: 25,
				swipeThreshold: 26,
				f7Slot: 1,
				instance: 27
			},
			null,
			[-1, -1]
		);
	}

	get instance() {
		return this.$$.ctx[27];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/shared/router-open-in-component.liquivelte generated by Svelte v3.50.0 */

function create_if_block_4$a(ctx) {
	let popup;
	let current;

	popup = new Popup({
			props: {
				className: "popup-router-open-in",
				"data-url": /*url*/ ctx[2],
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot_4$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(popup.$$.fragment);
		},
		l(nodes) {
			claim_component(popup.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(popup, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const popup_changes = {};
			if (dirty & /*url*/ 4) popup_changes["data-url"] = /*url*/ ctx[2];
			if (dirty & /*lec*/ 1) popup_changes.lec = /*lec*/ ctx[0];

			if (dirty & /*$$scope, viewSelector, url, lec*/ 269) {
				popup_changes.$$scope = { dirty, ctx };
			}

			popup.$set(popup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(popup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(popup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(popup, detaching);
		}
	};
}

// (23:2) <Popup  className="popup-router-open-in" data-url={url}     lec={lec} >
function create_default_slot_4$2(ctx) {
	let view;
	let current;

	view = new View({
			props: {
				linksView: /*viewSelector*/ ctx[3],
				url: /*url*/ ctx[2],
				ignoreOpenIn: true,
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(view.$$.fragment);
		},
		l(nodes) {
			claim_component(view.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(view, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const view_changes = {};
			if (dirty & /*viewSelector*/ 8) view_changes.linksView = /*viewSelector*/ ctx[3];
			if (dirty & /*url*/ 4) view_changes.url = /*url*/ ctx[2];
			if (dirty & /*lec*/ 1) view_changes.lec = /*lec*/ ctx[0];
			view.$set(view_changes);
		},
		i(local) {
			if (current) return;
			transition_in(view.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(view.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(view, detaching);
		}
	};
}

// (27:0) {#if openIn === 'loginScreen' }
function create_if_block_3$g(ctx) {
	let loginscreen;
	let current;

	loginscreen = new Login_screen({
			props: {
				className: "login-screen-router-open-in",
				"data-url": /*url*/ ctx[2],
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot_3$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(loginscreen.$$.fragment);
		},
		l(nodes) {
			claim_component(loginscreen.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(loginscreen, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const loginscreen_changes = {};
			if (dirty & /*url*/ 4) loginscreen_changes["data-url"] = /*url*/ ctx[2];
			if (dirty & /*lec*/ 1) loginscreen_changes.lec = /*lec*/ ctx[0];

			if (dirty & /*$$scope, viewSelector, url, lec*/ 269) {
				loginscreen_changes.$$scope = { dirty, ctx };
			}

			loginscreen.$set(loginscreen_changes);
		},
		i(local) {
			if (current) return;
			transition_in(loginscreen.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(loginscreen.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(loginscreen, detaching);
		}
	};
}

// (28:2) <LoginScreen  className="login-screen-router-open-in" data-url={url}     lec={lec} >
function create_default_slot_3$2(ctx) {
	let view;
	let current;

	view = new View({
			props: {
				linksView: /*viewSelector*/ ctx[3],
				url: /*url*/ ctx[2],
				ignoreOpenIn: true,
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(view.$$.fragment);
		},
		l(nodes) {
			claim_component(view.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(view, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const view_changes = {};
			if (dirty & /*viewSelector*/ 8) view_changes.linksView = /*viewSelector*/ ctx[3];
			if (dirty & /*url*/ 4) view_changes.url = /*url*/ ctx[2];
			if (dirty & /*lec*/ 1) view_changes.lec = /*lec*/ ctx[0];
			view.$set(view_changes);
		},
		i(local) {
			if (current) return;
			transition_in(view.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(view.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(view, detaching);
		}
	};
}

// (32:0) {#if openIn === 'sheet' }
function create_if_block_2$k(ctx) {
	let sheet;
	let current;

	sheet = new Sheet({
			props: {
				className: "sheet-modal-router-open-in",
				"data-url": /*url*/ ctx[2],
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot_2$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(sheet.$$.fragment);
		},
		l(nodes) {
			claim_component(sheet.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(sheet, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const sheet_changes = {};
			if (dirty & /*url*/ 4) sheet_changes["data-url"] = /*url*/ ctx[2];
			if (dirty & /*lec*/ 1) sheet_changes.lec = /*lec*/ ctx[0];

			if (dirty & /*$$scope, viewSelector, url, lec*/ 269) {
				sheet_changes.$$scope = { dirty, ctx };
			}

			sheet.$set(sheet_changes);
		},
		i(local) {
			if (current) return;
			transition_in(sheet.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(sheet.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(sheet, detaching);
		}
	};
}

// (33:2) <Sheet  className="sheet-modal-router-open-in" data-url={url}     lec={lec} >
function create_default_slot_2$4(ctx) {
	let view;
	let current;

	view = new View({
			props: {
				linksView: /*viewSelector*/ ctx[3],
				url: /*url*/ ctx[2],
				ignoreOpenIn: true,
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(view.$$.fragment);
		},
		l(nodes) {
			claim_component(view.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(view, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const view_changes = {};
			if (dirty & /*viewSelector*/ 8) view_changes.linksView = /*viewSelector*/ ctx[3];
			if (dirty & /*url*/ 4) view_changes.url = /*url*/ ctx[2];
			if (dirty & /*lec*/ 1) view_changes.lec = /*lec*/ ctx[0];
			view.$set(view_changes);
		},
		i(local) {
			if (current) return;
			transition_in(view.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(view.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(view, detaching);
		}
	};
}

// (37:0) {#if openIn === 'popover' }
function create_if_block_1$p(ctx) {
	let popover;
	let current;

	popover = new Popover({
			props: {
				className: "popover-router-open-in",
				targetEl: /*targetEl*/ ctx[4],
				"data-url": /*url*/ ctx[2],
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot_1$5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(popover.$$.fragment);
		},
		l(nodes) {
			claim_component(popover.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(popover, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const popover_changes = {};
			if (dirty & /*targetEl*/ 16) popover_changes.targetEl = /*targetEl*/ ctx[4];
			if (dirty & /*url*/ 4) popover_changes["data-url"] = /*url*/ ctx[2];
			if (dirty & /*lec*/ 1) popover_changes.lec = /*lec*/ ctx[0];

			if (dirty & /*$$scope, viewSelector, url, lec*/ 269) {
				popover_changes.$$scope = { dirty, ctx };
			}

			popover.$set(popover_changes);
		},
		i(local) {
			if (current) return;
			transition_in(popover.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(popover.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(popover, detaching);
		}
	};
}

// (38:2) <Popover  className="popover-router-open-in" {targetEl} data-url={url}     lec={lec} >
function create_default_slot_1$5(ctx) {
	let view;
	let current;

	view = new View({
			props: {
				linksView: /*viewSelector*/ ctx[3],
				url: /*url*/ ctx[2],
				ignoreOpenIn: true,
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(view.$$.fragment);
		},
		l(nodes) {
			claim_component(view.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(view, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const view_changes = {};
			if (dirty & /*viewSelector*/ 8) view_changes.linksView = /*viewSelector*/ ctx[3];
			if (dirty & /*url*/ 4) view_changes.url = /*url*/ ctx[2];
			if (dirty & /*lec*/ 1) view_changes.lec = /*lec*/ ctx[0];
			view.$set(view_changes);
		},
		i(local) {
			if (current) return;
			transition_in(view.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(view.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(view, detaching);
		}
	};
}

// (42:0) {#if openIn.indexOf('panel') === 0 }
function create_if_block$E(ctx) {
	let panel;
	let current;

	panel = new Panel({
			props: {
				side: /*side*/ ctx[5],
				effect: /*effect*/ ctx[6],
				className: "panel-router-open-in",
				"data-url": /*url*/ ctx[2],
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot$9] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(panel.$$.fragment);
		},
		l(nodes) {
			claim_component(panel.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(panel, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const panel_changes = {};
			if (dirty & /*side*/ 32) panel_changes.side = /*side*/ ctx[5];
			if (dirty & /*effect*/ 64) panel_changes.effect = /*effect*/ ctx[6];
			if (dirty & /*url*/ 4) panel_changes["data-url"] = /*url*/ ctx[2];
			if (dirty & /*lec*/ 1) panel_changes.lec = /*lec*/ ctx[0];

			if (dirty & /*$$scope, viewSelector, url, lec*/ 269) {
				panel_changes.$$scope = { dirty, ctx };
			}

			panel.$set(panel_changes);
		},
		i(local) {
			if (current) return;
			transition_in(panel.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(panel.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(panel, detaching);
		}
	};
}

// (43:2) <Panel  {side} {effect} className="panel-router-open-in" data-url={url}     lec={lec} >
function create_default_slot$9(ctx) {
	let view;
	let current;

	view = new View({
			props: {
				linksView: /*viewSelector*/ ctx[3],
				url: /*url*/ ctx[2],
				ignoreOpenIn: true,
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(view.$$.fragment);
		},
		l(nodes) {
			claim_component(view.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(view, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const view_changes = {};
			if (dirty & /*viewSelector*/ 8) view_changes.linksView = /*viewSelector*/ ctx[3];
			if (dirty & /*url*/ 4) view_changes.url = /*url*/ ctx[2];
			if (dirty & /*lec*/ 1) view_changes.lec = /*lec*/ ctx[0];
			view.$set(view_changes);
		},
		i(local) {
			if (current) return;
			transition_in(view.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(view.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(view, detaching);
		}
	};
}

function create_fragment$1u(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let show_if = /*openIn*/ ctx[1].indexOf('panel') === 0;
	let if_block4_anchor;
	let current;
	let if_block0 = /*openIn*/ ctx[1] === 'popup' && create_if_block_4$a(ctx);
	let if_block1 = /*openIn*/ ctx[1] === 'loginScreen' && create_if_block_3$g(ctx);
	let if_block2 = /*openIn*/ ctx[1] === 'sheet' && create_if_block_2$k(ctx);
	let if_block3 = /*openIn*/ ctx[1] === 'popover' && create_if_block_1$p(ctx);
	let if_block4 = show_if && create_if_block$E(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			t3 = space();
			if (if_block4) if_block4.c();
			if_block4_anchor = empty();
		},
		l(nodes) {
			if (if_block0) if_block0.l(nodes);
			t0 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t1 = claim_space(nodes);
			if (if_block2) if_block2.l(nodes);
			t2 = claim_space(nodes);
			if (if_block3) if_block3.l(nodes);
			t3 = claim_space(nodes);
			if (if_block4) if_block4.l(nodes);
			if_block4_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration(target, t1, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_hydration(target, t2, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_hydration(target, t3, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_hydration(target, if_block4_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*openIn*/ ctx[1] === 'popup') {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*openIn*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4$a(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*openIn*/ ctx[1] === 'loginScreen') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*openIn*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3$g(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*openIn*/ ctx[1] === 'sheet') {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*openIn*/ 2) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_2$k(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(t2.parentNode, t2);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*openIn*/ ctx[1] === 'popover') {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty & /*openIn*/ 2) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_1$p(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t3.parentNode, t3);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (dirty & /*openIn*/ 2) show_if = /*openIn*/ ctx[1].indexOf('panel') === 0;

			if (show_if) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty & /*openIn*/ 2) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block$E(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t1);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(t2);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach(t3);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach(if_block4_anchor);
		}
	};
}

let index$1w = 0;

function instance$1l($$self, $$props, $$invalidate) {
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { openIn } = $$props;
	let { url } = $$props;
	let { viewSelector } = $$props;
	let { targetEl } = $$props;
	let { side } = $$props;
	let { effect } = $$props;

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(0, lec = $$props.lec);
		if ('openIn' in $$props) $$invalidate(1, openIn = $$props.openIn);
		if ('url' in $$props) $$invalidate(2, url = $$props.url);
		if ('viewSelector' in $$props) $$invalidate(3, viewSelector = $$props.viewSelector);
		if ('targetEl' in $$props) $$invalidate(4, targetEl = $$props.targetEl);
		if ('side' in $$props) $$invalidate(5, side = $$props.side);
		if ('effect' in $$props) $$invalidate(6, effect = $$props.effect);
	};

	return [lec, openIn, url, viewSelector, targetEl, side, effect];
}

class Router_open_in_component extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1l, create_fragment$1u, safe_not_equal, {
			lec: 0,
			openIn: 1,
			url: 2,
			viewSelector: 3,
			targetEl: 4,
			side: 5,
			effect: 6
		});
	}
}

const routerOpenIn = (router, url, options) => {
  const navigateOptions = {
    url,
    route: {
      path: url,
      options: {
        ...options,
        openIn: undefined,
        props: {
          ...(options.props || {}),
          url,
          openIn: options.openIn,
          viewSelector: router.view.selector
        }
      }
    }
  };
  const params = {
    ...options
  };
  params.component = Router_open_in_component;
  if (options.openIn === 'popup') {
    navigateOptions.route.popup = params;
  }
  if (options.openIn === 'loginScreen') {
    navigateOptions.route.loginScreen = params;
  }
  if (options.openIn === 'sheet') {
    navigateOptions.route.sheet = params;
  }
  if (options.openIn === 'popover') {
    params.targetEl = options.clickedEl || options.targetEl;
    navigateOptions.route.popover = params;
    navigateOptions.route.options.props.targetEl = params.targetEl;
  }
  if (options.openIn.indexOf('panel') >= 0) {
    const parts = options.openIn.split(':');
    navigateOptions.route.options.props.side = parts[1] || 'left';
    navigateOptions.route.options.props.effect = parts[2] || 'cover';
    navigateOptions.route.panel = params;
  }
  return router.navigate(navigateOptions);
};

/* eslint no-underscore-dangle: "off" */
const getChildrenArray = el => {
  const arr = [];
  for (let i = 0; i < el.children.length; i += 1) {
    arr.push(el.children[i]);
  }
  return arr;
};
const hasSameChildren = (childrenBefore, childrenAfter) => {
  if (childrenBefore.length !== childrenAfter.length) return false;
  const set = new Set([...childrenBefore, ...childrenAfter]);
  if (set.size === childrenBefore.length) return true;
  return false;
};
var componentsRouter = {
  proto: {
    openIn(router, navigateUrl, options) {
      return routerOpenIn(router, navigateUrl, options);
    },
    pageComponentLoader(_ref) {
      let {
        routerEl,
        component,
        options,
        resolve,
        reject
      } = _ref;
      const router = this;
      const routerId = router.id;
      const el = routerEl;
      let viewRouter;
      app.f7routers.views.forEach(data => {
        if (data.el && data.el === routerEl || data.routerId && data.routerId === routerId) {
          viewRouter = data;
        }
      });
      if (!viewRouter) {
        reject();
        return;
      }
      const pageData = {
        component,
        id: getComponentId(),
        props: extend({
          f7route: options.route,
          f7router: router
        }, options.route.params, options.props || {})
      };
      let resolved;
      const childrenBefore = getChildrenArray(el);
      function onDidUpdate(componentRouterData) {
        if (componentRouterData !== viewRouter || resolved) return;
        const childrenAfter = getChildrenArray(el);
        if (hasSameChildren(childrenBefore, childrenAfter)) return;
        app.f7events.off('viewRouterDidUpdate', onDidUpdate);
        const pageEl = el.children[el.children.length - 1];
        pageData.el = pageEl;
        resolve(pageEl);
        resolved = true;
      }
      app.f7events.on('viewRouterDidUpdate', onDidUpdate);
      viewRouter.pages.push(pageData);
      viewRouter.setPages(viewRouter.pages);
    },
    removePage($pageEl) {
      if (!$pageEl) return;
      const router = this;
      let f7Page;
      if ('length' in $pageEl && $pageEl[0]) f7Page = $pageEl[0].f7Page;else f7Page = $pageEl.f7Page;
      if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
        router.app.$($pageEl).remove();
        return;
      }
      let viewRouter;
      app.f7routers.views.forEach(data => {
        if (data.el && data.el === router.el) {
          viewRouter = data;
        }
      });
      let pageEl;
      if ('length' in $pageEl) {
        // Dom7
        if ($pageEl.length === 0) return;
        pageEl = $pageEl[0];
      } else {
        pageEl = $pageEl;
      }
      if (!pageEl) return;
      let pageComponentFound;
      viewRouter.pages.forEach((page, index) => {
        if (page.el === pageEl) {
          pageComponentFound = true;
          viewRouter.pages.splice(index, 1);
          viewRouter.setPages(viewRouter.pages);
        }
      });
      if (!pageComponentFound) {
        pageEl.parentNode.removeChild(pageEl);
      }
    },
    tabComponentLoader(_temp) {
      let {
        tabEl,
        component,
        options,
        resolve,
        reject
      } = _temp === void 0 ? {} : _temp;
      const router = this;
      if (!tabEl) reject();
      let tabRouter;
      app.f7routers.tabs.forEach(tabData => {
        if (tabData.el && tabData.el === tabEl) {
          tabRouter = tabData;
        }
      });
      if (!tabRouter) {
        reject();
        return;
      }
      const id = getComponentId();
      const tabContent = {
        id,
        component,
        props: extend({
          f7route: options.route,
          f7router: router
        }, options.route.route && options.route.route.tab && options.route.route.tab.options && options.route.route.tab.options.props || {}, options.route.params, options.props || {})
      };
      let resolved;
      function onDidUpdate(componentRouterData) {
        if (componentRouterData !== tabRouter || resolved) return;
        app.f7events.off('tabRouterDidUpdate', onDidUpdate);
        const tabContentEl = tabEl.children[0];
        resolve(tabContentEl);
        resolved = true;
      }
      app.f7events.on('tabRouterDidUpdate', onDidUpdate);
      tabRouter.setTabContent(tabContent);
    },
    removeTabContent(tabEl) {
      if (!tabEl) return;
      let tabRouter;
      app.f7routers.tabs.forEach(tabData => {
        if (tabData.el && tabData.el === tabEl) {
          tabRouter = tabData;
        }
      });
      if (!tabRouter) {
        tabEl.innerHTML = ''; // eslint-disable-line
        return;
      }
      tabRouter.setTabContent(null);
    },
    modalComponentLoader(_temp2) {
      let {
        component,
        options,
        resolve,
        reject
      } = _temp2 === void 0 ? {} : _temp2;
      const router = this;
      const modalsRouter = app.f7routers.modals;
      if (!modalsRouter) {
        reject();
        return;
      }
      const modalData = {
        component,
        id: getComponentId(),
        props: extend({
          f7route: options.route,
          f7router: router
        }, options.route.params, options.props || {})
      };
      let resolved;
      function onDidUpdate() {
        if (resolved) return;
        app.f7events.off('modalsRouterDidUpdate', onDidUpdate);
        const modalEl = modalsRouter.el.children[modalsRouter.el.children.length - 1];
        modalData.el = modalEl;
        resolve(modalEl);
        resolved = true;
      }
      app.f7events.on('modalsRouterDidUpdate', onDidUpdate);
      modalsRouter.modals.push(modalData);
      modalsRouter.setModals(modalsRouter.modals);
    },
    removeModal(modalEl) {
      const modalsRouter = app.f7routers.modals;
      if (!modalsRouter) return;
      let modalDataToRemove;
      modalsRouter.modals.forEach(modalData => {
        if (modalData.el === modalEl) modalDataToRemove = modalData;
      });
      modalsRouter.modals.splice(modalsRouter.modals.indexOf(modalDataToRemove), 1);
      modalsRouter.setModals(modalsRouter.modals);
    }
  }
};

// eslint-disable-next-line
const Framework7Svelte = {
  name: 'sveltePlugin',
  installed: false,
  install(params) {
    if (params === void 0) {
      params = {};
    }
    const Framework7 = this;
    app.Framework7 = Framework7;
    if (Framework7Svelte.installed) return;
    Framework7Svelte.installed = true;
    f7initEvents();
    const {
      theme: paramsTheme,
      userAgent
    } = params;
    if (paramsTheme === 'md') {
      app.theme.md = true;
      theme$1.md = true;
    }
    if (paramsTheme === 'ios') {
      app.theme.md = true;
      theme$1.ios = true;
    }
    if (paramsTheme === 'aurora') {
      app.theme.md = true;
      theme$1.aurora = true;
    }

    // eslint-disable-next-line
    const needThemeCalc = typeof window === 'undefined' ? !!userAgent : true;
    if (needThemeCalc && (!paramsTheme || paramsTheme === 'auto')) {
      const device = Framework7.getDevice({
        userAgent
      }, true);
      app.theme.ios = !!device.ios;
      theme$1.ios = app.theme.ios;
      app.theme.aurora = device.desktop && device.electron;
      theme$1.aurora = app.theme.aurora;
      app.theme.md = !app.theme.ios && !app.theme.aurora;
      theme$1.md = app.theme.md;
    }
    f7ready(() => {
      setTheme();
    });
    Framework7.Router.use(componentsRouter);
  }
};

// eslint-disable-next-line
const useStore = function () {
  // (store, getter, callback)
  let store = arguments.length <= 0 ? undefined : arguments[0];
  let getter = arguments.length <= 1 ? undefined : arguments[1];
  let callback = arguments.length <= 2 ? undefined : arguments[2];
  if (arguments.length === 1) {
    // (getter)
    store = f7.store;
    getter = arguments.length <= 0 ? undefined : arguments[0];
  } else if (arguments.length === 2 && typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
    // (getter, callback)
    store = f7.store;
    getter = arguments.length <= 0 ? undefined : arguments[0];
    callback = arguments.length <= 1 ? undefined : arguments[1];
  }
  // eslint-disable-next-line
  const obj = store._gettersPlain[getter];
  const value = obj.value;
  if (callback) {
    obj.onUpdated(callback);
  }
  onDestroy(() => {
    if (callback) {
      // eslint-disable-next-line
      store.__removeCallback(callback);
    }
  });
  return value;
};

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/accordion-content.liquivelte generated by Svelte v3.50.0 */

function create_fragment$1t(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$1v = 0;

function instance$1k($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'accordion-item-content', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, $$scope, slots];
}

class Accordion_content extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1k, create_fragment$1t, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/accordion-item.liquivelte generated by Svelte v3.50.0 */

function create_fragment$1s(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	let div_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[8](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[8](null);
		}
	};
}

let index$1u = 0;

function instance$1j($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class","opened"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { opened = undefined } = $$props;
	let el;

	function onBeforeOpen(accEl, prevent) {
		if (accEl !== el) return;
		emit('accordionBeforeOpen', [prevent]);
	}

	function onOpen(accEl) {
		if (accEl !== el) return;
		emit('accordionOpen');
	}

	function onOpened(accEl) {
		if (accEl !== el) return;
		emit('accordionOpened');
	}

	function onBeforeClose(accEl, prevent) {
		if (accEl !== el) return;
		emit('accordionBeforeClose', [prevent]);
	}

	function onClose(accEl) {
		if (accEl !== el) return;
		emit('accordionClose');
	}

	function onClosed(accEl) {
		if (accEl !== el) return;
		emit('accordionClosed');
	}

	onMount(() => {
		f7ready(() => {
			app.f7.on('accordionBeforeOpen', onBeforeOpen);
			app.f7.on('accordionOpen', onOpen);
			app.f7.on('accordionOpened', onOpened);
			app.f7.on('accordionBeforeClose', onBeforeClose);
			app.f7.on('accordionClose', onClose);
			app.f7.on('accordionClosed', onClosed);
		});
	});

	onDestroy(() => {
		if (!app.f7 || !el) return;
		app.f7.off('accordionBeforeOpen', onBeforeOpen);
		app.f7.off('accordionOpen', onOpen);
		app.f7.off('accordionOpened', onOpened);
		app.f7.off('accordionBeforeClose', onBeforeClose);
		app.f7.off('accordionClose', onClose);
		app.f7.off('accordionClosed', onClosed);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(3, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('opened' in $$new_props) $$invalidate(5, opened = $$new_props.opened);
		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(1, classes = classNames(className, 'accordion-item', { 'accordion-item-opened': opened }, colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [el, classes, $$restProps, lec, className, opened, $$scope, slots, div_binding];
}

class Accordion_item extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1j, create_fragment$1s, safe_not_equal, { lec: 3, class: 4, opened: 5 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/accordion-toggle.liquivelte generated by Svelte v3.50.0 */

function create_fragment$1r(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$1t = 0;

function instance$1i($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'accordion-item-toggle', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, $$scope, slots];
}

class Accordion_toggle extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1i, create_fragment$1r, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/accordion.liquivelte generated by Svelte v3.50.0 */

function create_fragment$1q(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$1s = 0;

function instance$1h($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class","accordionOpposite"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let { accordionOpposite = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('accordionOpposite' in $$new_props) $$invalidate(4, accordionOpposite = $$new_props.accordionOpposite);
		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'accordion-list', accordionOpposite && 'accordion-opposite', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, accordionOpposite, $$scope, slots];
}

class Accordion extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1h, create_fragment$1q, safe_not_equal, { lec: 2, class: 3, accordionOpposite: 4 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/actions-button.liquivelte generated by Svelte v3.50.0 */
const get_media_slot_changes$4 = dirty => ({});
const get_media_slot_context$4 = ctx => ({});

// (46:2) {#if hasMediaSlots }
function create_if_block$D(ctx) {
	let div;
	let current;
	const media_slot_template = /*#slots*/ ctx[10].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[9], get_media_slot_context$4);

	return {
		c() {
			div = element("div");
			if (media_slot) media_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (media_slot) media_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "actions-button-media");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (media_slot) {
				if (media_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						media_slot,
						media_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[9], dirty, get_media_slot_changes$4),
						get_media_slot_context$4
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (media_slot) media_slot.d(detaching);
		}
	};
}

function create_fragment$1p(ctx) {
	let div1;
	let t;
	let div0;
	let current;
	let mounted;
	let dispose;
	let if_block = /*hasMediaSlots*/ ctx[2] && create_if_block$D(ctx);
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
	let div1_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[4])];
	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	return {
		c() {
			div1 = element("div");
			if (if_block) if_block.c();
			t = space();
			div0 = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (if_block) if_block.l(div1_nodes);
			t = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (default_slot) default_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "actions-button-text");
			set_attributes(div1, div1_data);
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);
			if (if_block) if_block.m(div1, null);
			append_hydration(div1, t);
			append_hydration(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div1_binding*/ ctx[11](div1);
			current = true;

			if (!mounted) {
				dispose = listen(div1, "click", /*onClick*/ ctx[3]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*hasMediaSlots*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*hasMediaSlots*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$D(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
						null
					);
				}
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 16 && restProps(/*$$restProps*/ ctx[4])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			/*div1_binding*/ ctx[11](null);
			mounted = false;
			dispose();
		}
	};
}

let index$1r = 0;

function instance$1g($$self, $$props, $$invalidate) {
	let hasMediaSlots;
	let classes;
	const omit_props_names = ["lec","class","bold","close"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { bold = false } = $$props;
	let { close = true } = $$props;
	let el;

	function onClick() {
		if (close && app.f7) {
			const dom7 = app.f7.$;
			app.f7.actions.close(dom7(el).parents('.actions-modal'));
		}

		emit('click');
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(5, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('bold' in $$new_props) $$invalidate(7, bold = $$new_props.bold);
		if ('close' in $$new_props) $$invalidate(8, close = $$new_props.close);
		if ('$$scope' in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(1, classes = classNames(
			className,
			{
				'actions-button': true,
				'actions-button-bold': bold
			},
			colorClasses($$props)
		));
	};

	$: $$invalidate(2, hasMediaSlots = $$slots.media);
	$$props = exclude_internal_props($$props);

	return [
		el,
		classes,
		hasMediaSlots,
		onClick,
		$$restProps,
		lec,
		className,
		bold,
		close,
		$$scope,
		slots,
		div1_binding
	];
}

class Actions_button extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1g, create_fragment$1p, safe_not_equal, { lec: 5, class: 6, bold: 7, close: 8 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/actions-group.liquivelte generated by Svelte v3.50.0 */

function create_fragment$1o(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$1q = 0;

function instance$1f($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'actions-group', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, $$scope, slots];
}

class Actions_group extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1f, create_fragment$1o, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/actions-label.liquivelte generated by Svelte v3.50.0 */

function create_fragment$1n(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[2])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div, "click", /*onClick*/ ctx[1]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

let index$1p = 0;

function instance$1e($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class","bold"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { bold = false } = $$props;

	function onClick() {
		emit('click');
	}

	$$self.$$set = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(3, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('bold' in $$new_props) $$invalidate(5, bold = $$new_props.bold);
		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'actions-label', { 'actions-button-bold': bold }, colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, onClick, $$restProps, lec, className, bold, $$scope, slots];
}

class Actions_label extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1e, create_fragment$1n, safe_not_equal, { lec: 3, class: 4, bold: 5 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/actions.liquivelte generated by Svelte v3.50.0 */
const get_default_slot_changes$6 = dirty => ({ actions: dirty[0] & /*f7Actions*/ 2 });
const get_default_slot_context$6 = ctx => ({ actions: /*f7Actions*/ ctx[1] });

function create_fragment$1m(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[20].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], get_default_slot_context$6);
	let div_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[21](div);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope, f7Actions*/ 524290)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[19],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, get_default_slot_changes$6),
						get_default_slot_context$6
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty[0] & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[21](null);
		}
	};
}

let index$1o = 0;

function instance_1$9($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"lec","class","opened","animate","grid","convertToPopover","forceToPopover","target","backdrop","backdropEl","closeByBackdropClick","closeByOutsideClick","closeOnEscape","containerEl","instance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { opened = undefined } = $$props;
	let { animate = undefined } = $$props;
	let { grid = undefined } = $$props;
	let { convertToPopover = undefined } = $$props;
	let { forceToPopover = undefined } = $$props;
	let { target = undefined } = $$props;
	let { backdrop = undefined } = $$props;
	let { backdropEl = undefined } = $$props;
	let { closeByBackdropClick = undefined } = $$props;
	let { closeByOutsideClick = undefined } = $$props;
	let { closeOnEscape = undefined } = $$props;
	let { containerEl = undefined } = $$props;
	let el;
	let f7Actions;
	const state = { isOpened: opened, isClosing: false };

	function instance() {
		return f7Actions;
	}

	function onOpen(instance) {
		Object.assign(state, { isOpened: true, isClosing: false });
		emit('actionsOpen', [instance]);
		$$invalidate(4, opened = true);
	}

	function onOpened(instance) {
		emit('actionsOpened', [instance]);
	}

	function onClose(instance) {
		Object.assign(state, { isOpened: false, isClosing: true });
		emit('actionsClose', [instance]);
	}

	function onClosed(instance) {
		Object.assign(state, { isClosing: false });
		emit('actionsClosed', [instance]);
		$$invalidate(4, opened = false);
	}

	let initialWatched = false;

	function watchOpened(openedPassed) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7Actions) return;
		if (openedPassed) f7Actions.open(); else f7Actions.close();
	}

	onMount(() => {
		const params = {
			el,
			on: {
				open: onOpen,
				opened: onOpened,
				close: onClose,
				closed: onClosed
			}
		};

		if (target) params.targetEl = target;
		if (typeof convertToPopover !== 'undefined') params.convertToPopover = convertToPopover;
		if (typeof forceToPopover !== 'undefined') params.forceToPopover = forceToPopover;
		if (typeof backdrop !== 'undefined') params.backdrop = backdrop;
		if (typeof backdropEl !== 'undefined') params.backdropEl = backdropEl;
		if (typeof closeByBackdropClick !== 'undefined') params.closeByBackdropClick = closeByBackdropClick;
		if (typeof closeByOutsideClick !== 'undefined') params.closeByOutsideClick = closeByOutsideClick;
		if (typeof closeOnEscape !== 'undefined') params.closeOnEscape = closeOnEscape;
		if (typeof animate !== 'undefined') params.animate = animate;
		if (typeof containerEl !== 'undefined') params.containerEl = containerEl;

		f7ready(() => {
			$$invalidate(1, f7Actions = app.f7.actions.create(params));

			if (opened) {
				f7Actions.open(false);
			}
		});
	});

	onDestroy(() => {
		if (f7Actions) f7Actions.destroy();
		$$invalidate(1, f7Actions = null);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(31, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(5, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('opened' in $$new_props) $$invalidate(4, opened = $$new_props.opened);
		if ('animate' in $$new_props) $$invalidate(7, animate = $$new_props.animate);
		if ('grid' in $$new_props) $$invalidate(8, grid = $$new_props.grid);
		if ('convertToPopover' in $$new_props) $$invalidate(9, convertToPopover = $$new_props.convertToPopover);
		if ('forceToPopover' in $$new_props) $$invalidate(10, forceToPopover = $$new_props.forceToPopover);
		if ('target' in $$new_props) $$invalidate(11, target = $$new_props.target);
		if ('backdrop' in $$new_props) $$invalidate(12, backdrop = $$new_props.backdrop);
		if ('backdropEl' in $$new_props) $$invalidate(13, backdropEl = $$new_props.backdropEl);
		if ('closeByBackdropClick' in $$new_props) $$invalidate(14, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ('closeByOutsideClick' in $$new_props) $$invalidate(15, closeByOutsideClick = $$new_props.closeByOutsideClick);
		if ('closeOnEscape' in $$new_props) $$invalidate(16, closeOnEscape = $$new_props.closeOnEscape);
		if ('containerEl' in $$new_props) $$invalidate(17, containerEl = $$new_props.containerEl);
		if ('$$scope' in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(2, classes = classNames(className, 'actions-modal', { 'actions-grid': grid }, modalStateClasses(state), colorClasses($$props)));

		if ($$self.$$.dirty[0] & /*opened*/ 16) {
			$: watchOpened(opened);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		f7Actions,
		classes,
		$$restProps,
		opened,
		lec,
		className,
		animate,
		grid,
		convertToPopover,
		forceToPopover,
		target,
		backdrop,
		backdropEl,
		closeByBackdropClick,
		closeByOutsideClick,
		closeOnEscape,
		containerEl,
		instance,
		$$scope,
		slots,
		div_binding
	];
}

class Actions extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance_1$9,
			create_fragment$1m,
			safe_not_equal,
			{
				lec: 5,
				class: 6,
				opened: 4,
				animate: 7,
				grid: 8,
				convertToPopover: 9,
				forceToPopover: 10,
				target: 11,
				backdrop: 12,
				backdropEl: 13,
				closeByBackdropClick: 14,
				closeByOutsideClick: 15,
				closeOnEscape: 16,
				containerEl: 17,
				instance: 18
			},
			null,
			[-1, -1]
		);
	}

	get instance() {
		return this.$$.ctx[18];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/routable-modals.liquivelte generated by Svelte v3.50.0 */

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

// (38:2) {#each modals as modal (modal.id)}
function create_each_block$3(key_1, ctx) {
	let first;
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*modal*/ ctx[7].props];
	var switch_value = /*modal*/ ctx[7].component;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
			this.h();
		},
		l(nodes) {
			first = empty();
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
			this.h();
		},
		h() {
			this.first = first;
		},
		m(target, anchor) {
			insert_hydration(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_hydration(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			const switch_instance_changes = (dirty & /*modals*/ 1)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*modal*/ ctx[7].props)])
			: {};

			if (switch_value !== (switch_value = /*modal*/ ctx[7].component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

function create_fragment$1l(ctx) {
	let div;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let each_value = /*modals*/ ctx[0];
	const get_key = ctx => /*modal*/ ctx[7].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$3(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "framework7-modals");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			/*div_binding*/ ctx[3](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*modals*/ 1) {
				each_value = /*modals*/ ctx[0];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*div_binding*/ ctx[3](null);
		}
	};
}

let index$1n = 0;

function instance$1d($$self, $$props, $$invalidate) {
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let modals = [];
	let el;
	let routerData;

	onMount(() => {
		routerData = {
			el,
			modals,
			setModals(m) {
				tick().then(() => {
					$$invalidate(0, modals = m);
				});
			}
		};

		app.f7routers.modals = routerData;
	});

	afterUpdate(() => {
		if (!routerData) return;
		app.f7events.emit('modalsRouterDidUpdate', routerData);
	});

	onDestroy(() => {
		if (!routerData) return;
		app.f7routers.modals = null;
		routerData = null;
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(2, lec = $$props.lec);
	};

	return [modals, el, lec, div_binding];
}

class Routable_modals extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1d, create_fragment$1l, safe_not_equal, { lec: 2 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/app.liquivelte generated by Svelte v3.50.0 */

function create_fragment$1k(ctx) {
	let div;
	let t;
	let routablemodals;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	routablemodals = new Routable_modals({ props: { lec: /*lec*/ ctx[0] } });

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			t = space();
			create_component(routablemodals.$$.fragment);
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			t = claim_space(div_nodes);
			claim_component(routablemodals.$$.fragment, div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", /*classes*/ ctx[2]);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_hydration(div, t);
			mount_component(routablemodals, div, null);
			/*div_binding*/ ctx[6](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			const routablemodals_changes = {};
			if (dirty & /*lec*/ 1) routablemodals_changes.lec = /*lec*/ ctx[0];
			routablemodals.$set(routablemodals_changes);

			if (!current || dirty & /*classes*/ 4) {
				attr(div, "class", /*classes*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(routablemodals.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(routablemodals.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			destroy_component(routablemodals);
			/*div_binding*/ ctx[6](null);
		}
	};
}

let index$1m = 0;

function instance$1c($$self, $$props, $$invalidate) {
	let classes;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let el;

	if (!app.f7 || typeof window === 'undefined') {
		f7init(el, noUndefinedProps($$props), false);
	}

	onMount(() => {
		const parentEl = el.parentNode;

		if (parentEl && parentEl !== document.body && parentEl.parentNode === document.body) {
			parentEl.style.height = '100%';
		}

		if (app.f7) {
			app.f7.init(el);
			return;
		}

		f7init(el, noUndefinedProps($$props), true);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('lec' in $$new_props) $$invalidate(0, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(2, classes = classNames(className, 'framework7-root', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [lec, el, classes, className, $$scope, slots, div_binding];
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1c, create_fragment$1k, safe_not_equal, { lec: 0, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/appbar.liquivelte generated by Svelte v3.50.0 */
const get_after_inner_slot_changes$4 = dirty => ({});
const get_after_inner_slot_context$4 = ctx => ({});
const get_before_inner_slot_changes$4 = dirty => ({});
const get_before_inner_slot_context$4 = ctx => ({});

// (38:2) {:else}
function create_else_block$g(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[10],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (34:2) {#if inner }
function create_if_block$C(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", div_class_value = "appbar-inner " + /*innerClasses*/ ctx[1]);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[10],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*innerClasses*/ 2 && div_class_value !== (div_class_value = "appbar-inner " + /*innerClasses*/ ctx[1])) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$1j(ctx) {
	let div;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let div_class_value;
	let current;
	const before_inner_slot_template = /*#slots*/ ctx[11]["before-inner"];
	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[10], get_before_inner_slot_context$4);
	const if_block_creators = [create_if_block$C, create_else_block$g];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*inner*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const after_inner_slot_template = /*#slots*/ ctx[11]["after-inner"];
	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[10], get_after_inner_slot_context$4);

	let div_levels = [
		{
			class: div_class_value = "appbar " + /*classes*/ ctx[2]
		},
		restProps(/*$$restProps*/ ctx[3])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (before_inner_slot) before_inner_slot.c();
			t0 = space();
			if_block.c();
			t1 = space();
			if (after_inner_slot) after_inner_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (before_inner_slot) before_inner_slot.l(div_nodes);
			t0 = claim_space(div_nodes);
			if_block.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (after_inner_slot) after_inner_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (before_inner_slot) {
				before_inner_slot.m(div, null);
			}

			append_hydration(div, t0);
			if_blocks[current_block_type_index].m(div, null);
			append_hydration(div, t1);

			if (after_inner_slot) {
				after_inner_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (before_inner_slot) {
				if (before_inner_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
					update_slot_base(
						before_inner_slot,
						before_inner_slot_template,
						ctx,
						/*$$scope*/ ctx[10],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
						: get_slot_changes(before_inner_slot_template, /*$$scope*/ ctx[10], dirty, get_before_inner_slot_changes$4),
						get_before_inner_slot_context$4
					);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, t1);
			}

			if (after_inner_slot) {
				if (after_inner_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
					update_slot_base(
						after_inner_slot,
						after_inner_slot_template,
						ctx,
						/*$$scope*/ ctx[10],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
						: get_slot_changes(after_inner_slot_template, /*$$scope*/ ctx[10], dirty, get_after_inner_slot_changes$4),
						get_after_inner_slot_context$4
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 4 && div_class_value !== (div_class_value = "appbar " + /*classes*/ ctx[2])) && { class: div_class_value },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(before_inner_slot, local);
			transition_in(if_block);
			transition_in(after_inner_slot, local);
			current = true;
		},
		o(local) {
			transition_out(before_inner_slot, local);
			transition_out(if_block);
			transition_out(after_inner_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (before_inner_slot) before_inner_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (after_inner_slot) after_inner_slot.d(detaching);
		}
	};
}

let index$1l = 0;

function instance$1b($$self, $$props, $$invalidate) {
	let classes;
	let innerClasses;
	const omit_props_names = ["lec","class","noShadow","noHairline","inner","innerClass","innerClassName"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let { noShadow = undefined } = $$props;
	let { noHairline = undefined } = $$props;
	let { inner = true } = $$props;
	let { innerClass = undefined } = $$props;
	let { innerClassName = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(4, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ('noShadow' in $$new_props) $$invalidate(6, noShadow = $$new_props.noShadow);
		if ('noHairline' in $$new_props) $$invalidate(7, noHairline = $$new_props.noHairline);
		if ('inner' in $$new_props) $$invalidate(0, inner = $$new_props.inner);
		if ('innerClass' in $$new_props) $$invalidate(8, innerClass = $$new_props.innerClass);
		if ('innerClassName' in $$new_props) $$invalidate(9, innerClassName = $$new_props.innerClassName);
		if ('$$scope' in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(2, classes = classNames(
			className,
			{
				'no-shadow': noShadow,
				'no-hairline': noHairline
			},
			colorClasses($$props)
		));

		if ($$self.$$.dirty & /*innerClass, innerClassName*/ 768) {
			$: $$invalidate(1, innerClasses = classNames(innerClass, innerClassName));
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		inner,
		innerClasses,
		classes,
		$$restProps,
		lec,
		className,
		noShadow,
		noHairline,
		innerClass,
		innerClassName,
		$$scope,
		slots
	];
}

class Appbar extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1b, create_fragment$1j, safe_not_equal, {
			lec: 4,
			class: 5,
			noShadow: 6,
			noHairline: 7,
			inner: 0,
			innerClass: 8,
			innerClassName: 9
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/area-chart.liquivelte generated by Svelte v3.50.0 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[56] = list[i];
	child_ctx[59] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[59] === 0,
		index: /*index*/ child_ctx[59] + 1,
		index0: /*index*/ child_ctx[59],
		last: /*index*/ child_ctx[59] === /*datasets*/ child_ctx[1].length - 1,
		rindex: /*datasets*/ child_ctx[1].length - /*index*/ child_ctx[59],
		rindex0: /*datasets*/ child_ctx[1].length - /*index*/ child_ctx[59] - 1,
		length: /*datasets*/ child_ctx[1].length
	};

	child_ctx[57] = constants_0;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[60] = list[i];
	child_ctx[59] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[59] === 0,
		index: /*index*/ child_ctx[59] + 1,
		index0: /*index*/ child_ctx[59],
		last: /*index*/ child_ctx[59] === /*axisLabels*/ child_ctx[3].length - 1,
		rindex: /*axisLabels*/ child_ctx[3].length - /*index*/ child_ctx[59],
		rindex0: /*axisLabels*/ child_ctx[3].length - /*index*/ child_ctx[59] - 1,
		length: /*axisLabels*/ child_ctx[3].length
	};

	child_ctx[57] = constants_0;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[62] = list[i];
	child_ctx[59] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[59] === 0,
		index: /*index*/ child_ctx[59] + 1,
		index0: /*index*/ child_ctx[59],
		last: /*index*/ child_ctx[59] === (e in /*verticalLines*/ child_ctx[13]).length - 1,
		rindex: (e in /*verticalLines*/ child_ctx[13]).length - /*index*/ child_ctx[59],
		rindex0: (e in /*verticalLines*/ child_ctx[13]).length - /*index*/ child_ctx[59] - 1,
		length: (e in /*verticalLines*/ child_ctx[13]).length
	};

	child_ctx[57] = constants_0;
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[64] = list[i];
	child_ctx[59] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[59] === 0,
		index: /*index*/ child_ctx[59] + 1,
		index0: /*index*/ child_ctx[59],
		last: /*index*/ child_ctx[59] === /*chartData*/ child_ctx[14].length - 1,
		rindex: /*chartData*/ child_ctx[14].length - /*index*/ child_ctx[59],
		rindex0: /*chartData*/ child_ctx[14].length - /*index*/ child_ctx[59] - 1,
		length: /*chartData*/ child_ctx[14].length
	};

	child_ctx[57] = constants_0;
	return child_ctx;
}

// (319:6) {:else}
function create_else_block_1$5(ctx) {
	let polygon;
	let polygon_fill_value;
	let polygon_points_value;

	return {
		c() {
			polygon = svg_element("polygon");
			this.h();
		},
		l(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { fill: true, fillrule: true, points: true });
			children(polygon).forEach(detach);
			this.h();
		},
		h() {
			attr(polygon, "fill", polygon_fill_value = /*data*/ ctx[64].color);
			attr(polygon, "fillrule", "evenodd");
			attr(polygon, "points", polygon_points_value = /*data*/ ctx[64].points);
		},
		m(target, anchor) {
			insert_hydration(target, polygon, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*chartData*/ 16384 && polygon_fill_value !== (polygon_fill_value = /*data*/ ctx[64].color)) {
				attr(polygon, "fill", polygon_fill_value);
			}

			if (dirty[0] & /*chartData*/ 16384 && polygon_points_value !== (polygon_points_value = /*data*/ ctx[64].points)) {
				attr(polygon, "points", polygon_points_value);
			}
		},
		d(detaching) {
			if (detaching) detach(polygon);
		}
	};
}

// (317:6) {#if lineChart }
function create_if_block_4$9(ctx) {
	let path;
	let path_stroke_value;
	let path_d_value;

	return {
		c() {
			path = svg_element("path");
			this.h();
		},
		l(nodes) {
			path = claim_svg_element(nodes, "path", { stroke: true, fillrule: true, d: true });
			children(path).forEach(detach);
			this.h();
		},
		h() {
			attr(path, "stroke", path_stroke_value = /*data*/ ctx[64].color);
			attr(path, "fillrule", "evenodd");
			attr(path, "d", path_d_value = /*data*/ ctx[64].points);
		},
		m(target, anchor) {
			insert_hydration(target, path, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*chartData*/ 16384 && path_stroke_value !== (path_stroke_value = /*data*/ ctx[64].color)) {
				attr(path, "stroke", path_stroke_value);
			}

			if (dirty[0] & /*chartData*/ 16384 && path_d_value !== (path_d_value = /*data*/ ctx[64].points)) {
				attr(path, "d", path_d_value);
			}
		},
		d(detaching) {
			if (detaching) detach(path);
		}
	};
}

// (307:4) {#each  chartData as data, index  }
function create_each_block_3(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*lineChart*/ ctx[0]) return create_if_block_4$9;
		return create_else_block_1$5;
	}

	let current_block_type = select_block_type(ctx, [-1, -1, -1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (324:4) {#each e in verticalLines as l, index  }
function create_each_block_2(ctx) {
	let line_1;
	let line_1_data_index_value;
	let line_1_y__value;
	let line_1_class_value;

	return {
		c() {
			line_1 = svg_element("line");
			this.h();
		},
		l(nodes) {
			line_1 = claim_svg_element(nodes, "line", {
				"data-index": true,
				fill: true,
				x1: true,
				y1: true,
				x2: true,
				y2: true,
				class: true
			});

			children(line_1).forEach(detach);
			this.h();
		},
		h() {
			attr(line_1, "data-index", line_1_data_index_value = /*index*/ ctx[59]);
			attr(line_1, "fill", "#000");
			attr(line_1, "x1", line);
			attr(line_1, "y1", line_1_y__value = 0);
			attr(line_1, "x2", line);
			attr(line_1, "y2", /*height*/ ctx[7]);

			attr(line_1, "class", line_1_class_value = classNames({
				'area-chart-current-line': /*currentIndex*/ ctx[8] === /*index*/ ctx[59]
			}));
		},
		m(target, anchor) {
			insert_hydration(target, line_1, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*height*/ 128) {
				attr(line_1, "y2", /*height*/ ctx[7]);
			}

			if (dirty[0] & /*currentIndex*/ 256 && line_1_class_value !== (line_1_class_value = classNames({
				'area-chart-current-line': /*currentIndex*/ ctx[8] === /*index*/ ctx[59]
			}))) {
				attr(line_1, "class", line_1_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(line_1);
		}
	};
}

// (345:2) {#if axis }
function create_if_block_2$j(ctx) {
	let div;
	let each_value_1 = /*axisLabels*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "area-chart-axis");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*formatAxisLabel, axisLabels, visibleLegends*/ 135176) {
				each_value_1 = /*axisLabels*/ ctx[3];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (358:10) {#if visibleLegends.includes(label) }
function create_if_block_3$f(ctx) {
	let span;
	let t_value = /*formatAxisLabel*/ ctx[17](/*label*/ ctx[60]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*axisLabels*/ 8 && t_value !== (t_value = /*formatAxisLabel*/ ctx[17](/*label*/ ctx[60]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (347:6) {#each  axisLabels as label, index  }
function create_each_block_1(ctx) {
	let span;
	let show_if = /*visibleLegends*/ ctx[12].includes(/*label*/ ctx[60]);
	let t;
	let if_block = show_if && create_if_block_3$f(ctx);

	return {
		c() {
			span = element("span");
			if (if_block) if_block.c();
			t = space();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			if (if_block) if_block.l(span_nodes);
			t = claim_space(span_nodes);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			if (if_block) if_block.m(span, null);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*visibleLegends, axisLabels*/ 4104) show_if = /*visibleLegends*/ ctx[12].includes(/*label*/ ctx[60]);

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3$f(ctx);
					if_block.c();
					if_block.m(span, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block) if_block.d();
		}
	};
}

// (363:2) {#if legend }
function create_if_block$B(ctx) {
	let div;
	let each_value = /*datasets*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "area-chart-legend");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*hiddenDatasets, toggleDatasets, toggleDataset, formatLegendLabel, datasets*/ 328226) {
				each_value = /*datasets*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (387:8) {:else}
function create_else_block$f(ctx) {
	let span1;
	let span0;
	let span0_style_value;
	let t0;
	let t1_value = /*formatLegendLabel*/ ctx[18](/*dataset*/ ctx[56].label) + "";
	let t1;
	let t2;

	return {
		c() {
			span1 = element("span");
			span0 = element("span");
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			this.h();
		},
		l(nodes) {
			span1 = claim_element(nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			span0 = claim_element(span1_nodes, "SPAN", { style: true });
			children(span0).forEach(detach);
			t0 = claim_space(span1_nodes);
			t1 = claim_text(span1_nodes, t1_value);
			t2 = claim_space(span1_nodes);
			span1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span0, "style", span0_style_value = `background-color: ${/*dataset*/ ctx[56].color}`);
			attr(span1, "class", "area-chart-legend-item");
		},
		m(target, anchor) {
			insert_hydration(target, span1, anchor);
			append_hydration(span1, span0);
			append_hydration(span1, t0);
			append_hydration(span1, t1);
			append_hydration(span1, t2);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*datasets*/ 2 && span0_style_value !== (span0_style_value = `background-color: ${/*dataset*/ ctx[56].color}`)) {
				attr(span0, "style", span0_style_value);
			}

			if (dirty[0] & /*datasets*/ 2 && t1_value !== (t1_value = /*formatLegendLabel*/ ctx[18](/*dataset*/ ctx[56].label) + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(span1);
		}
	};
}

// (375:8) {#if toggleDatasets }
function create_if_block_1$o(ctx) {
	let button;
	let span;
	let span_style_value;
	let t0;
	let t1_value = /*formatLegendLabel*/ ctx[18](/*dataset*/ ctx[56].label) + "";
	let t1;
	let t2;
	let button_class_value;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[33](/*index*/ ctx[59]);
	}

	return {
		c() {
			button = element("button");
			span = element("span");
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true, type: true });
			var button_nodes = children(button);
			span = claim_element(button_nodes, "SPAN", { style: true });
			children(span).forEach(detach);
			t0 = claim_space(button_nodes);
			t1 = claim_text(button_nodes, t1_value);
			t2 = claim_space(button_nodes);
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "style", span_style_value = `background-color: ${/*dataset*/ ctx[56].color}`);

			attr(button, "class", button_class_value = classNames('area-chart-legend-item', {
				'area-chart-legend-item-hidden': /*hiddenDatasets*/ ctx[9].includes(/*index*/ ctx[59]),
				'area-chart-legend-button': /*toggleDatasets*/ ctx[5]
			}));

			attr(button, "type", "button");
		},
		m(target, anchor) {
			insert_hydration(target, button, anchor);
			append_hydration(button, span);
			append_hydration(button, t0);
			append_hydration(button, t1);
			append_hydration(button, t2);

			if (!mounted) {
				dispose = listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*datasets*/ 2 && span_style_value !== (span_style_value = `background-color: ${/*dataset*/ ctx[56].color}`)) {
				attr(span, "style", span_style_value);
			}

			if (dirty[0] & /*datasets*/ 2 && t1_value !== (t1_value = /*formatLegendLabel*/ ctx[18](/*dataset*/ ctx[56].label) + "")) set_data(t1, t1_value);

			if (dirty[0] & /*hiddenDatasets, toggleDatasets*/ 544 && button_class_value !== (button_class_value = classNames('area-chart-legend-item', {
				'area-chart-legend-item-hidden': /*hiddenDatasets*/ ctx[9].includes(/*index*/ ctx[59]),
				'area-chart-legend-button': /*toggleDatasets*/ ctx[5]
			}))) {
				attr(button, "class", button_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (365:6) {#each  datasets as dataset, index  }
function create_each_block$2(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*toggleDatasets*/ ctx[5]) return create_if_block_1$o;
		return create_else_block$f;
	}

	let current_block_type = select_block_type_1(ctx, [-1, -1, -1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$1i(ctx) {
	let div;
	let svg;
	let each0_anchor;
	let svg_viewBox_value;
	let t0;
	let t1;
	let t2;
	let current;
	let each_value_3 = /*chartData*/ ctx[14];
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	let each_value_2 = e in /*verticalLines*/ ctx[13];
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	let if_block0 = /*axis*/ ctx[2] && create_if_block_2$j(ctx);
	let if_block1 = /*legend*/ ctx[4] && create_if_block$B(ctx);
	const default_slot_template = /*#slots*/ ctx[31].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[30], null);
	let div_levels = [{ class: /*classes*/ ctx[15] }, restProps(/*$$restProps*/ ctx[19])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			svg = svg_element("svg");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			each0_anchor = empty();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			svg = claim_svg_element(div_nodes, "svg", {
				xmlns: true,
				width: true,
				height: true,
				viewBox: true,
				preserveAspectRatio: true
			});

			var svg_nodes = children(svg);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].l(svg_nodes);
			}

			each0_anchor = empty();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(svg_nodes);
			}

			svg_nodes.forEach(detach);
			t0 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*width*/ ctx[6]);
			attr(svg, "height", /*height*/ ctx[7]);
			attr(svg, "viewBox", svg_viewBox_value = `0 0 { width } { height }`);
			attr(svg, "preserveAspectRatio", "none");
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, svg);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(svg, null);
			}

			append_hydration(svg, each0_anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(svg, null);
			}

			/*svg_binding*/ ctx[32](svg);
			append_hydration(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[34](div);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*chartData, lineChart*/ 16385) {
				each_value_3 = /*chartData*/ ctx[14];
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_3(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(svg, each0_anchor);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_3.length;
			}

			if (dirty[0] & /*height, currentIndex, verticalLines*/ 8576) {
				each_value_2 = e in /*verticalLines*/ ctx[13];
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(svg, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}

			if (!current || dirty[0] & /*width*/ 64) {
				attr(svg, "width", /*width*/ ctx[6]);
			}

			if (!current || dirty[0] & /*height*/ 128) {
				attr(svg, "height", /*height*/ ctx[7]);
			}

			if (/*axis*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$j(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*legend*/ ctx[4]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$B(ctx);
					if_block1.c();
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 1073741824)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[30],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[30])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[30], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 32768) && { class: /*classes*/ ctx[15] },
				dirty[0] & /*$$restProps*/ 524288 && restProps(/*$$restProps*/ ctx[19])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
			/*svg_binding*/ ctx[32](null);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[34](null);
		}
	};
}

let index$1k = 0;

function instance$1a($$self, $$props, $$invalidate) {
	let classes;
	let chartData;
	let verticalLines;
	let visibleLegends;

	const omit_props_names = [
		"lec","class","lineChart","datasets","axis","axisLabels","tooltip","legend","toggleDatasets","width","height","maxAxisLabels","formatAxisLabel","formatLegendLabel","formatTooltip","formatTooltipAxisLabel","formatTooltipTotal","formatTooltipDataset"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { lineChart = false } = $$props;
	let { datasets = [] } = $$props;
	let { axis = false } = $$props;
	let { axisLabels = [] } = $$props;
	let { tooltip = false } = $$props;
	let { legend = false } = $$props;
	let { toggleDatasets = false } = $$props;
	let { width = 640 } = $$props;
	let { height = 320 } = $$props;
	let { maxAxisLabels = 8 } = $$props;
	let { formatAxisLabel: formatAxisLabelProp = undefined } = $$props;
	let { formatLegendLabel: formatLegendLabelProp = undefined } = $$props;
	let { formatTooltip: formatTooltipProp = undefined } = $$props;
	let { formatTooltipAxisLabel = undefined } = $$props;
	let { formatTooltipTotal = undefined } = $$props;
	let { formatTooltipDataset = undefined } = $$props;
	let el;
	let svgEl = null;
	let currentIndex = null;
	let previousIndex = null;
	let hiddenDatasets = [];
	let f7Tooltip = null;
	let linesOffsets = null;

	const setCurrentIndex = value => {
		previousIndex = currentIndex;
		$$invalidate(8, currentIndex = value);
	};

	const setHiddenDatasets = value => {
		$$invalidate(9, hiddenDatasets = value);
	};

	const getVisibleLegends = () => {
		if (!maxAxisLabels || axisLabels.length <= maxAxisLabels) return axisLabels;
		const skipStep = Math.ceil(axisLabels.length / maxAxisLabels);
		const filtered = axisLabels.filter((label, index) => index % skipStep === 0);
		return filtered;
	};

	const getSummValues = () => {
		const summValues = [];

		datasets.filter((dataset, index) => !hiddenDatasets.includes(index)).forEach(({ values }) => {
			values.forEach((value, valueIndex) => {
				if (!summValues[valueIndex]) summValues[valueIndex] = 0;
				summValues[valueIndex] += value;
			});
		});

		return summValues;
	};

	const getChartData = () => {
		const data = [];

		if (!datasets.length) {
			return data;
		}

		const lastValues = datasets[0].values.map(() => 0);
		let maxValue = 0;

		if (lineChart) {
			datasets.forEach(({ values }) => {
				const datasetMaxValue = Math.max(...values);
				if (datasetMaxValue > maxValue) maxValue = datasetMaxValue;
			});
		} else {
			maxValue = Math.max(...getSummValues());
		}

		datasets.filter((dataset, index) => !hiddenDatasets.includes(index)).forEach(({ label, values, color }) => {
			const points = values.map((originalValue, valueIndex) => {
				lastValues[valueIndex] += originalValue;
				const value = lineChart ? originalValue : lastValues[valueIndex];
				const x = valueIndex / (values.length - 1) * width;
				const y = height - value / maxValue * height;

				if (lineChart) {
					return `${valueIndex === 0 ? 'M' : 'L'}${x},${y}`;
				}

				return `${x} ${y}`;
			});

			if (!lineChart) {
				points.push(`${width} ${height} 0 ${height}`);
			}

			data.push({ label, points: points.join(' '), color });
		});

		return data.reverse();
	};

	const getVerticalLines = () => {
		const lines = [];

		if (!datasets.length) {
			return lines;
		}

		const values = datasets[0].values;

		values.forEach((value, valueIndex) => {
			const x = valueIndex / (values.length - 1) * width;
			lines.push(x);
		});

		return lines;
	};

	const toggleDataset = index => {
		if (!toggleDatasets) return;

		if (hiddenDatasets.includes(index)) {
			hiddenDatasets.splice(hiddenDatasets.indexOf(index), 1);
		} else {
			hiddenDatasets.push(index);
		}

		setHiddenDatasets([...hiddenDatasets]);
	};

	const formatAxisLabel = label => {
		if (formatAxisLabelProp) return formatAxisLabelProp(label);
		return label;
	};

	const formatLegendLabel = label => {
		if (formatLegendLabelProp) return formatLegendLabelProp(label);
		return label;
	};

	const calcLinesOffsets = () => {
		const lines = svgEl.querySelectorAll('line');
		linesOffsets = [];

		for (let i = 0; i < lines.length; i += 1) {
			linesOffsets.push(lines[i].getBoundingClientRect().left);
		}
	};

	const formatTooltip = () => {
		if (currentIndex === null) return '';
		let total = 0;

		const currentValues = datasets.filter((dataset, index) => !hiddenDatasets.includes(index)).map(dataset => ({
			color: dataset.color,
			label: dataset.label,
			value: dataset.values[currentIndex]
		}));

		currentValues.forEach(dataset => {
			total += dataset.value;
		});

		if (formatTooltipProp) {
			return formatTooltipProp({
				index: currentIndex,
				total,
				datasets: currentValues
			});
		}

		let labelText = formatTooltipAxisLabel
		? formatTooltipAxisLabel(axisLabels[currentIndex])
		: formatAxisLabel(axisLabels[currentIndex]);

		if (!labelText) labelText = '';
		const totalText = formatTooltipTotal ? formatTooltipTotal(total) : total;

		// prettier-ignore
		const datasetsText = currentValues.length > 0
		? `
      <ul class="area-chart-tooltip-list">
        ${currentValues.map(({ label, color, value }) => {
				const valueText = formatTooltipDataset
				? formatTooltipDataset(label, value, color)
				: `${label}: ${value}`;

				return `
              <li><span style="background-color: ${color};"></span>${valueText}</li>
            `;
			}).join('')}
      </ul>`
		: '';

		// prettier-ignore
		return `
      <div class="area-chart-tooltip-label">${labelText}</div>
      <div class="area-chart-tooltip-total">${totalText}</div>
      ${datasetsText}
    `;
	};

	const setTooltip = () => {
		if (!tooltip) return;
		if (currentIndex === null && !f7Tooltip) return;
		const hasVisibleDataSets = datasets.filter((dataset, index) => !hiddenDatasets.includes(index)).length > 0;

		if (!hasVisibleDataSets) {
			if (f7Tooltip && f7Tooltip.hide) f7Tooltip.hide();
			return;
		}

		if (currentIndex !== null && !f7Tooltip) {
			f7Tooltip = app.f7.tooltip.create({
				trigger: 'manual',
				containerEl: el,
				targetEl: svgEl.querySelector(`line[data-index="${currentIndex}"]`),
				text: formatTooltip(),
				cssClass: 'area-chart-tooltip'
			});

			if (f7Tooltip && f7Tooltip.show) {
				f7Tooltip.show();
			}

			return;
		}

		if (!f7Tooltip || !f7Tooltip.hide || !f7Tooltip.show) {
			return;
		}

		if (currentIndex !== null) {
			f7Tooltip.setText(formatTooltip());
			f7Tooltip.setTargetEl(svgEl.querySelector(`line[data-index="${currentIndex}"]`));
			f7Tooltip.show();
		} else {
			f7Tooltip.hide();
		}
	};

	const onMouseEnter = () => {
		calcLinesOffsets();
	};

	const onMouseMove = e => {
		if (!linesOffsets) {
			calcLinesOffsets();
		}

		let currentLeft = e.pageX;
		if (typeof currentLeft === 'undefined') currentLeft = 0;
		const distances = linesOffsets.map(left => Math.abs(currentLeft - left));
		const minDistance = Math.min(...distances);
		const closestIndex = distances.indexOf(minDistance);
		setCurrentIndex(closestIndex);
	};

	const onMouseLeave = () => {
		setCurrentIndex(null);
	};

	const attachEvents = () => {
		if (!svgEl) return;
		svgEl.addEventListener('mouseenter', onMouseEnter);
		svgEl.addEventListener('mousemove', onMouseMove);
		svgEl.addEventListener('mouseleave', onMouseLeave);
	};

	const detachEvents = () => {
		if (!svgEl) return;
		svgEl.removeEventListener('mouseenter', onMouseEnter);
		svgEl.removeEventListener('mousemove', onMouseMove);
		svgEl.removeEventListener('mouseleave', onMouseLeave);
	};

	onMount(() => {
		attachEvents();
	});

	onDestroy(() => {
		detachEvents();

		if (f7Tooltip && f7Tooltip.destroy) {
			f7Tooltip.destroy();
		}

		f7Tooltip = null;
	});

	const watchCurrentIndex = () => {
		if (currentIndex === previousIndex) return;
		emit('select', [currentIndex]);
		setTooltip();
	};

	function svg_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			svgEl = $$value;
			$$invalidate(11, svgEl);
		});
	}

	const click_handler = index => toggleDataset(index);

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(10, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(55, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(20, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(21, className = $$new_props.class);
		if ('lineChart' in $$new_props) $$invalidate(0, lineChart = $$new_props.lineChart);
		if ('datasets' in $$new_props) $$invalidate(1, datasets = $$new_props.datasets);
		if ('axis' in $$new_props) $$invalidate(2, axis = $$new_props.axis);
		if ('axisLabels' in $$new_props) $$invalidate(3, axisLabels = $$new_props.axisLabels);
		if ('tooltip' in $$new_props) $$invalidate(22, tooltip = $$new_props.tooltip);
		if ('legend' in $$new_props) $$invalidate(4, legend = $$new_props.legend);
		if ('toggleDatasets' in $$new_props) $$invalidate(5, toggleDatasets = $$new_props.toggleDatasets);
		if ('width' in $$new_props) $$invalidate(6, width = $$new_props.width);
		if ('height' in $$new_props) $$invalidate(7, height = $$new_props.height);
		if ('maxAxisLabels' in $$new_props) $$invalidate(23, maxAxisLabels = $$new_props.maxAxisLabels);
		if ('formatAxisLabel' in $$new_props) $$invalidate(24, formatAxisLabelProp = $$new_props.formatAxisLabel);
		if ('formatLegendLabel' in $$new_props) $$invalidate(25, formatLegendLabelProp = $$new_props.formatLegendLabel);
		if ('formatTooltip' in $$new_props) $$invalidate(26, formatTooltipProp = $$new_props.formatTooltip);
		if ('formatTooltipAxisLabel' in $$new_props) $$invalidate(27, formatTooltipAxisLabel = $$new_props.formatTooltipAxisLabel);
		if ('formatTooltipTotal' in $$new_props) $$invalidate(28, formatTooltipTotal = $$new_props.formatTooltipTotal);
		if ('formatTooltipDataset' in $$new_props) $$invalidate(29, formatTooltipDataset = $$new_props.formatTooltipDataset);
		if ('$$scope' in $$new_props) $$invalidate(30, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*currentIndex*/ 256) {
			$: watchCurrentIndex(currentIndex);
		}

		if ($$self.$$.dirty[0] & /*className*/ 2097152) {
			$: $$invalidate(15, classes = classNames('area-chart', className));
		}

		if ($$self.$$.dirty[0] & /*datasets, hiddenDatasets*/ 514) {
			$: $$invalidate(14, chartData = getChartData(datasets, hiddenDatasets));
		}

		if ($$self.$$.dirty[0] & /*datasets*/ 2) {
			$: $$invalidate(13, verticalLines = getVerticalLines(datasets));
		}

		if ($$self.$$.dirty[0] & /*maxAxisLabels, axisLabels*/ 8388616) {
			$: $$invalidate(12, visibleLegends = getVisibleLegends(maxAxisLabels, axisLabels));
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		lineChart,
		datasets,
		axis,
		axisLabels,
		legend,
		toggleDatasets,
		width,
		height,
		currentIndex,
		hiddenDatasets,
		el,
		svgEl,
		visibleLegends,
		verticalLines,
		chartData,
		classes,
		toggleDataset,
		formatAxisLabel,
		formatLegendLabel,
		$$restProps,
		lec,
		className,
		tooltip,
		maxAxisLabels,
		formatAxisLabelProp,
		formatLegendLabelProp,
		formatTooltipProp,
		formatTooltipAxisLabel,
		formatTooltipTotal,
		formatTooltipDataset,
		$$scope,
		slots,
		svg_binding,
		click_handler,
		div_binding
	];
}

class Area_chart extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$1a,
			create_fragment$1i,
			safe_not_equal,
			{
				lec: 20,
				class: 21,
				lineChart: 0,
				datasets: 1,
				axis: 2,
				axisLabels: 3,
				tooltip: 22,
				legend: 4,
				toggleDatasets: 5,
				width: 6,
				height: 7,
				maxAxisLabels: 23,
				formatAxisLabel: 24,
				formatLegendLabel: 25,
				formatTooltip: 26,
				formatTooltipAxisLabel: 27,
				formatTooltipTotal: 28,
				formatTooltipDataset: 29
			},
			null,
			[-1, -1, -1]
		);
	}
}

const useTooltip = (el, props) => {
  let f7Tooltip = null;
  const {
    tooltip,
    tooltipTrigger
  } = props;
  if (el && tooltip) {
    f7ready(() => {
      f7Tooltip = app.f7.tooltip.create({
        targetEl: el,
        text: tooltip,
        trigger: tooltipTrigger
      });
    });
  }
  return {
    update(_temp) {
      let {
        tooltip: value
      } = _temp === void 0 ? {} : _temp;
      if (!value && f7Tooltip) {
        f7Tooltip.destroy();
        f7Tooltip = null;
        return;
      }
      if (value && !f7Tooltip && app.f7) {
        f7Tooltip = app.f7.tooltip.create({
          targetEl: el,
          text: value,
          trigger: tooltipTrigger
        });
        return;
      }
      if (!value || !f7Tooltip) return;
      f7Tooltip.setText(value);
    },
    destroy() {
      if (f7Tooltip && f7Tooltip.destroy) {
        f7Tooltip.destroy();
        f7Tooltip = null;
      }
    }
  };
};

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/badge.liquivelte generated by Svelte v3.50.0 */

function create_fragment$1h(ctx) {
	let span;
	let span_class_value;
	let useTooltip_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	let span_levels = [
		{
			class: span_class_value = "badge " + /*classes*/ ctx[2]
		},
		restProps(/*$$restProps*/ ctx[3])
	];

	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	return {
		c() {
			span = element("span");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			if (default_slot) default_slot.l(span_nodes);
			span_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(span, span_data);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;

			if (!mounted) {
				dispose = action_destroyer(useTooltip_action = useTooltip.call(null, span, {
					tooltip: /*tooltip*/ ctx[0],
					tooltipTrigger: /*tooltipTrigger*/ ctx[1]
				}));

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				(!current || dirty & /*classes*/ 4 && span_class_value !== (span_class_value = "badge " + /*classes*/ ctx[2])) && { class: span_class_value },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));

			if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/ 3) useTooltip_action.update.call(null, {
				tooltip: /*tooltip*/ ctx[0],
				tooltipTrigger: /*tooltipTrigger*/ ctx[1]
			});
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

let index$1j = 0;

function instance$19($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class","tooltip","tooltipTrigger"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(4, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ('tooltip' in $$new_props) $$invalidate(0, tooltip = $$new_props.tooltip);
		if ('tooltipTrigger' in $$new_props) $$invalidate(1, tooltipTrigger = $$new_props.tooltipTrigger);
		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(2, classes = classNames(className, colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [tooltip, tooltipTrigger, classes, $$restProps, lec, className, $$scope, slots];
}

class Badge extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$19, create_fragment$1h, safe_not_equal, {
			lec: 4,
			class: 5,
			tooltip: 0,
			tooltipTrigger: 1
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/block-footer.liquivelte generated by Svelte v3.50.0 */

function create_fragment$1g(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$1i = 0;

function instance$18($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'block-footer', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, $$scope, slots];
}

class Block_footer extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$18, create_fragment$1g, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/block-header.liquivelte generated by Svelte v3.50.0 */

function create_fragment$1f(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$1h = 0;

function instance$17($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'block-header', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, $$scope, slots];
}

class Block_header extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$17, create_fragment$1f, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/block-title.liquivelte generated by Svelte v3.50.0 */

function create_fragment$1e(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$1g = 0;

function instance$16($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","large","medium","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { large = false } = $$props;
	let { medium = false } = $$props;
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('large' in $$new_props) $$invalidate(3, large = $$new_props.large);
		if ('medium' in $$new_props) $$invalidate(4, medium = $$new_props.medium);
		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(
			className,
			'block-title',
			{
				'block-title-large': large,
				'block-title-medium': medium
			},
			colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, large, medium, className, $$scope, slots];
}

class Block_title extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$16, create_fragment$1e, safe_not_equal, { lec: 2, large: 3, medium: 4, class: 5 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/block.liquivelte generated by Svelte v3.50.0 */

function create_fragment$1d(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[22].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);
	let div_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[23](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[21],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[21])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[21], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[23](null);
		}
	};
}

let index$1f = 0;

function instance$15($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"lec","inset","xsmallInset","smallInset","mediumInset","largeInset","xlargeInset","strong","tabs","tab","tabActive","accordionList","accordionOpposite","noHairlines","noHairlinesMd","noHairlinesIos","noHairlinesAurora","class"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { inset = false } = $$props;
	let { xsmallInset = false } = $$props;
	let { smallInset = false } = $$props;
	let { mediumInset = false } = $$props;
	let { largeInset = false } = $$props;
	let { xlargeInset = false } = $$props;
	let { strong = false } = $$props;
	let { tabs = false } = $$props;
	let { tab = false } = $$props;
	let { tabActive = false } = $$props;
	let { accordionList = false } = $$props;
	let { accordionOpposite = false } = $$props;
	let { noHairlines = false } = $$props;
	let { noHairlinesMd = false } = $$props;
	let { noHairlinesIos = false } = $$props;
	let { noHairlinesAurora = false } = $$props;
	let { class: className = undefined } = $$props;
	let el;
	useTab(() => el, emit);

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(26, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(3, lec = $$new_props.lec);
		if ('inset' in $$new_props) $$invalidate(4, inset = $$new_props.inset);
		if ('xsmallInset' in $$new_props) $$invalidate(5, xsmallInset = $$new_props.xsmallInset);
		if ('smallInset' in $$new_props) $$invalidate(6, smallInset = $$new_props.smallInset);
		if ('mediumInset' in $$new_props) $$invalidate(7, mediumInset = $$new_props.mediumInset);
		if ('largeInset' in $$new_props) $$invalidate(8, largeInset = $$new_props.largeInset);
		if ('xlargeInset' in $$new_props) $$invalidate(9, xlargeInset = $$new_props.xlargeInset);
		if ('strong' in $$new_props) $$invalidate(10, strong = $$new_props.strong);
		if ('tabs' in $$new_props) $$invalidate(11, tabs = $$new_props.tabs);
		if ('tab' in $$new_props) $$invalidate(12, tab = $$new_props.tab);
		if ('tabActive' in $$new_props) $$invalidate(13, tabActive = $$new_props.tabActive);
		if ('accordionList' in $$new_props) $$invalidate(14, accordionList = $$new_props.accordionList);
		if ('accordionOpposite' in $$new_props) $$invalidate(15, accordionOpposite = $$new_props.accordionOpposite);
		if ('noHairlines' in $$new_props) $$invalidate(16, noHairlines = $$new_props.noHairlines);
		if ('noHairlinesMd' in $$new_props) $$invalidate(17, noHairlinesMd = $$new_props.noHairlinesMd);
		if ('noHairlinesIos' in $$new_props) $$invalidate(18, noHairlinesIos = $$new_props.noHairlinesIos);
		if ('noHairlinesAurora' in $$new_props) $$invalidate(19, noHairlinesAurora = $$new_props.noHairlinesAurora);
		if ('class' in $$new_props) $$invalidate(20, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(21, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(1, classes = classNames(
			className,
			'block',
			{
				inset,
				'xsmall-inset': xsmallInset,
				'small-inset': smallInset,
				'medium-inset': mediumInset,
				'large-inset': largeInset,
				'xlarge-inset': xlargeInset,
				'block-strong': strong,
				'accordion-list': accordionList,
				'accordion-opposite': accordionOpposite,
				tabs,
				tab,
				'tab-active': tabActive,
				'no-hairlines': noHairlines,
				'no-hairlines-md': noHairlinesMd,
				'no-hairlines-ios': noHairlinesIos,
				'no-hairlines-aurora': noHairlinesAurora
			},
			colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		classes,
		$$restProps,
		lec,
		inset,
		xsmallInset,
		smallInset,
		mediumInset,
		largeInset,
		xlargeInset,
		strong,
		tabs,
		tab,
		tabActive,
		accordionList,
		accordionOpposite,
		noHairlines,
		noHairlinesMd,
		noHairlinesIos,
		noHairlinesAurora,
		className,
		$$scope,
		slots,
		div_binding
	];
}

class Block extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$15, create_fragment$1d, safe_not_equal, {
			lec: 3,
			inset: 4,
			xsmallInset: 5,
			smallInset: 6,
			mediumInset: 7,
			largeInset: 8,
			xlargeInset: 9,
			strong: 10,
			tabs: 11,
			tab: 12,
			tabActive: 13,
			accordionList: 14,
			accordionOpposite: 15,
			noHairlines: 16,
			noHairlinesMd: 17,
			noHairlinesIos: 18,
			noHairlinesAurora: 19,
			class: 20
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/breadcrumbs-collapsed.liquivelte generated by Svelte v3.50.0 */

function create_fragment$1c(ctx) {
	let div;
	let span;
	let t;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[2])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			span = element("span");
			t = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			span = claim_element(div_nodes, "SPAN", {});
			children(span).forEach(detach);
			t = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, span);
			append_hydration(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div, "click", /*onClick*/ ctx[1]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

let index$1e = 0;

function instance$14($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	const emit = createEmitter(createEventDispatcher, $$props);

	function onClick() {
		emit('click');
	}

	$$self.$$set = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(3, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 16) {
			$: $$invalidate(0, classes = classNames(className, 'breadcrumbs-collapsed'));
		}
	};

	$$props = exclude_internal_props($$props);
	return [classes, onClick, $$restProps, lec, className, $$scope, slots];
}

class Breadcrumbs_collapsed extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$14, create_fragment$1c, safe_not_equal, { lec: 3, class: 4 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/breadcrumbs-item.liquivelte generated by Svelte v3.50.0 */

function create_fragment$1b(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$1d = 0;

function instance$13($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","active","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { active = false } = $$props;
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('active' in $$new_props) $$invalidate(3, active = $$new_props.active);
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, active*/ 24) {
			$: $$invalidate(0, classes = classNames(className, 'breadcrumbs-item', active && 'breadcrumbs-item-active'));
		}
	};

	return [classes, $$restProps, lec, active, className, $$scope, slots];
}

class Breadcrumbs_item extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$13, create_fragment$1b, safe_not_equal, { lec: 2, active: 3, class: 4 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/breadcrumbs-separator.liquivelte generated by Svelte v3.50.0 */

function create_fragment$1a(ctx) {
	let div;
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
		},
		p(ctx, [dirty]) {
			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*classes*/ 1 && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

let index$1c = 0;

function instance$12($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 8) {
			$: $$invalidate(0, classes = classNames(className, 'breadcrumbs-separator'));
		}
	};

	return [classes, $$restProps, lec, className];
}

class Breadcrumbs_separator extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$12, create_fragment$1a, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/breadcrumbs.liquivelte generated by Svelte v3.50.0 */

function create_fragment$19(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$1b = 0;

function instance$11($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 8) {
			$: $$invalidate(0, classes = classNames(className, 'breadcrumbs'));
		}
	};

	return [classes, $$restProps, lec, className, $$scope, slots];
}

class Breadcrumbs extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$11, create_fragment$19, safe_not_equal, { lec: 2, class: 3 });
	}
}

const useRouteProps = (el, routeProps) => {
  if (el && routeProps) {
    el.f7RouteProps = routeProps;
  }
  return {
    update(newValue) {
      if (el && el.f7RouteProps && !newValue) delete el.f7RouteProps;else if (el && newValue) el.f7RouteProps = newValue;
    },
    destroy() {
      if (el && routeProps) {
        delete el.f7RouteProps;
      }
    }
  };
};

const useIcon = function (props) {
  if (props === void 0) {
    props = {};
  }
  const {
    icon,
    iconMaterial,
    iconF7,
    iconMd,
    iconIos,
    iconAurora,
    iconColor,
    iconSize,
    iconBadge,
    badgeColor,
    iconBadgeColor
  } = props;
  if (icon || iconMaterial || iconF7 || iconMd || iconIos || iconAurora) {
    return {
      props: {
        material: iconMaterial,
        f7: iconF7,
        icon,
        md: iconMd,
        ios: iconIos,
        aurora: iconAurora,
        color: iconColor,
        size: iconSize
      },
      badge: iconBadge || iconBadge === 0 ? {
        props: {
          color: badgeColor || iconBadgeColor
        },
        content: iconBadge
      } : null
    };
  }
  return null;
};

const useTheme = set => {
  const t = app.f7 ? app.theme : null;
  if (!app.f7) {
    f7ready(() => {
      set(app.theme);
    });
  }
  return t;
};

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/icon.liquivelte generated by Svelte v3.50.0 */

function create_fragment$18(ctx) {
	let i;
	let t0_value = (/*iconText*/ ctx[4] || '') + "";
	let t0;
	let t1;
	let useTooltip_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[22].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);

	let i_levels = [
		{ style: /*iconStyle*/ ctx[3] },
		{ class: /*iconClasses*/ ctx[5] },
		restProps(/*$$restProps*/ ctx[6])
	];

	let i_data = {};

	for (let i = 0; i < i_levels.length; i += 1) {
		i_data = assign(i_data, i_levels[i]);
	}

	return {
		c() {
			i = element("i");
			t0 = text(t0_value);
			t1 = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			i = claim_element(nodes, "I", { style: true, class: true });
			var i_nodes = children(i);
			t0 = claim_text(i_nodes, t0_value);
			t1 = claim_space(i_nodes);
			if (default_slot) default_slot.l(i_nodes);
			i_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(i, i_data);
		},
		m(target, anchor) {
			insert_hydration(target, i, anchor);
			append_hydration(i, t0);
			append_hydration(i, t1);

			if (default_slot) {
				default_slot.m(i, null);
			}

			/*i_binding*/ ctx[23](i);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(useTooltip_action = useTooltip.call(null, i, {
					tooltip: /*tooltip*/ ctx[0],
					tooltipTrigger: /*tooltipTrigger*/ ctx[1]
				}));

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*iconText*/ 16) && t0_value !== (t0_value = (/*iconText*/ ctx[4] || '') + "")) set_data(t0, t0_value);

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[21],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[21])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[21], dirty, null),
						null
					);
				}
			}

			set_attributes(i, i_data = get_spread_update(i_levels, [
				(!current || dirty & /*iconStyle*/ 8) && { style: /*iconStyle*/ ctx[3] },
				(!current || dirty & /*iconClasses*/ 32) && { class: /*iconClasses*/ ctx[5] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));

			if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/ 3) useTooltip_action.update.call(null, {
				tooltip: /*tooltip*/ ctx[0],
				tooltipTrigger: /*tooltipTrigger*/ ctx[1]
			});
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(i);
			if (default_slot) default_slot.d(detaching);
			/*i_binding*/ ctx[23](null);
			mounted = false;
			dispose();
		}
	};
}

let index$1a = 0;

function instance$10($$self, $$props, $$invalidate) {
	let iconClasses;
	let iconText;
	let iconSize;
	let iconStyle;

	const omit_props_names = [
		"lec","style","class","material","f7","icon","ios","aurora","md","tooltip","tooltipTrigger","size"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { style = undefined } = $$props;
	let { class: className = undefined } = $$props;
	let { material = undefined } = $$props;
	let { f7 = undefined } = $$props;
	let { icon = undefined } = $$props;
	let { ios = undefined } = $$props;
	let { aurora = undefined } = $$props;
	let { md = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let { size = undefined } = $$props;
	let el;

	let theme = useTheme(t => {
		$$invalidate(17, theme = t);
	});

	let classes = { icon: true };
	let themeIcon;

	function iconTextComputed(t) {
		let textComputed = material || f7;

		if (md && t && t.md && (md.indexOf('material:') >= 0 || md.indexOf('f7:') >= 0)) {
			textComputed = md.split(':')[1];
		} else if (ios && t && t.ios && (ios.indexOf('material:') >= 0 || ios.indexOf('f7:') >= 0)) {
			textComputed = ios.split(':')[1];
		} else if (aurora && t && t.aurora && (aurora.indexOf('material:') >= 0 || aurora.indexOf('f7:') >= 0)) {
			textComputed = aurora.split(':')[1];
		}

		return textComputed;
	}

	function i_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(26, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(7, lec = $$new_props.lec);
		if ('style' in $$new_props) $$invalidate(8, style = $$new_props.style);
		if ('class' in $$new_props) $$invalidate(9, className = $$new_props.class);
		if ('material' in $$new_props) $$invalidate(10, material = $$new_props.material);
		if ('f7' in $$new_props) $$invalidate(11, f7 = $$new_props.f7);
		if ('icon' in $$new_props) $$invalidate(12, icon = $$new_props.icon);
		if ('ios' in $$new_props) $$invalidate(13, ios = $$new_props.ios);
		if ('aurora' in $$new_props) $$invalidate(14, aurora = $$new_props.aurora);
		if ('md' in $$new_props) $$invalidate(15, md = $$new_props.md);
		if ('tooltip' in $$new_props) $$invalidate(0, tooltip = $$new_props.tooltip);
		if ('tooltipTrigger' in $$new_props) $$invalidate(1, tooltipTrigger = $$new_props.tooltipTrigger);
		if ('size' in $$new_props) $$invalidate(16, size = $$new_props.size);
		if ('$$scope' in $$new_props) $$invalidate(21, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*theme, ios, md, aurora*/ 188416) {
			$: if (theme) {
				if (theme.ios) $$invalidate(19, themeIcon = ios);
				if (theme.md) $$invalidate(19, themeIcon = md);
				if (theme.aurora) $$invalidate(19, themeIcon = aurora);
			}
		}

		if ($$self.$$.dirty & /*themeIcon, material, f7, icon*/ 531456) {
			$: if (themeIcon) {
				const parts = themeIcon.split(':');
				const prop = parts[0];
				const value = parts[1];

				if (prop === 'material' || prop === 'f7') {
					$$invalidate(18, classes['material-icons'] = prop === 'material', classes);
					$$invalidate(18, classes['f7-icons'] = prop === 'f7', classes);
				}

				if (prop === 'icon') {
					$$invalidate(18, classes[value] = true, classes);
				}
			} else {
				$$invalidate(18, classes = {
					icon: true,
					'material-icons': material,
					'f7-icons': f7
				});

				if (icon) $$invalidate(18, classes[icon] = true, classes);
			}
		}

		$: $$invalidate(5, iconClasses = classNames(className, classes, colorClasses($$props)));

		if ($$self.$$.dirty & /*theme*/ 131072) {
			$: $$invalidate(4, iconText = iconTextComputed(theme));
		}

		if ($$self.$$.dirty & /*size*/ 65536) {
			$: $$invalidate(20, iconSize = typeof size === 'number' || parseFloat(size) === size * 1
			? `${size}px`
			: size);
		}

		if ($$self.$$.dirty & /*style, iconSize*/ 1048832) {
			$: $$invalidate(3, iconStyle = (style || '') + (iconSize
			? `;font-size: ${iconSize}; width: ${iconSize}; height: ${iconSize}`.replace(';;', '')
			: ''));
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		tooltip,
		tooltipTrigger,
		el,
		iconStyle,
		iconText,
		iconClasses,
		$$restProps,
		lec,
		style,
		className,
		material,
		f7,
		icon,
		ios,
		aurora,
		md,
		size,
		theme,
		classes,
		themeIcon,
		iconSize,
		$$scope,
		slots,
		i_binding
	];
}

class Icon extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$10, create_fragment$18, safe_not_equal, {
			lec: 7,
			style: 8,
			class: 9,
			material: 10,
			f7: 11,
			icon: 12,
			ios: 13,
			aurora: 14,
			md: 15,
			tooltip: 0,
			tooltipTrigger: 1,
			size: 16
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/use-icon.liquivelte generated by Svelte v3.50.0 */

function create_if_block$A(ctx) {
	let badge;
	let current;
	const badge_spread_levels = [/*icon*/ ctx[1].badge.props, { lec: /*lec*/ ctx[0] }];

	let badge_props = {
		$$slots: { default: [create_default_slot_1$4] },
		$$scope: { ctx }
	};

	for (let i = 0; i < badge_spread_levels.length; i += 1) {
		badge_props = assign(badge_props, badge_spread_levels[i]);
	}

	badge = new Badge({ props: badge_props });

	return {
		c() {
			create_component(badge.$$.fragment);
		},
		l(nodes) {
			claim_component(badge.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(badge, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const badge_changes = (dirty & /*icon, lec*/ 3)
			? get_spread_update(badge_spread_levels, [
					dirty & /*icon*/ 2 && get_spread_object(/*icon*/ ctx[1].badge.props),
					dirty & /*lec*/ 1 && { lec: /*lec*/ ctx[0] }
				])
			: {};

			if (dirty & /*$$scope, icon*/ 10) {
				badge_changes.$$scope = { dirty, ctx };
			}

			badge.$set(badge_changes);
		},
		i(local) {
			if (current) return;
			transition_in(badge.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(badge.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(badge, detaching);
		}
	};
}

// (15:4) <Badge  {...icon.badge.props}     lec={lec} >
function create_default_slot_1$4(ctx) {
	let t_value = /*icon*/ ctx[1].badge.content + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 2 && t_value !== (t_value = /*icon*/ ctx[1].badge.content + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (13:0) <Icon  {...icon.props}     lec={lec} >
function create_default_slot$8(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*icon*/ ctx[1].badge && create_if_block$A(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[1].badge) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*icon*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$A(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$17(ctx) {
	let icon_1;
	let current;
	const icon_1_spread_levels = [/*icon*/ ctx[1].props, { lec: /*lec*/ ctx[0] }];

	let icon_1_props = {
		$$slots: { default: [create_default_slot$8] },
		$$scope: { ctx }
	};

	for (let i = 0; i < icon_1_spread_levels.length; i += 1) {
		icon_1_props = assign(icon_1_props, icon_1_spread_levels[i]);
	}

	icon_1 = new Icon({ props: icon_1_props });

	return {
		c() {
			create_component(icon_1.$$.fragment);
		},
		l(nodes) {
			claim_component(icon_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(icon_1, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const icon_1_changes = (dirty & /*icon, lec*/ 3)
			? get_spread_update(icon_1_spread_levels, [
					dirty & /*icon*/ 2 && get_spread_object(/*icon*/ ctx[1].props),
					dirty & /*lec*/ 1 && { lec: /*lec*/ ctx[0] }
				])
			: {};

			if (dirty & /*$$scope, icon, lec*/ 11) {
				icon_1_changes.$$scope = { dirty, ctx };
			}

			icon_1.$set(icon_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon_1, detaching);
		}
	};
}

let index$19 = 0;

function instance$$($$self, $$props, $$invalidate) {
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { icon = undefined } = $$props;

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(0, lec = $$props.lec);
		if ('icon' in $$props) $$invalidate(1, icon = $$props.icon);
	};

	return [lec, icon];
}

class Use_icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$$, create_fragment$17, safe_not_equal, { lec: 0, icon: 1 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/preloader.liquivelte generated by Svelte v3.50.0 */

function create_else_block$e(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "preloader-inner");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (53:34) 
function create_if_block_2$i(ctx) {
	let span1;
	let span0;

	return {
		c() {
			span1 = element("span");
			span0 = element("span");
			this.h();
		},
		l(nodes) {
			span1 = claim_element(nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			span0 = claim_element(span1_nodes, "SPAN", { class: true });
			children(span0).forEach(detach);
			span1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span0, "class", "preloader-inner-circle");
			attr(span1, "class", "preloader-inner");
		},
		m(target, anchor) {
			insert_hydration(target, span1, anchor);
			append_hydration(span1, span0);
		},
		d(detaching) {
			if (detaching) detach(span1);
		}
	};
}

// (42:31) 
function create_if_block_1$n(ctx) {
	let span8;
	let span0;
	let t0;
	let span1;
	let t1;
	let span2;
	let t2;
	let span3;
	let t3;
	let span4;
	let t4;
	let span5;
	let t5;
	let span6;
	let t6;
	let span7;

	return {
		c() {
			span8 = element("span");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			t1 = space();
			span2 = element("span");
			t2 = space();
			span3 = element("span");
			t3 = space();
			span4 = element("span");
			t4 = space();
			span5 = element("span");
			t5 = space();
			span6 = element("span");
			t6 = space();
			span7 = element("span");
			this.h();
		},
		l(nodes) {
			span8 = claim_element(nodes, "SPAN", { class: true });
			var span8_nodes = children(span8);
			span0 = claim_element(span8_nodes, "SPAN", { class: true });
			children(span0).forEach(detach);
			t0 = claim_space(span8_nodes);
			span1 = claim_element(span8_nodes, "SPAN", { class: true });
			children(span1).forEach(detach);
			t1 = claim_space(span8_nodes);
			span2 = claim_element(span8_nodes, "SPAN", { class: true });
			children(span2).forEach(detach);
			t2 = claim_space(span8_nodes);
			span3 = claim_element(span8_nodes, "SPAN", { class: true });
			children(span3).forEach(detach);
			t3 = claim_space(span8_nodes);
			span4 = claim_element(span8_nodes, "SPAN", { class: true });
			children(span4).forEach(detach);
			t4 = claim_space(span8_nodes);
			span5 = claim_element(span8_nodes, "SPAN", { class: true });
			children(span5).forEach(detach);
			t5 = claim_space(span8_nodes);
			span6 = claim_element(span8_nodes, "SPAN", { class: true });
			children(span6).forEach(detach);
			t6 = claim_space(span8_nodes);
			span7 = claim_element(span8_nodes, "SPAN", { class: true });
			children(span7).forEach(detach);
			span8_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span0, "class", "preloader-inner-line");
			attr(span1, "class", "preloader-inner-line");
			attr(span2, "class", "preloader-inner-line");
			attr(span3, "class", "preloader-inner-line");
			attr(span4, "class", "preloader-inner-line");
			attr(span5, "class", "preloader-inner-line");
			attr(span6, "class", "preloader-inner-line");
			attr(span7, "class", "preloader-inner-line");
			attr(span8, "class", "preloader-inner");
		},
		m(target, anchor) {
			insert_hydration(target, span8, anchor);
			append_hydration(span8, span0);
			append_hydration(span8, t0);
			append_hydration(span8, span1);
			append_hydration(span8, t1);
			append_hydration(span8, span2);
			append_hydration(span8, t2);
			append_hydration(span8, span3);
			append_hydration(span8, t3);
			append_hydration(span8, span4);
			append_hydration(span8, t4);
			append_hydration(span8, span5);
			append_hydration(span8, t5);
			append_hydration(span8, span6);
			append_hydration(span8, t6);
			append_hydration(span8, span7);
		},
		d(detaching) {
			if (detaching) detach(span8);
		}
	};
}

// (36:2) {#if theme && theme.md}
function create_if_block$z(ctx) {
	let span;
	let svg;
	let circle;

	return {
		c() {
			span = element("span");
			svg = svg_element("svg");
			circle = svg_element("circle");
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			svg = claim_svg_element(span_nodes, "svg", { viewBox: true });
			var svg_nodes = children(svg);
			circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach);
			svg_nodes.forEach(detach);
			span_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(circle, "cx", "18");
			attr(circle, "cy", "18");
			attr(circle, "r", "16");
			attr(svg, "viewBox", "0 0 36 36");
			attr(span, "class", "preloader-inner");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, svg);
			append_hydration(svg, circle);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

function create_fragment$16(ctx) {
	let span;

	function select_block_type(ctx, dirty) {
		if (/*theme*/ ctx[0] && /*theme*/ ctx[0].md) return create_if_block$z;
		if (/*theme*/ ctx[0] && /*theme*/ ctx[0].ios) return create_if_block_1$n;
		if (/*theme*/ ctx[0] && /*theme*/ ctx[0].aurora) return create_if_block_2$i;
		return create_else_block$e;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	let span_levels = [
		{ style: /*preloaderStyle*/ ctx[2] },
		{ class: /*classes*/ ctx[1] },
		restProps(/*$$restProps*/ ctx[3])
	];

	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	return {
		c() {
			span = element("span");
			if_block.c();
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { style: true, class: true });
			var span_nodes = children(span);
			if_block.l(span_nodes);
			span_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(span, span_data);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			if_block.m(span, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type !== (current_block_type = select_block_type(ctx, dirty))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(span, null);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				dirty & /*preloaderStyle*/ 4 && { style: /*preloaderStyle*/ ctx[2] },
				dirty & /*classes*/ 2 && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(span);
			if_block.d();
		}
	};
}

let index$18 = 0;

function instance$_($$self, $$props, $$invalidate) {
	let sizeComputed;
	let preloaderStyle;
	let classes;
	const omit_props_names = ["lec","style","class","size"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { style = undefined } = $$props;
	let { class: className = undefined } = $$props;
	let { size = undefined } = $$props;

	let theme = useTheme(t => {
		$$invalidate(0, theme = t);
	});

	$$self.$$set = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(4, lec = $$new_props.lec);
		if ('style' in $$new_props) $$invalidate(5, style = $$new_props.style);
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('size' in $$new_props) $$invalidate(7, size = $$new_props.size);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 128) {
			$: $$invalidate(8, sizeComputed = size && typeof size === 'string' && size.indexOf('px') >= 0
			? size.replace('px', '')
			: size);
		}

		if ($$self.$$.dirty & /*style, sizeComputed*/ 288) {
			$: $$invalidate(2, preloaderStyle = ((style || '') + (sizeComputed
			? `;width: ${sizeComputed}px; height: ${sizeComputed}px; --f7-preloader-size: ${sizeComputed}px`
			: '')).replace(';;', ';'));
		}

		$: $$invalidate(1, classes = classNames(className, 'preloader', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);

	return [
		theme,
		classes,
		preloaderStyle,
		$$restProps,
		lec,
		style,
		className,
		size,
		sizeComputed
	];
}

class Preloader extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$_, create_fragment$16, safe_not_equal, { lec: 4, style: 5, class: 6, size: 7 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/button.liquivelte generated by Svelte v3.50.0 */

function create_else_block_1$4(ctx) {
	let a;
	let current_block_type_index;
	let if_block;
	let a_class_value;
	let useRouteProps_action;
	let useTooltip_action;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_6$4, create_else_block_2$3];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*preloader*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let a_levels = [
		{
			class: a_class_value = "button " + /*classes*/ ctx[11]
		},
		/*attrs*/ ctx[12]
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = element("a");
			if_block.c();
			this.h();
		},
		l(nodes) {
			a = claim_element(nodes, "A", { class: true });
			var a_nodes = children(a);
			if_block.l(a_nodes);
			a_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(a, a_data);
		},
		m(target, anchor) {
			insert_hydration(target, a, anchor);
			if_blocks[current_block_type_index].m(a, null);
			/*a_binding*/ ctx[51](a);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useRouteProps_action = useRouteProps.call(null, a, /*routeProps*/ ctx[4])),
					listen(a, "click", /*onClick*/ ctx[13]),
					action_destroyer(useTooltip_action = useTooltip.call(null, a, {
						tooltip: /*tooltip*/ ctx[2],
						tooltipTrigger: /*tooltipTrigger*/ ctx[3]
					}))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(a, null);
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty[0] & /*classes*/ 2048 && a_class_value !== (a_class_value = "button " + /*classes*/ ctx[11])) && { class: a_class_value },
				dirty[0] & /*attrs*/ 4096 && /*attrs*/ ctx[12]
			]));

			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 16) useRouteProps_action.update.call(null, /*routeProps*/ ctx[4]);

			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 12) useTooltip_action.update.call(null, {
				tooltip: /*tooltip*/ ctx[2],
				tooltipTrigger: /*tooltipTrigger*/ ctx[3]
			});
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if_blocks[current_block_type_index].d();
			/*a_binding*/ ctx[51](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (136:0) {#if tagName == 'button' }
function create_if_block$y(ctx) {
	let button;
	let current_block_type_index;
	let if_block;
	let button_class_value;
	let useRouteProps_action;
	let useTooltip_action;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1$m, create_else_block$d];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*preloader*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let button_levels = [
		{
			class: button_class_value = "button " + /*classes*/ ctx[11]
		},
		/*attrs*/ ctx[12]
	];

	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = assign(button_data, button_levels[i]);
	}

	return {
		c() {
			button = element("button");
			if_block.c();
			this.h();
		},
		l(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			if_block.l(button_nodes);
			button_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(button, button_data);
		},
		m(target, anchor) {
			insert_hydration(target, button, anchor);
			if_blocks[current_block_type_index].m(button, null);
			if (button.autofocus) button.focus();
			/*button_binding*/ ctx[50](button);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useRouteProps_action = useRouteProps.call(null, button, /*routeProps*/ ctx[4])),
					listen(button, "click", /*onClick*/ ctx[13]),
					action_destroyer(useTooltip_action = useTooltip.call(null, button, {
						tooltip: /*tooltip*/ ctx[2],
						tooltipTrigger: /*tooltipTrigger*/ ctx[3]
					}))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(button, null);
			}

			set_attributes(button, button_data = get_spread_update(button_levels, [
				(!current || dirty[0] & /*classes*/ 2048 && button_class_value !== (button_class_value = "button " + /*classes*/ ctx[11])) && { class: button_class_value },
				dirty[0] & /*attrs*/ 4096 && /*attrs*/ ctx[12]
			]));

			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 16) useRouteProps_action.update.call(null, /*routeProps*/ ctx[4]);

			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 12) useTooltip_action.update.call(null, {
				tooltip: /*tooltip*/ ctx[2],
				tooltipTrigger: /*tooltipTrigger*/ ctx[3]
			});
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(button);
			if_blocks[current_block_type_index].d();
			/*button_binding*/ ctx[50](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (186:4) {:else}
function create_else_block_2$3(ctx) {
	let t0;
	let t1;
	let current;
	let if_block0 = /*icon*/ ctx[9] && create_if_block_10$4(ctx);
	let if_block1 = /*text*/ ctx[1] != undefined && create_if_block_9$4(ctx);
	const default_slot_template = /*#slots*/ ctx[49].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[48], null);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (if_block0) if_block0.l(nodes);
			t0 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t1 = claim_space(nodes);
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration(target, t1, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[9]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*icon*/ 512) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_10$4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*text*/ ctx[1] != undefined) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_9$4(ctx);
					if_block1.c();
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 131072)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[48],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[48])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[48], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t1);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (175:4) {#if preloader }
function create_if_block_6$4(ctx) {
	let preloader_1;
	let t0;
	let span;
	let t1;
	let t2;
	let current;

	preloader_1 = new Preloader({
			props: {
				size: /*preloaderSize*/ ctx[6],
				color: /*preloaderColor*/ ctx[7],
				lec: /*lec*/ ctx[0]
			}
		});

	let if_block0 = /*icon*/ ctx[9] && create_if_block_8$4(ctx);
	let if_block1 = /*text*/ ctx[1] != undefined && create_if_block_7$4(ctx);
	const default_slot_template = /*#slots*/ ctx[49].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[48], null);

	return {
		c() {
			create_component(preloader_1.$$.fragment);
			t0 = space();
			span = element("span");
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			claim_component(preloader_1.$$.fragment, nodes);
			t0 = claim_space(nodes);
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			if (if_block0) if_block0.l(span_nodes);
			t1 = claim_space(span_nodes);
			if (if_block1) if_block1.l(span_nodes);
			t2 = claim_space(span_nodes);
			if (default_slot) default_slot.l(span_nodes);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			mount_component(preloader_1, target, anchor);
			insert_hydration(target, t0, anchor);
			insert_hydration(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append_hydration(span, t1);
			if (if_block1) if_block1.m(span, null);
			append_hydration(span, t2);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			const preloader_1_changes = {};
			if (dirty[0] & /*preloaderSize*/ 64) preloader_1_changes.size = /*preloaderSize*/ ctx[6];
			if (dirty[0] & /*preloaderColor*/ 128) preloader_1_changes.color = /*preloaderColor*/ ctx[7];
			if (dirty[0] & /*lec*/ 1) preloader_1_changes.lec = /*lec*/ ctx[0];
			preloader_1.$set(preloader_1_changes);

			if (/*icon*/ ctx[9]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*icon*/ 512) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_8$4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(span, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*text*/ ctx[1] != undefined) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_7$4(ctx);
					if_block1.c();
					if_block1.m(span, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 131072)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[48],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[48])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[48], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(preloader_1.$$.fragment, local);
			transition_in(if_block0);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(preloader_1.$$.fragment, local);
			transition_out(if_block0);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			destroy_component(preloader_1, detaching);
			if (detaching) detach(t0);
			if (detaching) detach(span);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (187:6) {#if icon }
function create_if_block_10$4(ctx) {
	let useicon;
	let current;

	useicon = new Use_icon({
			props: {
				icon: /*icon*/ ctx[9],
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(useicon.$$.fragment);
		},
		l(nodes) {
			claim_component(useicon.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(useicon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const useicon_changes = {};
			if (dirty[0] & /*icon*/ 512) useicon_changes.icon = /*icon*/ ctx[9];
			if (dirty[0] & /*lec*/ 1) useicon_changes.lec = /*lec*/ ctx[0];
			useicon.$set(useicon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(useicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(useicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(useicon, detaching);
		}
	};
}

// (190:6) {#if text != undefined }
function create_if_block_9$4(ctx) {
	let span;
	let t_value = plainText(/*text*/ ctx[1]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*text*/ 2 && t_value !== (t_value = plainText(/*text*/ ctx[1]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (178:8) {#if icon }
function create_if_block_8$4(ctx) {
	let useicon;
	let current;

	useicon = new Use_icon({
			props: {
				icon: /*icon*/ ctx[9],
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(useicon.$$.fragment);
		},
		l(nodes) {
			claim_component(useicon.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(useicon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const useicon_changes = {};
			if (dirty[0] & /*icon*/ 512) useicon_changes.icon = /*icon*/ ctx[9];
			if (dirty[0] & /*lec*/ 1) useicon_changes.lec = /*lec*/ ctx[0];
			useicon.$set(useicon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(useicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(useicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(useicon, detaching);
		}
	};
}

// (181:8) {#if text != undefined }
function create_if_block_7$4(ctx) {
	let span;
	let t_value = plainText(/*text*/ ctx[1]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*text*/ 2 && t_value !== (t_value = plainText(/*text*/ ctx[1]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (156:4) {:else}
function create_else_block$d(ctx) {
	let t0;
	let t1;
	let current;
	let if_block0 = /*icon*/ ctx[9] && create_if_block_5$5(ctx);
	let if_block1 = /*text*/ ctx[1] != undefined && create_if_block_4$8(ctx);
	const default_slot_template = /*#slots*/ ctx[49].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[48], null);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (if_block0) if_block0.l(nodes);
			t0 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t1 = claim_space(nodes);
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration(target, t1, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[9]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*icon*/ 512) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_5$5(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*text*/ ctx[1] != undefined) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_4$8(ctx);
					if_block1.c();
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 131072)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[48],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[48])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[48], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t1);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (145:4) {#if preloader }
function create_if_block_1$m(ctx) {
	let preloader_1;
	let t0;
	let span;
	let t1;
	let t2;
	let current;

	preloader_1 = new Preloader({
			props: {
				size: /*preloaderSize*/ ctx[6],
				color: /*preloaderColor*/ ctx[7],
				lec: /*lec*/ ctx[0]
			}
		});

	let if_block0 = /*icon*/ ctx[9] && create_if_block_3$e(ctx);
	let if_block1 = /*text*/ ctx[1] != undefined && create_if_block_2$h(ctx);
	const default_slot_template = /*#slots*/ ctx[49].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[48], null);

	return {
		c() {
			create_component(preloader_1.$$.fragment);
			t0 = space();
			span = element("span");
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			claim_component(preloader_1.$$.fragment, nodes);
			t0 = claim_space(nodes);
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			if (if_block0) if_block0.l(span_nodes);
			t1 = claim_space(span_nodes);
			if (if_block1) if_block1.l(span_nodes);
			t2 = claim_space(span_nodes);
			if (default_slot) default_slot.l(span_nodes);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			mount_component(preloader_1, target, anchor);
			insert_hydration(target, t0, anchor);
			insert_hydration(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append_hydration(span, t1);
			if (if_block1) if_block1.m(span, null);
			append_hydration(span, t2);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			const preloader_1_changes = {};
			if (dirty[0] & /*preloaderSize*/ 64) preloader_1_changes.size = /*preloaderSize*/ ctx[6];
			if (dirty[0] & /*preloaderColor*/ 128) preloader_1_changes.color = /*preloaderColor*/ ctx[7];
			if (dirty[0] & /*lec*/ 1) preloader_1_changes.lec = /*lec*/ ctx[0];
			preloader_1.$set(preloader_1_changes);

			if (/*icon*/ ctx[9]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*icon*/ 512) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3$e(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(span, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*text*/ ctx[1] != undefined) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2$h(ctx);
					if_block1.c();
					if_block1.m(span, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 131072)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[48],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[48])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[48], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(preloader_1.$$.fragment, local);
			transition_in(if_block0);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(preloader_1.$$.fragment, local);
			transition_out(if_block0);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			destroy_component(preloader_1, detaching);
			if (detaching) detach(t0);
			if (detaching) detach(span);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (157:6) {#if icon }
function create_if_block_5$5(ctx) {
	let useicon;
	let current;

	useicon = new Use_icon({
			props: {
				icon: /*icon*/ ctx[9],
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(useicon.$$.fragment);
		},
		l(nodes) {
			claim_component(useicon.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(useicon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const useicon_changes = {};
			if (dirty[0] & /*icon*/ 512) useicon_changes.icon = /*icon*/ ctx[9];
			if (dirty[0] & /*lec*/ 1) useicon_changes.lec = /*lec*/ ctx[0];
			useicon.$set(useicon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(useicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(useicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(useicon, detaching);
		}
	};
}

// (160:6) {#if text != undefined }
function create_if_block_4$8(ctx) {
	let span;
	let t_value = plainText(/*text*/ ctx[1]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*text*/ 2 && t_value !== (t_value = plainText(/*text*/ ctx[1]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (148:8) {#if icon }
function create_if_block_3$e(ctx) {
	let useicon;
	let current;

	useicon = new Use_icon({
			props: {
				icon: /*icon*/ ctx[9],
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(useicon.$$.fragment);
		},
		l(nodes) {
			claim_component(useicon.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(useicon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const useicon_changes = {};
			if (dirty[0] & /*icon*/ 512) useicon_changes.icon = /*icon*/ ctx[9];
			if (dirty[0] & /*lec*/ 1) useicon_changes.lec = /*lec*/ ctx[0];
			useicon.$set(useicon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(useicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(useicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(useicon, detaching);
		}
	};
}

// (151:8) {#if text != undefined }
function create_if_block_2$h(ctx) {
	let span;
	let t_value = plainText(/*text*/ ctx[1]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*text*/ 2 && t_value !== (t_value = plainText(/*text*/ ctx[1]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

function create_fragment$15(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$y, create_else_block_1$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tagName*/ ctx[10] == 'button') return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

let index$17 = 0;

function instance$Z($$self, $$props, $$invalidate) {
	let hrefComputed;
	let attrs;
	let classes;
	let tagName;
	let icon;

	const omit_props_names = [
		"lec","class","text","tabLink","tabLinkActive","type","href","target","round","roundMd","roundIos","roundAurora","fill","fillMd","fillIos","fillAurora","large","largeMd","largeIos","largeAurora","small","smallMd","smallIos","smallAurora","raised","raisedMd","raisedIos","raisedAurora","outline","outlineMd","outlineIos","outlineAurora","active","disabled","tooltip","tooltipTrigger","routeProps","preloader","preloaderSize","preloaderColor","loading"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { text = undefined } = $$props;
	let { tabLink = undefined } = $$props;
	let { tabLinkActive = false } = $$props;
	let { type = undefined } = $$props;
	let { href = '#' } = $$props;
	let { target = undefined } = $$props;
	let { round = false } = $$props;
	let { roundMd = false } = $$props;
	let { roundIos = false } = $$props;
	let { roundAurora = false } = $$props;
	let { fill = false } = $$props;
	let { fillMd = false } = $$props;
	let { fillIos = false } = $$props;
	let { fillAurora = false } = $$props;
	let { large = false } = $$props;
	let { largeMd = false } = $$props;
	let { largeIos = false } = $$props;
	let { largeAurora = false } = $$props;
	let { small = false } = $$props;
	let { smallMd = false } = $$props;
	let { smallIos = false } = $$props;
	let { smallAurora = false } = $$props;
	let { raised = false } = $$props;
	let { raisedMd = false } = $$props;
	let { raisedIos = false } = $$props;
	let { raisedAurora = false } = $$props;
	let { outline = false } = $$props;
	let { outlineMd = false } = $$props;
	let { outlineIos = false } = $$props;
	let { outlineAurora = false } = $$props;
	let { active = false } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let { routeProps = undefined } = $$props;
	let { preloader = false } = $$props;
	let { preloaderSize = undefined } = $$props;
	let { preloaderColor = undefined } = $$props;
	let { loading = false } = $$props;
	let el;

	function onClick() {
		emit('click');
	}

	function button_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(8, el);
		});
	}

	function a_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(8, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(54, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(55, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(0, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(14, className = $$new_props.class);
		if ('text' in $$new_props) $$invalidate(1, text = $$new_props.text);
		if ('tabLink' in $$new_props) $$invalidate(15, tabLink = $$new_props.tabLink);
		if ('tabLinkActive' in $$new_props) $$invalidate(16, tabLinkActive = $$new_props.tabLinkActive);
		if ('type' in $$new_props) $$invalidate(17, type = $$new_props.type);
		if ('href' in $$new_props) $$invalidate(18, href = $$new_props.href);
		if ('target' in $$new_props) $$invalidate(19, target = $$new_props.target);
		if ('round' in $$new_props) $$invalidate(20, round = $$new_props.round);
		if ('roundMd' in $$new_props) $$invalidate(21, roundMd = $$new_props.roundMd);
		if ('roundIos' in $$new_props) $$invalidate(22, roundIos = $$new_props.roundIos);
		if ('roundAurora' in $$new_props) $$invalidate(23, roundAurora = $$new_props.roundAurora);
		if ('fill' in $$new_props) $$invalidate(24, fill = $$new_props.fill);
		if ('fillMd' in $$new_props) $$invalidate(25, fillMd = $$new_props.fillMd);
		if ('fillIos' in $$new_props) $$invalidate(26, fillIos = $$new_props.fillIos);
		if ('fillAurora' in $$new_props) $$invalidate(27, fillAurora = $$new_props.fillAurora);
		if ('large' in $$new_props) $$invalidate(28, large = $$new_props.large);
		if ('largeMd' in $$new_props) $$invalidate(29, largeMd = $$new_props.largeMd);
		if ('largeIos' in $$new_props) $$invalidate(30, largeIos = $$new_props.largeIos);
		if ('largeAurora' in $$new_props) $$invalidate(31, largeAurora = $$new_props.largeAurora);
		if ('small' in $$new_props) $$invalidate(32, small = $$new_props.small);
		if ('smallMd' in $$new_props) $$invalidate(33, smallMd = $$new_props.smallMd);
		if ('smallIos' in $$new_props) $$invalidate(34, smallIos = $$new_props.smallIos);
		if ('smallAurora' in $$new_props) $$invalidate(35, smallAurora = $$new_props.smallAurora);
		if ('raised' in $$new_props) $$invalidate(36, raised = $$new_props.raised);
		if ('raisedMd' in $$new_props) $$invalidate(37, raisedMd = $$new_props.raisedMd);
		if ('raisedIos' in $$new_props) $$invalidate(38, raisedIos = $$new_props.raisedIos);
		if ('raisedAurora' in $$new_props) $$invalidate(39, raisedAurora = $$new_props.raisedAurora);
		if ('outline' in $$new_props) $$invalidate(40, outline = $$new_props.outline);
		if ('outlineMd' in $$new_props) $$invalidate(41, outlineMd = $$new_props.outlineMd);
		if ('outlineIos' in $$new_props) $$invalidate(42, outlineIos = $$new_props.outlineIos);
		if ('outlineAurora' in $$new_props) $$invalidate(43, outlineAurora = $$new_props.outlineAurora);
		if ('active' in $$new_props) $$invalidate(44, active = $$new_props.active);
		if ('disabled' in $$new_props) $$invalidate(45, disabled = $$new_props.disabled);
		if ('tooltip' in $$new_props) $$invalidate(2, tooltip = $$new_props.tooltip);
		if ('tooltipTrigger' in $$new_props) $$invalidate(3, tooltipTrigger = $$new_props.tooltipTrigger);
		if ('routeProps' in $$new_props) $$invalidate(4, routeProps = $$new_props.routeProps);
		if ('preloader' in $$new_props) $$invalidate(5, preloader = $$new_props.preloader);
		if ('preloaderSize' in $$new_props) $$invalidate(6, preloaderSize = $$new_props.preloaderSize);
		if ('preloaderColor' in $$new_props) $$invalidate(7, preloaderColor = $$new_props.preloaderColor);
		if ('loading' in $$new_props) $$invalidate(46, loading = $$new_props.loading);
		if ('$$scope' in $$new_props) $$invalidate(48, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*href*/ 262144) {
			$: $$invalidate(47, hrefComputed = href === true ? '#' : href || undefined);
		}

		$: $$invalidate(12, attrs = extend(
			{
				href: hrefComputed,
				target,
				type,
				'data-tab': isStringProp(tabLink) && tabLink || undefined,
				...restProps($$restProps)
			},
			routerAttrs($$props),
			actionsAttrs($$props)
		));

		$: $$invalidate(11, classes = classNames(
			className,
			{
				'tab-link': tabLink || tabLink === '',
				'tab-link-active': tabLinkActive,
				'button-round': round,
				'button-round-ios': roundIos,
				'button-round-aurora': roundAurora,
				'button-round-md': roundMd,
				'button-fill': fill,
				'button-fill-ios': fillIos,
				'button-fill-aurora': fillAurora,
				'button-fill-md': fillMd,
				'button-large': large,
				'button-large-ios': largeIos,
				'button-large-aurora': largeAurora,
				'button-large-md': largeMd,
				'button-small': small,
				'button-small-ios': smallIos,
				'button-small-aurora': smallAurora,
				'button-small-md': smallMd,
				'button-raised': raised,
				'button-raised-ios': raisedIos,
				'button-raised-aurora': raisedAurora,
				'button-raised-md': raisedMd,
				'button-active': active,
				'button-outline': outline,
				'button-outline-ios': outlineIos,
				'button-outline-aurora': outlineAurora,
				'button-outline-md': outlineMd,
				'button-preloader': preloader,
				'button-loading': loading,
				disabled
			},
			colorClasses($$props),
			routerClasses($$props),
			actionsClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*type*/ 131072) {
			$: $$invalidate(10, tagName = type === 'submit' || type === 'reset' || type === 'button'
			? 'button'
			: 'a');
		}

		$: $$invalidate(9, icon = useIcon($$props));
	};

	$$props = exclude_internal_props($$props);

	return [
		lec,
		text,
		tooltip,
		tooltipTrigger,
		routeProps,
		preloader,
		preloaderSize,
		preloaderColor,
		el,
		icon,
		tagName,
		classes,
		attrs,
		onClick,
		className,
		tabLink,
		tabLinkActive,
		type,
		href,
		target,
		round,
		roundMd,
		roundIos,
		roundAurora,
		fill,
		fillMd,
		fillIos,
		fillAurora,
		large,
		largeMd,
		largeIos,
		largeAurora,
		small,
		smallMd,
		smallIos,
		smallAurora,
		raised,
		raisedMd,
		raisedIos,
		raisedAurora,
		outline,
		outlineMd,
		outlineIos,
		outlineAurora,
		active,
		disabled,
		loading,
		hrefComputed,
		$$scope,
		slots,
		button_binding,
		a_binding
	];
}

class Button extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$Z,
			create_fragment$15,
			safe_not_equal,
			{
				lec: 0,
				class: 14,
				text: 1,
				tabLink: 15,
				tabLinkActive: 16,
				type: 17,
				href: 18,
				target: 19,
				round: 20,
				roundMd: 21,
				roundIos: 22,
				roundAurora: 23,
				fill: 24,
				fillMd: 25,
				fillIos: 26,
				fillAurora: 27,
				large: 28,
				largeMd: 29,
				largeIos: 30,
				largeAurora: 31,
				small: 32,
				smallMd: 33,
				smallIos: 34,
				smallAurora: 35,
				raised: 36,
				raisedMd: 37,
				raisedIos: 38,
				raisedAurora: 39,
				outline: 40,
				outlineMd: 41,
				outlineIos: 42,
				outlineAurora: 43,
				active: 44,
				disabled: 45,
				tooltip: 2,
				tooltipTrigger: 3,
				routeProps: 4,
				preloader: 5,
				preloaderSize: 6,
				preloaderColor: 7,
				loading: 46
			},
			null,
			[-1, -1]
		);
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/card-content.liquivelte generated by Svelte v3.50.0 */

function create_fragment$14(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	let div_levels = [
		{
			class: div_class_value = "card-content " + /*classes*/ ctx[0]
		},
		restProps(/*$$restProps*/ ctx[1])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1 && div_class_value !== (div_class_value = "card-content " + /*classes*/ ctx[0])) && { class: div_class_value },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$16 = 0;

function instance$Y($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class","padding"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let { padding = true } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('padding' in $$new_props) $$invalidate(4, padding = $$new_props.padding);
		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, { 'card-content-padding': padding }, colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, padding, $$scope, slots];
}

class Card_content extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$Y, create_fragment$14, safe_not_equal, { lec: 2, class: 3, padding: 4 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/card-footer.liquivelte generated by Svelte v3.50.0 */

function create_fragment$13(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	let div_levels = [
		{
			class: div_class_value = "card-footer " + /*classes*/ ctx[0]
		},
		restProps(/*$$restProps*/ ctx[1])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1 && div_class_value !== (div_class_value = "card-footer " + /*classes*/ ctx[0])) && { class: div_class_value },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$15 = 0;

function instance$X($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, $$scope, slots];
}

class Card_footer extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$X, create_fragment$13, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/card-header.liquivelte generated by Svelte v3.50.0 */

function create_fragment$12(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	let div_levels = [
		{
			class: div_class_value = "card-header " + /*classes*/ ctx[0]
		},
		restProps(/*$$restProps*/ ctx[1])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1 && div_class_value !== (div_class_value = "card-header " + /*classes*/ ctx[0])) && { class: div_class_value },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$14 = 0;

function instance$W($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, $$scope, slots];
}

class Card_header extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$W, create_fragment$12, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/card.liquivelte generated by Svelte v3.50.0 */
const get_footer_slot_changes$2 = dirty => ({});
const get_footer_slot_context$2 = ctx => ({});
const get_content_slot_changes$3 = dirty => ({});
const get_content_slot_context$3 = ctx => ({});
const get_header_slot_changes$2 = dirty => ({});
const get_header_slot_context$2 = ctx => ({});

// (155:2) {#if typeof title !== 'undefined' || hasHeaderSlots}
function create_if_block_2$g(ctx) {
	let cardheader;
	let current;

	cardheader = new Card_header({
			props: {
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot_2$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(cardheader.$$.fragment);
		},
		l(nodes) {
			claim_component(cardheader.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(cardheader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const cardheader_changes = {};
			if (dirty[0] & /*lec*/ 1) cardheader_changes.lec = /*lec*/ ctx[0];

			if (dirty[0] & /*$$scope, title*/ 536870914) {
				cardheader_changes.$$scope = { dirty, ctx };
			}

			cardheader.$set(cardheader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(cardheader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(cardheader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(cardheader, detaching);
		}
	};
}

// (156:4) <CardHeader      lec={lec} >
function create_default_slot_2$3(ctx) {
	let t0_value = plainText(/*title*/ ctx[1]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[27].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[29], get_header_slot_context$2);

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
		},
		l(nodes) {
			t0 = claim_text(nodes, t0_value);
			t1 = claim_space(nodes);
			if (header_slot) header_slot.l(nodes);
		},
		m(target, anchor) {
			insert_hydration(target, t0, anchor);
			insert_hydration(target, t1, anchor);

			if (header_slot) {
				header_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 2) && t0_value !== (t0_value = plainText(/*title*/ ctx[1]) + "")) set_data(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && (!current || dirty[0] & /*$$scope*/ 536870912)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[29],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[29])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[29], dirty, get_header_slot_changes$2),
						get_header_slot_context$2
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (161:2) {#if typeof content !== 'undefined' || hasContentSlots}
function create_if_block_1$l(ctx) {
	let cardcontent;
	let current;

	cardcontent = new Card_content({
			props: {
				padding: /*padding*/ ctx[13],
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(cardcontent.$$.fragment);
		},
		l(nodes) {
			claim_component(cardcontent.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(cardcontent, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const cardcontent_changes = {};
			if (dirty[0] & /*padding*/ 8192) cardcontent_changes.padding = /*padding*/ ctx[13];
			if (dirty[0] & /*lec*/ 1) cardcontent_changes.lec = /*lec*/ ctx[0];

			if (dirty[0] & /*$$scope, content*/ 536870916) {
				cardcontent_changes.$$scope = { dirty, ctx };
			}

			cardcontent.$set(cardcontent_changes);
		},
		i(local) {
			if (current) return;
			transition_in(cardcontent.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(cardcontent.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(cardcontent, detaching);
		}
	};
}

// (162:4) <CardContent  {padding}     lec={lec} >
function create_default_slot_1$3(ctx) {
	let t0_value = plainText(/*content*/ ctx[2]) + "";
	let t0;
	let t1;
	let current;
	const content_slot_template = /*#slots*/ ctx[27].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[29], get_content_slot_context$3);

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
			if (content_slot) content_slot.c();
		},
		l(nodes) {
			t0 = claim_text(nodes, t0_value);
			t1 = claim_space(nodes);
			if (content_slot) content_slot.l(nodes);
		},
		m(target, anchor) {
			insert_hydration(target, t0, anchor);
			insert_hydration(target, t1, anchor);

			if (content_slot) {
				content_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*content*/ 4) && t0_value !== (t0_value = plainText(/*content*/ ctx[2]) + "")) set_data(t0, t0_value);

			if (content_slot) {
				if (content_slot.p && (!current || dirty[0] & /*$$scope*/ 536870912)) {
					update_slot_base(
						content_slot,
						content_slot_template,
						ctx,
						/*$$scope*/ ctx[29],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[29])
						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[29], dirty, get_content_slot_changes$3),
						get_content_slot_context$3
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(content_slot, local);
			current = true;
		},
		o(local) {
			transition_out(content_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (content_slot) content_slot.d(detaching);
		}
	};
}

// (167:2) {#if typeof footer !== 'undefined' || hasFooterSlots}
function create_if_block$x(ctx) {
	let cardfooter;
	let current;

	cardfooter = new Card_footer({
			props: {
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(cardfooter.$$.fragment);
		},
		l(nodes) {
			claim_component(cardfooter.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(cardfooter, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const cardfooter_changes = {};
			if (dirty[0] & /*lec*/ 1) cardfooter_changes.lec = /*lec*/ ctx[0];

			if (dirty[0] & /*$$scope, footer*/ 536870920) {
				cardfooter_changes.$$scope = { dirty, ctx };
			}

			cardfooter.$set(cardfooter_changes);
		},
		i(local) {
			if (current) return;
			transition_in(cardfooter.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(cardfooter.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(cardfooter, detaching);
		}
	};
}

// (168:4) <CardFooter      lec={lec} >
function create_default_slot$7(ctx) {
	let t0_value = plainText(/*footer*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[27].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[29], get_footer_slot_context$2);

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
		},
		l(nodes) {
			t0 = claim_text(nodes, t0_value);
			t1 = claim_space(nodes);
			if (footer_slot) footer_slot.l(nodes);
		},
		m(target, anchor) {
			insert_hydration(target, t0, anchor);
			insert_hydration(target, t1, anchor);

			if (footer_slot) {
				footer_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 8) && t0_value !== (t0_value = plainText(/*footer*/ ctx[3]) + "")) set_data(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty[0] & /*$$scope*/ 536870912)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[29],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[29])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[29], dirty, get_footer_slot_changes$2),
						get_footer_slot_context$2
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (footer_slot) footer_slot.d(detaching);
		}
	};
}

function create_fragment$11(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let div_class_value;
	let div_data_animate_value;
	let div_data_hide_navbar_on_open_value;
	let div_data_hide_toolbar_on_open_value;
	let div_data_hide_statusbar_on_open_value;
	let div_data_swipe_to_close_value;
	let div_data_close_by_backdrop_click_value;
	let div_data_backdrop_value;
	let current;
	let if_block0 = (typeof /*title*/ ctx[1] !== 'undefined' || /*hasHeaderSlots*/ ctx[17]) && create_if_block_2$g(ctx);
	let if_block1 = (typeof /*content*/ ctx[2] !== 'undefined' || /*hasContentSlots*/ ctx[16]) && create_if_block_1$l(ctx);
	let if_block2 = (typeof /*footer*/ ctx[3] !== 'undefined' || /*hasFooterSlots*/ ctx[15]) && create_if_block$x(ctx);
	const default_slot_template = /*#slots*/ ctx[27].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[29], null);

	let div_levels = [
		{
			class: div_class_value = "card " + /*classes*/ ctx[18]
		},
		{
			"data-animate": div_data_animate_value = typeof /*animate*/ ctx[4] === 'undefined'
			? /*animate*/ ctx[4]
			: /*animate*/ ctx[4].toString()
		},
		{
			"data-hide-navbar-on-open": div_data_hide_navbar_on_open_value = typeof /*hideNavbarOnOpen*/ ctx[5] === 'undefined'
			? /*hideNavbarOnOpen*/ ctx[5]
			: /*hideNavbarOnOpen*/ ctx[5].toString()
		},
		{
			"data-hide-toolbar-on-open": div_data_hide_toolbar_on_open_value = typeof /*hideToolbarOnOpen*/ ctx[6] === 'undefined'
			? /*hideToolbarOnOpen*/ ctx[6]
			: /*hideToolbarOnOpen*/ ctx[6].toString()
		},
		{
			"data-hide-statusbar-on-open": div_data_hide_statusbar_on_open_value = typeof /*hideStatusbarOnOpen*/ ctx[7] === 'undefined'
			? /*hideStatusbarOnOpen*/ ctx[7]
			: /*hideStatusbarOnOpen*/ ctx[7].toString()
		},
		{
			"data-scrollable-el": /*scrollableEl*/ ctx[8]
		},
		{
			"data-swipe-to-close": div_data_swipe_to_close_value = typeof /*swipeToClose*/ ctx[9] === 'undefined'
			? /*swipeToClose*/ ctx[9]
			: /*swipeToClose*/ ctx[9].toString()
		},
		{
			"data-close-by-backdrop-click": div_data_close_by_backdrop_click_value = typeof /*closeByBackdropClick*/ ctx[10] === 'undefined'
			? /*closeByBackdropClick*/ ctx[10]
			: /*closeByBackdropClick*/ ctx[10].toString()
		},
		{
			"data-backdrop": div_data_backdrop_value = typeof /*backdrop*/ ctx[11] === 'undefined'
			? /*backdrop*/ ctx[11]
			: /*backdrop*/ ctx[11].toString()
		},
		{
			"data-backdrop-el": /*backdropEl*/ ctx[12]
		},
		restProps(/*$$restProps*/ ctx[19])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {
				class: true,
				"data-animate": true,
				"data-hide-navbar-on-open": true,
				"data-hide-toolbar-on-open": true,
				"data-hide-statusbar-on-open": true,
				"data-scrollable-el": true,
				"data-swipe-to-close": true,
				"data-close-by-backdrop-click": true,
				"data-backdrop": true,
				"data-backdrop-el": true
			});

			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block2) if_block2.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t1);
			if (if_block2) if_block2.m(div, null);
			append_hydration(div, t2);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[28](div);
			current = true;
		},
		p(ctx, dirty) {
			if (typeof /*title*/ ctx[1] !== 'undefined' || /*hasHeaderSlots*/ ctx[17]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*title, hasHeaderSlots*/ 131074) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$g(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (typeof /*content*/ ctx[2] !== 'undefined' || /*hasContentSlots*/ ctx[16]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*content, hasContentSlots*/ 65540) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$l(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (typeof /*footer*/ ctx[3] !== 'undefined' || /*hasFooterSlots*/ ctx[15]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*footer, hasFooterSlots*/ 32776) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block$x(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, t2);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 536870912)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[29],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[29])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[29], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 262144 && div_class_value !== (div_class_value = "card " + /*classes*/ ctx[18])) && { class: div_class_value },
				(!current || dirty[0] & /*animate*/ 16 && div_data_animate_value !== (div_data_animate_value = typeof /*animate*/ ctx[4] === 'undefined'
				? /*animate*/ ctx[4]
				: /*animate*/ ctx[4].toString())) && { "data-animate": div_data_animate_value },
				(!current || dirty[0] & /*hideNavbarOnOpen*/ 32 && div_data_hide_navbar_on_open_value !== (div_data_hide_navbar_on_open_value = typeof /*hideNavbarOnOpen*/ ctx[5] === 'undefined'
				? /*hideNavbarOnOpen*/ ctx[5]
				: /*hideNavbarOnOpen*/ ctx[5].toString())) && {
					"data-hide-navbar-on-open": div_data_hide_navbar_on_open_value
				},
				(!current || dirty[0] & /*hideToolbarOnOpen*/ 64 && div_data_hide_toolbar_on_open_value !== (div_data_hide_toolbar_on_open_value = typeof /*hideToolbarOnOpen*/ ctx[6] === 'undefined'
				? /*hideToolbarOnOpen*/ ctx[6]
				: /*hideToolbarOnOpen*/ ctx[6].toString())) && {
					"data-hide-toolbar-on-open": div_data_hide_toolbar_on_open_value
				},
				(!current || dirty[0] & /*hideStatusbarOnOpen*/ 128 && div_data_hide_statusbar_on_open_value !== (div_data_hide_statusbar_on_open_value = typeof /*hideStatusbarOnOpen*/ ctx[7] === 'undefined'
				? /*hideStatusbarOnOpen*/ ctx[7]
				: /*hideStatusbarOnOpen*/ ctx[7].toString())) && {
					"data-hide-statusbar-on-open": div_data_hide_statusbar_on_open_value
				},
				(!current || dirty[0] & /*scrollableEl*/ 256) && {
					"data-scrollable-el": /*scrollableEl*/ ctx[8]
				},
				(!current || dirty[0] & /*swipeToClose*/ 512 && div_data_swipe_to_close_value !== (div_data_swipe_to_close_value = typeof /*swipeToClose*/ ctx[9] === 'undefined'
				? /*swipeToClose*/ ctx[9]
				: /*swipeToClose*/ ctx[9].toString())) && {
					"data-swipe-to-close": div_data_swipe_to_close_value
				},
				(!current || dirty[0] & /*closeByBackdropClick*/ 1024 && div_data_close_by_backdrop_click_value !== (div_data_close_by_backdrop_click_value = typeof /*closeByBackdropClick*/ ctx[10] === 'undefined'
				? /*closeByBackdropClick*/ ctx[10]
				: /*closeByBackdropClick*/ ctx[10].toString())) && {
					"data-close-by-backdrop-click": div_data_close_by_backdrop_click_value
				},
				(!current || dirty[0] & /*backdrop*/ 2048 && div_data_backdrop_value !== (div_data_backdrop_value = typeof /*backdrop*/ ctx[11] === 'undefined'
				? /*backdrop*/ ctx[11]
				: /*backdrop*/ ctx[11].toString())) && { "data-backdrop": div_data_backdrop_value },
				(!current || dirty[0] & /*backdropEl*/ 4096) && {
					"data-backdrop-el": /*backdropEl*/ ctx[12]
				},
				dirty[0] & /*$$restProps*/ 524288 && restProps(/*$$restProps*/ ctx[19])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[28](null);
		}
	};
}

let index$13 = 0;

function instance$V($$self, $$props, $$invalidate) {
	let classes;
	let hasHeaderSlots;
	let hasContentSlots;
	let hasFooterSlots;

	const omit_props_names = [
		"lec","class","title","content","footer","outline","expandable","expandableAnimateWidth","expandableOpened","animate","hideNavbarOnOpen","hideToolbarOnOpen","hideStatusbarOnOpen","scrollableEl","swipeToClose","closeByBackdropClick","backdrop","backdropEl","noShadow","noBorder","padding"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { title = undefined } = $$props;
	let { content = undefined } = $$props;
	let { footer = undefined } = $$props;
	let { outline = false } = $$props;
	let { expandable = false } = $$props;
	let { expandableAnimateWidth = false } = $$props;
	let { expandableOpened = false } = $$props;
	let { animate = undefined } = $$props;
	let { hideNavbarOnOpen = undefined } = $$props;
	let { hideToolbarOnOpen = undefined } = $$props;
	let { hideStatusbarOnOpen = undefined } = $$props;
	let { scrollableEl = undefined } = $$props;
	let { swipeToClose = undefined } = $$props;
	let { closeByBackdropClick = undefined } = $$props;
	let { backdrop = undefined } = $$props;
	let { backdropEl = undefined } = $$props;
	let { noShadow = false } = $$props;
	let { noBorder = false } = $$props;
	let { padding = true } = $$props;
	let el;

	/* eslint-enable no-undef */
	function open() {
		app.f7.card.open(el);
	}

	function close() {
		app.f7.card.close(el);
	}

	let initialWatched = false;

	function watchOpened(openedPassed) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (openedPassed) {
			open();
		} else {
			close();
		}
	}

	function onBeforeOpen(cardEl, prevent) {
		if (cardEl !== el) return;
		emit('cardBeforeOpen', [el, prevent]);
	}

	function onOpen(cardEl) {
		if (cardEl !== el) return;
		emit('cardOpen', [el]);
		$$invalidate(20, expandableOpened = true);
	}

	function onOpened(cardEl, pageEl) {
		if (cardEl !== el) return;
		emit('cardOpened', [el, pageEl]);
	}

	function onClose(cardEl) {
		if (cardEl !== el) return;
		emit('cardClose', [el]);
	}

	function onClosed(cardEl, pageEl) {
		if (cardEl !== el) return;
		emit('cardClosed', [el, pageEl]);
		$$invalidate(20, expandableOpened = false);
	}

	onMount(() => {
		if (!expandable) return;

		f7ready(() => {
			app.f7.on('cardBeforeOpen', onBeforeOpen);
			app.f7.on('cardOpen', onOpen);
			app.f7.on('cardOpened', onOpened);
			app.f7.on('cardClose', onClose);
			app.f7.on('cardClosed', onClosed);

			if (expandable && expandableOpened && el) {
				app.f7.card.open(el, false);
			}
		});
	});

	onDestroy(() => {
		if (!expandable) return;
		if (!app.f7 || !el) return;
		app.f7.off('cardBeforeOpen', onBeforeOpen);
		app.f7.off('cardOpen', onOpen);
		app.f7.off('cardOpened', onOpened);
		app.f7.off('cardClose', onClose);
		app.f7.off('cardClosed', onClosed);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(14, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(42, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(0, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(21, className = $$new_props.class);
		if ('title' in $$new_props) $$invalidate(1, title = $$new_props.title);
		if ('content' in $$new_props) $$invalidate(2, content = $$new_props.content);
		if ('footer' in $$new_props) $$invalidate(3, footer = $$new_props.footer);
		if ('outline' in $$new_props) $$invalidate(22, outline = $$new_props.outline);
		if ('expandable' in $$new_props) $$invalidate(23, expandable = $$new_props.expandable);
		if ('expandableAnimateWidth' in $$new_props) $$invalidate(24, expandableAnimateWidth = $$new_props.expandableAnimateWidth);
		if ('expandableOpened' in $$new_props) $$invalidate(20, expandableOpened = $$new_props.expandableOpened);
		if ('animate' in $$new_props) $$invalidate(4, animate = $$new_props.animate);
		if ('hideNavbarOnOpen' in $$new_props) $$invalidate(5, hideNavbarOnOpen = $$new_props.hideNavbarOnOpen);
		if ('hideToolbarOnOpen' in $$new_props) $$invalidate(6, hideToolbarOnOpen = $$new_props.hideToolbarOnOpen);
		if ('hideStatusbarOnOpen' in $$new_props) $$invalidate(7, hideStatusbarOnOpen = $$new_props.hideStatusbarOnOpen);
		if ('scrollableEl' in $$new_props) $$invalidate(8, scrollableEl = $$new_props.scrollableEl);
		if ('swipeToClose' in $$new_props) $$invalidate(9, swipeToClose = $$new_props.swipeToClose);
		if ('closeByBackdropClick' in $$new_props) $$invalidate(10, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ('backdrop' in $$new_props) $$invalidate(11, backdrop = $$new_props.backdrop);
		if ('backdropEl' in $$new_props) $$invalidate(12, backdropEl = $$new_props.backdropEl);
		if ('noShadow' in $$new_props) $$invalidate(25, noShadow = $$new_props.noShadow);
		if ('noBorder' in $$new_props) $$invalidate(26, noBorder = $$new_props.noBorder);
		if ('padding' in $$new_props) $$invalidate(13, padding = $$new_props.padding);
		if ('$$scope' in $$new_props) $$invalidate(29, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(18, classes = classNames(
			className,
			{
				'card-outline': outline,
				'card-expandable': expandable,
				'card-expandable-animate-width': expandableAnimateWidth,
				'no-shadow': noShadow,
				'no-border': noBorder
			},
			colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*expandableOpened*/ 1048576) {
			$: watchOpened(expandableOpened);
		}
	};

	$: $$invalidate(17, hasHeaderSlots = $$slots.header);
	$: $$invalidate(16, hasContentSlots = $$slots.content);
	$: $$invalidate(15, hasFooterSlots = $$slots.footer);
	$$props = exclude_internal_props($$props);

	return [
		lec,
		title,
		content,
		footer,
		animate,
		hideNavbarOnOpen,
		hideToolbarOnOpen,
		hideStatusbarOnOpen,
		scrollableEl,
		swipeToClose,
		closeByBackdropClick,
		backdrop,
		backdropEl,
		padding,
		el,
		hasFooterSlots,
		hasContentSlots,
		hasHeaderSlots,
		classes,
		$$restProps,
		expandableOpened,
		className,
		outline,
		expandable,
		expandableAnimateWidth,
		noShadow,
		noBorder,
		slots,
		div_binding,
		$$scope
	];
}

class Card extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$V,
			create_fragment$11,
			safe_not_equal,
			{
				lec: 0,
				class: 21,
				title: 1,
				content: 2,
				footer: 3,
				outline: 22,
				expandable: 23,
				expandableAnimateWidth: 24,
				expandableOpened: 20,
				animate: 4,
				hideNavbarOnOpen: 5,
				hideToolbarOnOpen: 6,
				hideStatusbarOnOpen: 7,
				scrollableEl: 8,
				swipeToClose: 9,
				closeByBackdropClick: 10,
				backdrop: 11,
				backdropEl: 12,
				noShadow: 25,
				noBorder: 26,
				padding: 13
			},
			null,
			[-1, -1]
		);
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/checkbox.liquivelte generated by Svelte v3.50.0 */

function create_fragment$10(ctx) {
	let label;
	let input;
	let input_value_value;
	let t0;
	let i;
	let t1;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
	let label_levels = [{ class: /*classes*/ ctx[6] }, restProps(/*$$restProps*/ ctx[8])];
	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	return {
		c() {
			label = element("label");
			input = element("input");
			t0 = space();
			i = element("i");
			t1 = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			label = claim_element(nodes, "LABEL", { class: true });
			var label_nodes = children(label);
			input = claim_element(label_nodes, "INPUT", { type: true, name: true });
			t0 = claim_space(label_nodes);
			i = claim_element(label_nodes, "I", { class: true });
			children(i).forEach(detach);
			t1 = claim_space(label_nodes);
			if (default_slot) default_slot.l(label_nodes);
			label_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(input, "type", "checkbox");
			attr(input, "name", /*name*/ ctx[1]);

			input.value = input_value_value = typeof /*value*/ ctx[2] === 'undefined'
			? ''
			: /*value*/ ctx[2];

			input.disabled = /*disabled*/ ctx[3];
			input.readOnly = /*readonly*/ ctx[4];
			input.checked = /*checked*/ ctx[0];
			attr(i, "class", "icon-checkbox");
			set_attributes(label, label_data);
		},
		m(target, anchor) {
			insert_hydration(target, label, anchor);
			append_hydration(label, input);
			/*input_binding*/ ctx[14](input);
			append_hydration(label, t0);
			append_hydration(label, i);
			append_hydration(label, t1);

			if (default_slot) {
				default_slot.m(label, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(input, "change", /*onChange*/ ctx[7]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*name*/ 2) {
				attr(input, "name", /*name*/ ctx[1]);
			}

			if (!current || dirty & /*value*/ 4 && input_value_value !== (input_value_value = typeof /*value*/ ctx[2] === 'undefined'
			? ''
			: /*value*/ ctx[2])) {
				input.value = input_value_value;
			}

			if (!current || dirty & /*disabled*/ 8) {
				input.disabled = /*disabled*/ ctx[3];
			}

			if (!current || dirty & /*readonly*/ 16) {
				input.readOnly = /*readonly*/ ctx[4];
			}

			if (!current || dirty & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
						null
					);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				(!current || dirty & /*classes*/ 64) && { class: /*classes*/ ctx[6] },
				dirty & /*$$restProps*/ 256 && restProps(/*$$restProps*/ ctx[8])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label);
			/*input_binding*/ ctx[14](null);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

let index$12 = 0;

function instance$U($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class","checked","indeterminate","name","value","disabled","readonly"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { checked = undefined } = $$props;
	let { indeterminate = undefined } = $$props;
	let { name = undefined } = $$props;
	let { value = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let inputEl;

	function onChange(event) {
		emit('change', [event]);
		$$invalidate(0, checked = event.target.checked);
	}

	onMount(() => {
		if (indeterminate && inputEl) {
			$$invalidate(5, inputEl.indeterminate = true, inputEl);
		}
	});

	afterUpdate(() => {
		if (inputEl) {
			$$invalidate(5, inputEl.indeterminate = indeterminate, inputEl);
		}
	});

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(5, inputEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(9, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(10, className = $$new_props.class);
		if ('checked' in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ('indeterminate' in $$new_props) $$invalidate(11, indeterminate = $$new_props.indeterminate);
		if ('name' in $$new_props) $$invalidate(1, name = $$new_props.name);
		if ('value' in $$new_props) $$invalidate(2, value = $$new_props.value);
		if ('disabled' in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
		if ('readonly' in $$new_props) $$invalidate(4, readonly = $$new_props.readonly);
		if ('$$scope' in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(6, classes = classNames(className, { checkbox: true, disabled }, colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);

	return [
		checked,
		name,
		value,
		disabled,
		readonly,
		inputEl,
		classes,
		onChange,
		$$restProps,
		lec,
		className,
		indeterminate,
		$$scope,
		slots,
		input_binding
	];
}

class Checkbox extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$U, create_fragment$10, safe_not_equal, {
			lec: 9,
			class: 10,
			checked: 0,
			indeterminate: 11,
			name: 1,
			value: 2,
			disabled: 3,
			readonly: 4
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/chip.liquivelte generated by Svelte v3.50.0 */
const get_text_slot_changes$4 = dirty => ({});
const get_text_slot_context$4 = ctx => ({});
const get_media_slot_changes$3 = dirty => ({});
const get_media_slot_context$3 = ctx => ({});

// (74:2) {#if media || hasMediaSlots || icon }
function create_if_block_2$f(ctx) {
	let div;
	let t0;
	let t1_value = plainText(/*media*/ ctx[1]) + "";
	let t1;
	let t2;
	let current;
	let if_block = /*icon*/ ctx[7] && create_if_block_3$d(ctx);
	const media_slot_template = /*#slots*/ ctx[21].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[20], get_media_slot_context$3);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			if (media_slot) media_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t0 = claim_space(div_nodes);
			t1 = claim_text(div_nodes, t1_value);
			t2 = claim_space(div_nodes);
			if (media_slot) media_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", /*mediaClasses*/ ctx[11]);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t0);
			append_hydration(div, t1);
			append_hydration(div, t2);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*icon*/ 128) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_3$d(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if ((!current || dirty & /*media*/ 2) && t1_value !== (t1_value = plainText(/*media*/ ctx[1]) + "")) set_data(t1, t1_value);

			if (media_slot) {
				if (media_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						media_slot,
						media_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[20], dirty, get_media_slot_changes$3),
						get_media_slot_context$3
					);
				}
			}

			if (!current || dirty & /*mediaClasses*/ 2048) {
				attr(div, "class", /*mediaClasses*/ ctx[11]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(media_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(media_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};
}

// (76:6) {#if icon }
function create_if_block_3$d(ctx) {
	let useicon;
	let current;

	useicon = new Use_icon({
			props: {
				icon: /*icon*/ ctx[7],
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(useicon.$$.fragment);
		},
		l(nodes) {
			claim_component(useicon.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(useicon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const useicon_changes = {};
			if (dirty & /*icon*/ 128) useicon_changes.icon = /*icon*/ ctx[7];
			if (dirty & /*lec*/ 1) useicon_changes.lec = /*lec*/ ctx[0];
			useicon.$set(useicon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(useicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(useicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(useicon, detaching);
		}
	};
}

// (83:2) {#if text || hasTextSlots || hasDefaultSlots }
function create_if_block_1$k(ctx) {
	let div;
	let t0_value = plainText(/*text*/ ctx[2]) + "";
	let t0;
	let t1;
	let t2;
	let current;
	const text_slot_template = /*#slots*/ ctx[21].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[20], get_text_slot_context$4);
	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			t2 = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (text_slot) text_slot.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "chip-label");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			append_hydration(div, t2);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*text*/ 4) && t0_value !== (t0_value = plainText(/*text*/ ctx[2]) + "")) set_data(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						text_slot,
						text_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[20], dirty, get_text_slot_changes$4),
						get_text_slot_context$4
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(text_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(text_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (text_slot) text_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (90:2) {#if deleteable }
function create_if_block$w(ctx) {
	let a;
	let mounted;
	let dispose;

	return {
		c() {
			a = element("a");
			this.h();
		},
		l(nodes) {
			a = claim_element(nodes, "A", { class: true });
			children(a).forEach(detach);
			this.h();
		},
		h() {
			attr(a, "class", "chip-delete");
		},
		m(target, anchor) {
			insert_hydration(target, a, anchor);

			if (!mounted) {
				dispose = listen(a, "click", /*onDeleteClick*/ ctx[14]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(a);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$$(ctx) {
	let div;
	let t0;
	let t1;
	let div_class_value;
	let useTooltip_action;
	let current;
	let mounted;
	let dispose;
	let if_block0 = (/*media*/ ctx[1] || /*hasMediaSlots*/ ctx[10] || /*icon*/ ctx[7]) && create_if_block_2$f(ctx);
	let if_block1 = (/*text*/ ctx[2] || /*hasTextSlots*/ ctx[9] || /*hasDefaultSlots*/ ctx[8]) && create_if_block_1$k(ctx);
	let if_block2 = /*deleteable*/ ctx[3] && create_if_block$w(ctx);

	let div_levels = [
		{
			class: div_class_value = "chip " + /*classes*/ ctx[12]
		},
		restProps(/*$$restProps*/ ctx[15])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block2) if_block2.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t1);
			if (if_block2) if_block2.m(div, null);
			/*div_binding*/ ctx[22](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "click", /*onClick*/ ctx[13]),
					action_destroyer(useTooltip_action = useTooltip.call(null, div, {
						tooltip: /*tooltip*/ ctx[4],
						tooltipTrigger: /*tooltipTrigger*/ ctx[5]
					}))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*media*/ ctx[1] || /*hasMediaSlots*/ ctx[10] || /*icon*/ ctx[7]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*media, hasMediaSlots, icon*/ 1154) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$f(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*text*/ ctx[2] || /*hasTextSlots*/ ctx[9] || /*hasDefaultSlots*/ ctx[8]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*text, hasTextSlots, hasDefaultSlots*/ 772) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$k(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*deleteable*/ ctx[3]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block$w(ctx);
					if_block2.c();
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 4096 && div_class_value !== (div_class_value = "chip " + /*classes*/ ctx[12])) && { class: div_class_value },
				dirty & /*$$restProps*/ 32768 && restProps(/*$$restProps*/ ctx[15])
			]));

			if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/ 48) useTooltip_action.update.call(null, {
				tooltip: /*tooltip*/ ctx[4],
				tooltipTrigger: /*tooltipTrigger*/ ctx[5]
			});
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			/*div_binding*/ ctx[22](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

let index$11 = 0;

function instance$T($$self, $$props, $$invalidate) {
	let classes;
	let mediaClasses;
	let hasMediaSlots;
	let hasTextSlots;
	let hasDefaultSlots;
	let icon;

	const omit_props_names = [
		"lec","class","media","text","deleteable","mediaBgColor","mediaTextColor","outline","tooltip","tooltipTrigger"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { media = undefined } = $$props;
	let { text = undefined } = $$props;
	let { deleteable = undefined } = $$props;
	let { mediaBgColor = undefined } = $$props;
	let { mediaTextColor = undefined } = $$props;
	let { outline = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let el;

	function onClick(e) {
		emit('click', [e]);
	}

	function onDeleteClick(e) {
		emit('delete', [e]);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(6, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(25, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(0, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(16, className = $$new_props.class);
		if ('media' in $$new_props) $$invalidate(1, media = $$new_props.media);
		if ('text' in $$new_props) $$invalidate(2, text = $$new_props.text);
		if ('deleteable' in $$new_props) $$invalidate(3, deleteable = $$new_props.deleteable);
		if ('mediaBgColor' in $$new_props) $$invalidate(17, mediaBgColor = $$new_props.mediaBgColor);
		if ('mediaTextColor' in $$new_props) $$invalidate(18, mediaTextColor = $$new_props.mediaTextColor);
		if ('outline' in $$new_props) $$invalidate(19, outline = $$new_props.outline);
		if ('tooltip' in $$new_props) $$invalidate(4, tooltip = $$new_props.tooltip);
		if ('tooltipTrigger' in $$new_props) $$invalidate(5, tooltipTrigger = $$new_props.tooltipTrigger);
		if ('$$scope' in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(12, classes = classNames(className, { 'chip-outline': outline }, colorClasses($$props)));

		if ($$self.$$.dirty & /*mediaTextColor, mediaBgColor*/ 393216) {
			$: $$invalidate(11, mediaClasses = classNames('chip-media', mediaTextColor && `text-color-${mediaTextColor}`, mediaBgColor && `bg-color-${mediaBgColor}`));
		}

		$: $$invalidate(7, icon = useIcon($$props));
	};

	$: $$invalidate(10, hasMediaSlots = $$slots.media);

	// eslint-disable-next-line
	$: $$invalidate(9, hasTextSlots = $$slots.text);

	// eslint-disable-next-line
	$: $$invalidate(8, hasDefaultSlots = $$slots.default);

	$$props = exclude_internal_props($$props);

	return [
		lec,
		media,
		text,
		deleteable,
		tooltip,
		tooltipTrigger,
		el,
		icon,
		hasDefaultSlots,
		hasTextSlots,
		hasMediaSlots,
		mediaClasses,
		classes,
		onClick,
		onDeleteClick,
		$$restProps,
		className,
		mediaBgColor,
		mediaTextColor,
		outline,
		$$scope,
		slots,
		div_binding
	];
}

class Chip extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$T, create_fragment$$, safe_not_equal, {
			lec: 0,
			class: 16,
			media: 1,
			text: 2,
			deleteable: 3,
			mediaBgColor: 17,
			mediaTextColor: 18,
			outline: 19,
			tooltip: 4,
			tooltipTrigger: 5
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/col.liquivelte generated by Svelte v3.50.0 */

function create_if_block_2$e(ctx) {
	let span;
	let t;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);
	let if_block = /*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2] && create_if_block_3$c(ctx);
	let span_levels = [{ class: /*classes*/ ctx[4] }, restProps(/*$$restProps*/ ctx[6])];
	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	return {
		c() {
			span = element("span");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			if (default_slot) default_slot.l(span_nodes);
			t = claim_space(span_nodes);
			if (if_block) if_block.l(span_nodes);
			span_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(span, span_data);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			append_hydration(span, t);
			if (if_block) if_block.m(span, null);
			/*span_binding*/ ctx[20](span);
			current = true;

			if (!mounted) {
				dispose = listen(span, "click", /*onClick*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[17],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
						null
					);
				}
			}

			if (/*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2]) {
				if (if_block) {
					
				} else {
					if_block = create_if_block_3$c(ctx);
					if_block.c();
					if_block.m(span, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			/*span_binding*/ ctx[20](null);
			mounted = false;
			dispose();
		}
	};
}

// (68:0) {#if tag === 'div'}
function create_if_block$v(ctx) {
	let div;
	let t;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);
	let if_block = /*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2] && create_if_block_1$j(ctx);
	let div_levels = [{ class: /*classes*/ ctx[4] }, restProps(/*$$restProps*/ ctx[6])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			t = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_hydration(div, t);
			if (if_block) if_block.m(div, null);
			/*div_binding*/ ctx[19](div);
			current = true;

			if (!mounted) {
				dispose = listen(div, "click", /*onClick*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[17],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
						null
					);
				}
			}

			if (/*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2]) {
				if (if_block) {
					
				} else {
					if_block = create_if_block_1$j(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			/*div_binding*/ ctx[19](null);
			mounted = false;
			dispose();
		}
	};
}

// (76:4) {#if resizable && resizableHandler}
function create_if_block_3$c(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "resize-handler");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (71:4) {#if resizable && resizableHandler}
function create_if_block_1$j(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "resize-handler");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

function create_fragment$_(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$v, create_if_block_2$e];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tag*/ ctx[0] === 'div') return 0;
		if (/*tag*/ ctx[0] === 'span') return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, -1))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

let index$10 = 0;

function instance$S($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"lec","class","tag","width","xsmall","small","medium","large","xlarge","resizable","resizableFixed","resizableAbsolute","resizableHandler"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { tag = 'div' } = $$props;
	let { width = 'auto' } = $$props;
	let { xsmall = undefined } = $$props;
	let { small = undefined } = $$props;
	let { medium = undefined } = $$props;
	let { large = undefined } = $$props;
	let { xlarge = undefined } = $$props;
	let { resizable = false } = $$props;
	let { resizableFixed = false } = $$props;
	let { resizableAbsolute = false } = $$props;
	let { resizableHandler = true } = $$props;
	let el;

	function onClick() {
		emit('click');
	}

	function onResize(targetEl) {
		if (el !== targetEl) return;
		emit('gridResize');
	}

	onMount(() => {
		f7ready(() => {
			app.f7.on('gridResize', onResize);
		});
	});

	onDestroy(() => {
		if (!app.f7) return;
		app.f7.off('gridResize', onResize);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	function span_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(7, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ('tag' in $$new_props) $$invalidate(0, tag = $$new_props.tag);
		if ('width' in $$new_props) $$invalidate(9, width = $$new_props.width);
		if ('xsmall' in $$new_props) $$invalidate(10, xsmall = $$new_props.xsmall);
		if ('small' in $$new_props) $$invalidate(11, small = $$new_props.small);
		if ('medium' in $$new_props) $$invalidate(12, medium = $$new_props.medium);
		if ('large' in $$new_props) $$invalidate(13, large = $$new_props.large);
		if ('xlarge' in $$new_props) $$invalidate(14, xlarge = $$new_props.xlarge);
		if ('resizable' in $$new_props) $$invalidate(1, resizable = $$new_props.resizable);
		if ('resizableFixed' in $$new_props) $$invalidate(15, resizableFixed = $$new_props.resizableFixed);
		if ('resizableAbsolute' in $$new_props) $$invalidate(16, resizableAbsolute = $$new_props.resizableAbsolute);
		if ('resizableHandler' in $$new_props) $$invalidate(2, resizableHandler = $$new_props.resizableHandler);
		if ('$$scope' in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(4, classes = classNames(
			className,
			{
				col: width === 'auto',
				[`col-${width}`]: width !== 'auto',
				[`xsmall-${xsmall}`]: xsmall,
				[`small-${small}`]: small,
				[`medium-${medium}`]: medium,
				[`large-${large}`]: large,
				[`xlarge-${xlarge}`]: xlarge,
				resizable,
				'resizable-fixed': resizableFixed,
				'resizable-absolute': resizableAbsolute
			},
			colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		tag,
		resizable,
		resizableHandler,
		el,
		classes,
		onClick,
		$$restProps,
		lec,
		className,
		width,
		xsmall,
		small,
		medium,
		large,
		xlarge,
		resizableFixed,
		resizableAbsolute,
		$$scope,
		slots,
		div_binding,
		span_binding
	];
}

class Col extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$S, create_fragment$_, safe_not_equal, {
			lec: 7,
			class: 8,
			tag: 0,
			width: 9,
			xsmall: 10,
			small: 11,
			medium: 12,
			large: 13,
			xlarge: 14,
			resizable: 1,
			resizableFixed: 15,
			resizableAbsolute: 16,
			resizableHandler: 2
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/fab-backdrop.liquivelte generated by Svelte v3.50.0 */

function create_fragment$Z(ctx) {
	let div;

	let div_levels = [
		{ class: /*classes*/ ctx[1] },
		{ "data-f7-slot": /*f7Slot*/ ctx[0] },
		restProps(/*$$restProps*/ ctx[2])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true, "data-f7-slot": true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
		},
		p(ctx, [dirty]) {
			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*classes*/ 2 && { class: /*classes*/ ctx[1] },
				dirty & /*f7Slot*/ 1 && { "data-f7-slot": /*f7Slot*/ ctx[0] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

let index$$ = 0;

function instance$R($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class","f7Slot"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let { f7Slot = 'fixed' } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(3, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('f7Slot' in $$new_props) $$invalidate(0, f7Slot = $$new_props.f7Slot);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 16) {
			$: $$invalidate(1, classes = classNames(className, 'fab-backdrop'));
		}
	};

	return [f7Slot, classes, $$restProps, lec, className];
}

class Fab_backdrop extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$R, create_fragment$Z, safe_not_equal, { lec: 3, class: 4, f7Slot: 0 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/fab-button.liquivelte generated by Svelte v3.50.0 */

function create_if_block$u(ctx) {
	let span;
	let t_value = plainText(/*label*/ ctx[0]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "fab-label");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 1 && t_value !== (t_value = plainText(/*label*/ ctx[0]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

function create_fragment$Y(ctx) {
	let a;
	let t;
	let useTooltip_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	let if_block = typeof /*label*/ ctx[0] !== 'undefined' && create_if_block$u(ctx);

	let a_levels = [
		{ target: /*target*/ ctx[1] },
		{ class: /*classes*/ ctx[5] },
		restProps(/*$$restProps*/ ctx[7])
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = element("a");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l(nodes) {
			a = claim_element(nodes, "A", { target: true, class: true });
			var a_nodes = children(a);
			if (default_slot) default_slot.l(a_nodes);
			t = claim_space(a_nodes);
			if (if_block) if_block.l(a_nodes);
			a_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(a, a_data);
		},
		m(target, anchor) {
			insert_hydration(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			append_hydration(a, t);
			if (if_block) if_block.m(a, null);
			/*a_binding*/ ctx[13](a);
			current = true;

			if (!mounted) {
				dispose = [
					listen(a, "click", /*onClick*/ ctx[6]),
					action_destroyer(useTooltip_action = useTooltip.call(null, a, {
						tooltip: /*tooltip*/ ctx[2],
						tooltipTrigger: /*tooltipTrigger*/ ctx[3]
					}))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}

			if (typeof /*label*/ ctx[0] !== 'undefined') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$u(ctx);
					if_block.c();
					if_block.m(a, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*target*/ 2) && { target: /*target*/ ctx[1] },
				(!current || dirty & /*classes*/ 32) && { class: /*classes*/ ctx[5] },
				dirty & /*$$restProps*/ 128 && restProps(/*$$restProps*/ ctx[7])
			]));

			if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/ 12) useTooltip_action.update.call(null, {
				tooltip: /*tooltip*/ ctx[2],
				tooltipTrigger: /*tooltipTrigger*/ ctx[3]
			});
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			/*a_binding*/ ctx[13](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

let index$_ = 0;

function instance$Q($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class","fabClose","label","target","tooltip","tooltipTrigger"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { fabClose = false } = $$props;
	let { label = undefined } = $$props;
	let { target = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let el;

	function onClick() {
		emit('click');
	}

	function a_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(4, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(16, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(8, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(9, className = $$new_props.class);
		if ('fabClose' in $$new_props) $$invalidate(10, fabClose = $$new_props.fabClose);
		if ('label' in $$new_props) $$invalidate(0, label = $$new_props.label);
		if ('target' in $$new_props) $$invalidate(1, target = $$new_props.target);
		if ('tooltip' in $$new_props) $$invalidate(2, tooltip = $$new_props.tooltip);
		if ('tooltipTrigger' in $$new_props) $$invalidate(3, tooltipTrigger = $$new_props.tooltipTrigger);
		if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(5, classes = classNames(
			className,
			{
				'fab-close': fabClose,
				'fab-label-button': label
			},
			colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		label,
		target,
		tooltip,
		tooltipTrigger,
		el,
		classes,
		onClick,
		$$restProps,
		lec,
		className,
		fabClose,
		$$scope,
		slots,
		a_binding
	];
}

class Fab_button extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$Q, create_fragment$Y, safe_not_equal, {
			lec: 8,
			class: 9,
			fabClose: 10,
			label: 0,
			target: 1,
			tooltip: 2,
			tooltipTrigger: 3
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/fab-buttons.liquivelte generated by Svelte v3.50.0 */

function create_fragment$X(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$Z = 0;

function instance$P($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class","position"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let { position = 'top' } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('position' in $$new_props) $$invalidate(4, position = $$new_props.position);
		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'fab-buttons', `fab-buttons-${position}`, colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, position, $$scope, slots];
}

class Fab_buttons extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$P, create_fragment$X, safe_not_equal, { lec: 2, class: 3, position: 4 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/fab.liquivelte generated by Svelte v3.50.0 */
const get_root_slot_changes$4 = dirty => ({});
const get_root_slot_context$4 = ctx => ({});
const get_link_slot_changes = dirty => ({});
const get_link_slot_context = ctx => ({});
const get_text_slot_changes$3 = dirty => ({});
const get_text_slot_context$3 = ctx => ({});

// (86:4) {#if typeof text !== 'undefined' || hasTextSlots}
function create_if_block$t(ctx) {
	let div;
	let t0_value = plainText(/*text*/ ctx[2]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*#slots*/ ctx[19].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[18], get_text_slot_context$3);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (text_slot) text_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "fab-text");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			/*div_binding*/ ctx[20](div);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*text*/ 4) && t0_value !== (t0_value = plainText(/*text*/ ctx[2]) + "")) set_data(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
					update_slot_base(
						text_slot,
						text_slot_template,
						ctx,
						/*$$scope*/ ctx[18],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[18], dirty, get_text_slot_changes$3),
						get_text_slot_context$3
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (text_slot) text_slot.d(detaching);
			/*div_binding*/ ctx[20](null);
		}
	};
}

function create_fragment$W(ctx) {
	let div;
	let a;
	let t0;
	let t1;
	let useTooltip_action;
	let t2;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[19].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);
	let if_block = (typeof /*text*/ ctx[2] !== 'undefined' || /*hasTextSlots*/ ctx[7]) && create_if_block$t(ctx);
	const link_slot_template = /*#slots*/ ctx[19].link;
	const link_slot = create_slot(link_slot_template, ctx, /*$$scope*/ ctx[18], get_link_slot_context);
	const root_slot_template = /*#slots*/ ctx[19].root;
	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[18], get_root_slot_context$4);

	let div_levels = [
		{ class: /*classes*/ ctx[10] },
		{ "data-morph-to": /*morphTo*/ ctx[0] },
		{ "data-f7-slot": /*f7Slot*/ ctx[5] },
		restProps(/*$$restProps*/ ctx[13])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			a = element("a");
			if (default_slot) default_slot.c();
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			if (link_slot) link_slot.c();
			t2 = space();
			if (root_slot) root_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {
				class: true,
				"data-morph-to": true,
				"data-f7-slot": true
			});

			var div_nodes = children(div);
			a = claim_element(div_nodes, "A", { target: true, href: true });
			var a_nodes = children(a);
			if (default_slot) default_slot.l(a_nodes);
			t0 = claim_space(a_nodes);
			if (if_block) if_block.l(a_nodes);
			t1 = claim_space(a_nodes);
			if (link_slot) link_slot.l(a_nodes);
			a_nodes.forEach(detach);
			t2 = claim_space(div_nodes);
			if (root_slot) root_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(a, "target", /*target*/ ctx[1]);
			attr(a, "href", /*hrefComputed*/ ctx[11]);
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, a);

			if (default_slot) {
				default_slot.m(a, null);
			}

			append_hydration(a, t0);
			if (if_block) if_block.m(a, null);
			append_hydration(a, t1);

			if (link_slot) {
				link_slot.m(a, null);
			}

			/*a_binding*/ ctx[21](a);
			append_hydration(div, t2);

			if (root_slot) {
				root_slot.m(div, null);
			}

			/*div_binding_1*/ ctx[22](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen(a, "click", /*onClick*/ ctx[12]),
					action_destroyer(useTooltip_action = useTooltip.call(null, a, {
						tooltip: /*tooltip*/ ctx[3],
						tooltipTrigger: /*tooltipTrigger*/ ctx[4]
					}))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[18],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, null),
						null
					);
				}
			}

			if (typeof /*text*/ ctx[2] !== 'undefined' || /*hasTextSlots*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*text, hasTextSlots*/ 132) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$t(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(a, t1);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (link_slot) {
				if (link_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
					update_slot_base(
						link_slot,
						link_slot_template,
						ctx,
						/*$$scope*/ ctx[18],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
						: get_slot_changes(link_slot_template, /*$$scope*/ ctx[18], dirty, get_link_slot_changes),
						get_link_slot_context
					);
				}
			}

			if (!current || dirty & /*target*/ 2) {
				attr(a, "target", /*target*/ ctx[1]);
			}

			if (!current || dirty & /*hrefComputed*/ 2048) {
				attr(a, "href", /*hrefComputed*/ ctx[11]);
			}

			if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/ 24) useTooltip_action.update.call(null, {
				tooltip: /*tooltip*/ ctx[3],
				tooltipTrigger: /*tooltipTrigger*/ ctx[4]
			});

			if (root_slot) {
				if (root_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
					update_slot_base(
						root_slot,
						root_slot_template,
						ctx,
						/*$$scope*/ ctx[18],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
						: get_slot_changes(root_slot_template, /*$$scope*/ ctx[18], dirty, get_root_slot_changes$4),
						get_root_slot_context$4
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1024) && { class: /*classes*/ ctx[10] },
				(!current || dirty & /*morphTo*/ 1) && { "data-morph-to": /*morphTo*/ ctx[0] },
				(!current || dirty & /*f7Slot*/ 32) && { "data-f7-slot": /*f7Slot*/ ctx[5] },
				dirty & /*$$restProps*/ 8192 && restProps(/*$$restProps*/ ctx[13])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block);
			transition_in(link_slot, local);
			transition_in(root_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(if_block);
			transition_out(link_slot, local);
			transition_out(root_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			if (link_slot) link_slot.d(detaching);
			/*a_binding*/ ctx[21](null);
			if (root_slot) root_slot.d(detaching);
			/*div_binding_1*/ ctx[22](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

let index$Y = 0;

function instance$O($$self, $$props, $$invalidate) {
	let hrefComputed;
	let hasTextSlots;
	let classes;

	const omit_props_names = [
		"lec","class","morphTo","href","target","text","position","tooltip","tooltipTrigger","f7Slot"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { morphTo = undefined } = $$props;
	let { href = undefined } = $$props;
	let { target = undefined } = $$props;
	let { text = undefined } = $$props;
	let { position = 'right-bottom' } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let { f7Slot = 'fixed' } = $$props;
	let el;
	let linkEl;
	let textEl;

	function onClick() {
		emit('click');
	}

	onMount(() => {
		f7ready(() => {
			const dom7 = app.f7.$;
			const rootEls = dom7(linkEl).children('.fab-buttons');

			if (rootEls.length) {
				dom7(el).append(rootEls);
			}
		});
	});

	afterUpdate(() => {
		if (!app.f7) return;
		const dom7 = app.f7.$;
		const rootEls = dom7(linkEl).children('.fab-buttons');

		if (rootEls.length) {
			dom7(el).append(rootEls);
		}
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			textEl = $$value;
			$$invalidate(6, textEl);
		});
	}

	function a_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			linkEl = $$value;
			$$invalidate(9, linkEl);
		});
	}

	function div_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(8, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(25, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(14, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(15, className = $$new_props.class);
		if ('morphTo' in $$new_props) $$invalidate(0, morphTo = $$new_props.morphTo);
		if ('href' in $$new_props) $$invalidate(16, href = $$new_props.href);
		if ('target' in $$new_props) $$invalidate(1, target = $$new_props.target);
		if ('text' in $$new_props) $$invalidate(2, text = $$new_props.text);
		if ('position' in $$new_props) $$invalidate(17, position = $$new_props.position);
		if ('tooltip' in $$new_props) $$invalidate(3, tooltip = $$new_props.tooltip);
		if ('tooltipTrigger' in $$new_props) $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
		if ('f7Slot' in $$new_props) $$invalidate(5, f7Slot = $$new_props.f7Slot);
		if ('$$scope' in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*href*/ 65536) {
			$: $$invalidate(11, hrefComputed = href === true ? '#' : href || undefined);
		}

		$: $$invalidate(10, classes = classNames(
			className,
			'fab',
			`fab-${position}`,
			{
				'fab-morph': morphTo,
				'fab-extended': text || hasTextSlots || typeof textEl !== 'undefined'
			},
			colorClasses($$props)
		));
	};

	$: $$invalidate(7, hasTextSlots = $$slots.text);
	$$props = exclude_internal_props($$props);

	return [
		morphTo,
		target,
		text,
		tooltip,
		tooltipTrigger,
		f7Slot,
		textEl,
		hasTextSlots,
		el,
		linkEl,
		classes,
		hrefComputed,
		onClick,
		$$restProps,
		lec,
		className,
		href,
		position,
		$$scope,
		slots,
		div_binding,
		a_binding,
		div_binding_1
	];
}

class Fab extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$O, create_fragment$W, safe_not_equal, {
			lec: 14,
			class: 15,
			morphTo: 0,
			href: 16,
			target: 1,
			text: 2,
			position: 17,
			tooltip: 3,
			tooltipTrigger: 4,
			f7Slot: 5
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/gauge.liquivelte generated by Svelte v3.50.0 */

function create_if_block_4$7(ctx) {
	let path0;
	let path0_d_value;
	let path0_fill_value;
	let path1;
	let path1_d_value;
	let path1_stroke_dasharray_value;
	let path1_stroke_dashoffset_value;
	let path1_fill_value;

	return {
		c() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l(nodes) {
			path0 = claim_svg_element(nodes, "path", {
				class: true,
				d: true,
				stroke: true,
				"stroke-width": true,
				fill: true
			});

			children(path0).forEach(detach);

			path1 = claim_svg_element(nodes, "path", {
				class: true,
				d: true,
				stroke: true,
				"stroke-width": true,
				"stroke-dasharray": true,
				"stroke-dashoffset": true,
				fill: true
			});

			children(path1).forEach(detach);
			this.h();
		},
		h() {
			attr(path0, "class", "gauge-back-semi");
			attr(path0, "d", path0_d_value = `M${/*size*/ ctx[0] - /*borderWidth*/ ctx[4] / 2},${/*size*/ ctx[0] / 2} a1,1 0 0,0 -${/*size*/ ctx[0] - /*borderWidth*/ ctx[4]},0`);
			attr(path0, "stroke", /*borderBgColor*/ ctx[2]);
			attr(path0, "stroke-width", /*borderWidth*/ ctx[4]);
			attr(path0, "fill", path0_fill_value = /*bgColor*/ ctx[1] || 'none');
			attr(path1, "class", "gauge-front-semi");
			attr(path1, "d", path1_d_value = `M${/*size*/ ctx[0] - /*borderWidth*/ ctx[4] / 2},${/*size*/ ctx[0] / 2} a1,1 0 0,0 -${/*size*/ ctx[0] - /*borderWidth*/ ctx[4]},0`);
			attr(path1, "stroke", /*borderColor*/ ctx[3]);
			attr(path1, "stroke-width", /*borderWidth*/ ctx[4]);
			attr(path1, "stroke-dasharray", path1_stroke_dasharray_value = /*length*/ ctx[15] / 2);
			attr(path1, "stroke-dashoffset", path1_stroke_dashoffset_value = /*length*/ ctx[15] / 2 * (1 + /*progress*/ ctx[14]));

			attr(path1, "fill", path1_fill_value = /*borderBgColor*/ ctx[2]
			? 'none'
			: /*bgColor*/ ctx[1] || 'none');
		},
		m(target, anchor) {
			insert_hydration(target, path0, anchor);
			insert_hydration(target, path1, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*size, borderWidth*/ 17 && path0_d_value !== (path0_d_value = `M${/*size*/ ctx[0] - /*borderWidth*/ ctx[4] / 2},${/*size*/ ctx[0] / 2} a1,1 0 0,0 -${/*size*/ ctx[0] - /*borderWidth*/ ctx[4]},0`)) {
				attr(path0, "d", path0_d_value);
			}

			if (dirty & /*borderBgColor*/ 4) {
				attr(path0, "stroke", /*borderBgColor*/ ctx[2]);
			}

			if (dirty & /*borderWidth*/ 16) {
				attr(path0, "stroke-width", /*borderWidth*/ ctx[4]);
			}

			if (dirty & /*bgColor*/ 2 && path0_fill_value !== (path0_fill_value = /*bgColor*/ ctx[1] || 'none')) {
				attr(path0, "fill", path0_fill_value);
			}

			if (dirty & /*size, borderWidth*/ 17 && path1_d_value !== (path1_d_value = `M${/*size*/ ctx[0] - /*borderWidth*/ ctx[4] / 2},${/*size*/ ctx[0] / 2} a1,1 0 0,0 -${/*size*/ ctx[0] - /*borderWidth*/ ctx[4]},0`)) {
				attr(path1, "d", path1_d_value);
			}

			if (dirty & /*borderColor*/ 8) {
				attr(path1, "stroke", /*borderColor*/ ctx[3]);
			}

			if (dirty & /*borderWidth*/ 16) {
				attr(path1, "stroke-width", /*borderWidth*/ ctx[4]);
			}

			if (dirty & /*length*/ 32768 && path1_stroke_dasharray_value !== (path1_stroke_dasharray_value = /*length*/ ctx[15] / 2)) {
				attr(path1, "stroke-dasharray", path1_stroke_dasharray_value);
			}

			if (dirty & /*length, progress*/ 49152 && path1_stroke_dashoffset_value !== (path1_stroke_dashoffset_value = /*length*/ ctx[15] / 2 * (1 + /*progress*/ ctx[14]))) {
				attr(path1, "stroke-dashoffset", path1_stroke_dashoffset_value);
			}

			if (dirty & /*borderBgColor, bgColor*/ 6 && path1_fill_value !== (path1_fill_value = /*borderBgColor*/ ctx[2]
			? 'none'
			: /*bgColor*/ ctx[1] || 'none')) {
				attr(path1, "fill", path1_fill_value);
			}
		},
		d(detaching) {
			if (detaching) detach(path0);
			if (detaching) detach(path1);
		}
	};
}

// (62:4) {#if !semiCircle}
function create_if_block_2$d(ctx) {
	let circle;
	let circle_transform_value;
	let circle_stroke_dashoffset_value;
	let circle_fill_value;
	let circle_cx_value;
	let circle_cy_value;
	let if_block = /*borderBgColor*/ ctx[2] && create_if_block_3$b(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			circle = svg_element("circle");
			this.h();
		},
		l(nodes) {
			if (if_block) if_block.l(nodes);

			circle = claim_svg_element(nodes, "circle", {
				class: true,
				transform: true,
				stroke: true,
				"stroke-width": true,
				"stroke-dasharray": true,
				"stroke-dashoffset": true,
				fill: true,
				cx: true,
				cy: true,
				r: true
			});

			children(circle).forEach(detach);
			this.h();
		},
		h() {
			attr(circle, "class", "gauge-front-circle");
			attr(circle, "transform", circle_transform_value = `rotate(-90 ${/*size*/ ctx[0] / 2} ${/*size*/ ctx[0] / 2})`);
			attr(circle, "stroke", /*borderColor*/ ctx[3]);
			attr(circle, "stroke-width", /*borderWidth*/ ctx[4]);
			attr(circle, "stroke-dasharray", /*length*/ ctx[15]);
			attr(circle, "stroke-dashoffset", circle_stroke_dashoffset_value = /*length*/ ctx[15] * (1 - /*progress*/ ctx[14]));

			attr(circle, "fill", circle_fill_value = /*borderBgColor*/ ctx[2]
			? 'none'
			: /*bgColor*/ ctx[1] || 'none');

			attr(circle, "cx", circle_cx_value = /*size*/ ctx[0] / 2);
			attr(circle, "cy", circle_cy_value = /*size*/ ctx[0] / 2);
			attr(circle, "r", /*radius*/ ctx[13]);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_hydration(target, circle, anchor);
		},
		p(ctx, dirty) {
			if (/*borderBgColor*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3$b(ctx);
					if_block.c();
					if_block.m(circle.parentNode, circle);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*size*/ 1 && circle_transform_value !== (circle_transform_value = `rotate(-90 ${/*size*/ ctx[0] / 2} ${/*size*/ ctx[0] / 2})`)) {
				attr(circle, "transform", circle_transform_value);
			}

			if (dirty & /*borderColor*/ 8) {
				attr(circle, "stroke", /*borderColor*/ ctx[3]);
			}

			if (dirty & /*borderWidth*/ 16) {
				attr(circle, "stroke-width", /*borderWidth*/ ctx[4]);
			}

			if (dirty & /*length*/ 32768) {
				attr(circle, "stroke-dasharray", /*length*/ ctx[15]);
			}

			if (dirty & /*length, progress*/ 49152 && circle_stroke_dashoffset_value !== (circle_stroke_dashoffset_value = /*length*/ ctx[15] * (1 - /*progress*/ ctx[14]))) {
				attr(circle, "stroke-dashoffset", circle_stroke_dashoffset_value);
			}

			if (dirty & /*borderBgColor, bgColor*/ 6 && circle_fill_value !== (circle_fill_value = /*borderBgColor*/ ctx[2]
			? 'none'
			: /*bgColor*/ ctx[1] || 'none')) {
				attr(circle, "fill", circle_fill_value);
			}

			if (dirty & /*size*/ 1 && circle_cx_value !== (circle_cx_value = /*size*/ ctx[0] / 2)) {
				attr(circle, "cx", circle_cx_value);
			}

			if (dirty & /*size*/ 1 && circle_cy_value !== (circle_cy_value = /*size*/ ctx[0] / 2)) {
				attr(circle, "cy", circle_cy_value);
			}

			if (dirty & /*radius*/ 8192) {
				attr(circle, "r", /*radius*/ ctx[13]);
			}
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(circle);
		}
	};
}

// (63:6) {#if borderBgColor}
function create_if_block_3$b(ctx) {
	let circle;
	let circle_fill_value;
	let circle_cx_value;
	let circle_cy_value;

	return {
		c() {
			circle = svg_element("circle");
			this.h();
		},
		l(nodes) {
			circle = claim_svg_element(nodes, "circle", {
				class: true,
				stroke: true,
				"stroke-width": true,
				fill: true,
				cx: true,
				cy: true,
				r: true
			});

			children(circle).forEach(detach);
			this.h();
		},
		h() {
			attr(circle, "class", "gauge-back-circle");
			attr(circle, "stroke", /*borderBgColor*/ ctx[2]);
			attr(circle, "stroke-width", /*borderWidth*/ ctx[4]);
			attr(circle, "fill", circle_fill_value = /*bgColor*/ ctx[1] || 'none');
			attr(circle, "cx", circle_cx_value = /*size*/ ctx[0] / 2);
			attr(circle, "cy", circle_cy_value = /*size*/ ctx[0] / 2);
			attr(circle, "r", /*radius*/ ctx[13]);
		},
		m(target, anchor) {
			insert_hydration(target, circle, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*borderBgColor*/ 4) {
				attr(circle, "stroke", /*borderBgColor*/ ctx[2]);
			}

			if (dirty & /*borderWidth*/ 16) {
				attr(circle, "stroke-width", /*borderWidth*/ ctx[4]);
			}

			if (dirty & /*bgColor*/ 2 && circle_fill_value !== (circle_fill_value = /*bgColor*/ ctx[1] || 'none')) {
				attr(circle, "fill", circle_fill_value);
			}

			if (dirty & /*size*/ 1 && circle_cx_value !== (circle_cx_value = /*size*/ ctx[0] / 2)) {
				attr(circle, "cx", circle_cx_value);
			}

			if (dirty & /*size*/ 1 && circle_cy_value !== (circle_cy_value = /*size*/ ctx[0] / 2)) {
				attr(circle, "cy", circle_cy_value);
			}

			if (dirty & /*radius*/ 8192) {
				attr(circle, "r", /*radius*/ ctx[13]);
			}
		},
		d(detaching) {
			if (detaching) detach(circle);
		}
	};
}

// (87:4) {#if valueText}
function create_if_block_1$i(ctx) {
	let text_1;
	let t;
	let text_1_y_value;
	let text_1_dy_value;
	let text_1_dominant_baseline_value;

	return {
		c() {
			text_1 = svg_element("text");
			t = text(/*valueText*/ ctx[5]);
			this.h();
		},
		l(nodes) {
			text_1 = claim_svg_element(nodes, "text", {
				class: true,
				x: true,
				y: true,
				"font-weight": true,
				"font-size": true,
				fill: true,
				dy: true,
				"text-anchor": true,
				"dominant-baseline": true
			});

			var text_1_nodes = children(text_1);
			t = claim_text(text_1_nodes, /*valueText*/ ctx[5]);
			text_1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(text_1, "class", "gauge-value-text");
			attr(text_1, "x", "50%");
			attr(text_1, "y", text_1_y_value = /*semiCircle*/ ctx[16] ? '100%' : '50%');
			attr(text_1, "font-weight", /*valueFontWeight*/ ctx[8]);
			attr(text_1, "font-size", /*valueFontSize*/ ctx[7]);
			attr(text_1, "fill", /*valueTextColor*/ ctx[6]);

			attr(text_1, "dy", text_1_dy_value = /*semiCircle*/ ctx[16]
			? /*labelText*/ ctx[9]
				? -/*labelFontSize*/ ctx[11] - 15
				: -5
			: 0);

			attr(text_1, "text-anchor", "middle");
			attr(text_1, "dominant-baseline", text_1_dominant_baseline_value = !/*semiCircle*/ ctx[16] ? 'middle' : null);
		},
		m(target, anchor) {
			insert_hydration(target, text_1, anchor);
			append_hydration(text_1, t);
		},
		p(ctx, dirty) {
			if (dirty & /*valueText*/ 32) set_data(t, /*valueText*/ ctx[5]);

			if (dirty & /*semiCircle*/ 65536 && text_1_y_value !== (text_1_y_value = /*semiCircle*/ ctx[16] ? '100%' : '50%')) {
				attr(text_1, "y", text_1_y_value);
			}

			if (dirty & /*valueFontWeight*/ 256) {
				attr(text_1, "font-weight", /*valueFontWeight*/ ctx[8]);
			}

			if (dirty & /*valueFontSize*/ 128) {
				attr(text_1, "font-size", /*valueFontSize*/ ctx[7]);
			}

			if (dirty & /*valueTextColor*/ 64) {
				attr(text_1, "fill", /*valueTextColor*/ ctx[6]);
			}

			if (dirty & /*semiCircle, labelText, labelFontSize*/ 68096 && text_1_dy_value !== (text_1_dy_value = /*semiCircle*/ ctx[16]
			? /*labelText*/ ctx[9]
				? -/*labelFontSize*/ ctx[11] - 15
				: -5
			: 0)) {
				attr(text_1, "dy", text_1_dy_value);
			}

			if (dirty & /*semiCircle*/ 65536 && text_1_dominant_baseline_value !== (text_1_dominant_baseline_value = !/*semiCircle*/ ctx[16] ? 'middle' : null)) {
				attr(text_1, "dominant-baseline", text_1_dominant_baseline_value);
			}
		},
		d(detaching) {
			if (detaching) detach(text_1);
		}
	};
}

// (102:4) {#if labelText}
function create_if_block$s(ctx) {
	let text_1;
	let t;
	let text_1_y_value;
	let text_1_dy_value;
	let text_1_dominant_baseline_value;

	return {
		c() {
			text_1 = svg_element("text");
			t = text(/*labelText*/ ctx[9]);
			this.h();
		},
		l(nodes) {
			text_1 = claim_svg_element(nodes, "text", {
				class: true,
				x: true,
				y: true,
				"font-weight": true,
				"font-size": true,
				fill: true,
				dy: true,
				"text-anchor": true,
				"dominant-baseline": true
			});

			var text_1_nodes = children(text_1);
			t = claim_text(text_1_nodes, /*labelText*/ ctx[9]);
			text_1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(text_1, "class", "gauge-label-text");
			attr(text_1, "x", "50%");
			attr(text_1, "y", text_1_y_value = /*semiCircle*/ ctx[16] ? '100%' : '50%');
			attr(text_1, "font-weight", /*labelFontWeight*/ ctx[12]);
			attr(text_1, "font-size", /*labelFontSize*/ ctx[11]);
			attr(text_1, "fill", /*labelTextColor*/ ctx[10]);

			attr(text_1, "dy", text_1_dy_value = /*semiCircle*/ ctx[16]
			? -5
			: /*valueText*/ ctx[5]
				? /*valueFontSize*/ ctx[7] / 2 + 10
				: 0);

			attr(text_1, "text-anchor", "middle");
			attr(text_1, "dominant-baseline", text_1_dominant_baseline_value = !/*semiCircle*/ ctx[16] ? 'middle' : null);
		},
		m(target, anchor) {
			insert_hydration(target, text_1, anchor);
			append_hydration(text_1, t);
		},
		p(ctx, dirty) {
			if (dirty & /*labelText*/ 512) set_data(t, /*labelText*/ ctx[9]);

			if (dirty & /*semiCircle*/ 65536 && text_1_y_value !== (text_1_y_value = /*semiCircle*/ ctx[16] ? '100%' : '50%')) {
				attr(text_1, "y", text_1_y_value);
			}

			if (dirty & /*labelFontWeight*/ 4096) {
				attr(text_1, "font-weight", /*labelFontWeight*/ ctx[12]);
			}

			if (dirty & /*labelFontSize*/ 2048) {
				attr(text_1, "font-size", /*labelFontSize*/ ctx[11]);
			}

			if (dirty & /*labelTextColor*/ 1024) {
				attr(text_1, "fill", /*labelTextColor*/ ctx[10]);
			}

			if (dirty & /*semiCircle, valueText, valueFontSize*/ 65696 && text_1_dy_value !== (text_1_dy_value = /*semiCircle*/ ctx[16]
			? -5
			: /*valueText*/ ctx[5]
				? /*valueFontSize*/ ctx[7] / 2 + 10
				: 0)) {
				attr(text_1, "dy", text_1_dy_value);
			}

			if (dirty & /*semiCircle*/ 65536 && text_1_dominant_baseline_value !== (text_1_dominant_baseline_value = !/*semiCircle*/ ctx[16] ? 'middle' : null)) {
				attr(text_1, "dominant-baseline", text_1_dominant_baseline_value);
			}
		},
		d(detaching) {
			if (detaching) detach(text_1);
		}
	};
}

function create_fragment$V(ctx) {
	let div;
	let svg;
	let if_block0_anchor;
	let if_block1_anchor;
	let if_block2_anchor;
	let svg_width_value;
	let svg_height_value;
	let svg_viewBox_value;
	let if_block0 = /*semiCircle*/ ctx[16] && create_if_block_4$7(ctx);
	let if_block1 = !/*semiCircle*/ ctx[16] && create_if_block_2$d(ctx);
	let if_block2 = /*valueText*/ ctx[5] && create_if_block_1$i(ctx);
	let if_block3 = /*labelText*/ ctx[9] && create_if_block$s(ctx);
	let div_levels = [{ class: /*classes*/ ctx[17] }, restProps(/*$$restProps*/ ctx[18])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			svg = svg_element("svg");
			if (if_block0) if_block0.c();
			if_block0_anchor = empty();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
			if (if_block3) if_block3.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			svg = claim_svg_element(div_nodes, "svg", {
				class: true,
				width: true,
				height: true,
				viewBox: true
			});

			var svg_nodes = children(svg);
			if (if_block0) if_block0.l(svg_nodes);
			if_block0_anchor = empty();
			if (if_block1) if_block1.l(svg_nodes);
			if_block1_anchor = empty();
			if (if_block2) if_block2.l(svg_nodes);
			if_block2_anchor = empty();
			if (if_block3) if_block3.l(svg_nodes);
			svg_nodes.forEach(detach);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(svg, "class", "gauge-svg");
			attr(svg, "width", svg_width_value = `${/*size*/ ctx[0]}px`);

			attr(svg, "height", svg_height_value = `${/*semiCircle*/ ctx[16]
			? /*size*/ ctx[0] / 2
			: /*size*/ ctx[0]}px`);

			attr(svg, "viewBox", svg_viewBox_value = `0 0 ${/*size*/ ctx[0]} ${/*semiCircle*/ ctx[16]
			? /*size*/ ctx[0] / 2
			: /*size*/ ctx[0]}`);

			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, svg);
			if (if_block0) if_block0.m(svg, null);
			append_hydration(svg, if_block0_anchor);
			if (if_block1) if_block1.m(svg, null);
			append_hydration(svg, if_block1_anchor);
			if (if_block2) if_block2.m(svg, null);
			append_hydration(svg, if_block2_anchor);
			if (if_block3) if_block3.m(svg, null);
		},
		p(ctx, [dirty]) {
			if (/*semiCircle*/ ctx[16]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4$7(ctx);
					if_block0.c();
					if_block0.m(svg, if_block0_anchor);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!/*semiCircle*/ ctx[16]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2$d(ctx);
					if_block1.c();
					if_block1.m(svg, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*valueText*/ ctx[5]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_1$i(ctx);
					if_block2.c();
					if_block2.m(svg, if_block2_anchor);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*labelText*/ ctx[9]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block$s(ctx);
					if_block3.c();
					if_block3.m(svg, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (dirty & /*size*/ 1 && svg_width_value !== (svg_width_value = `${/*size*/ ctx[0]}px`)) {
				attr(svg, "width", svg_width_value);
			}

			if (dirty & /*semiCircle, size*/ 65537 && svg_height_value !== (svg_height_value = `${/*semiCircle*/ ctx[16]
			? /*size*/ ctx[0] / 2
			: /*size*/ ctx[0]}px`)) {
				attr(svg, "height", svg_height_value);
			}

			if (dirty & /*size, semiCircle*/ 65537 && svg_viewBox_value !== (svg_viewBox_value = `0 0 ${/*size*/ ctx[0]} ${/*semiCircle*/ ctx[16]
			? /*size*/ ctx[0] / 2
			: /*size*/ ctx[0]}`)) {
				attr(svg, "viewBox", svg_viewBox_value);
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*classes*/ 131072 && { class: /*classes*/ ctx[17] },
				dirty & /*$$restProps*/ 262144 && restProps(/*$$restProps*/ ctx[18])
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
		}
	};
}

let index$X = 0;

function instance$N($$self, $$props, $$invalidate) {
	let classes;
	let semiCircle;
	let radius;
	let length;
	let progress;

	const omit_props_names = [
		"lec","class","type","value","size","bgColor","borderBgColor","borderColor","borderWidth","valueText","valueTextColor","valueFontSize","valueFontWeight","labelText","labelTextColor","labelFontSize","labelFontWeight"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let { type = 'circle' } = $$props;
	let { value = 0 } = $$props;
	let { size = 200 } = $$props;
	let { bgColor = 'transparent' } = $$props;
	let { borderBgColor = '#eeeeee' } = $$props;
	let { borderColor = '#000000' } = $$props;
	let { borderWidth = 10 } = $$props;
	let { valueText = undefined } = $$props;
	let { valueTextColor = '#000000' } = $$props;
	let { valueFontSize = 31 } = $$props;
	let { valueFontWeight = 500 } = $$props;
	let { labelText = undefined } = $$props;
	let { labelTextColor = '#888888' } = $$props;
	let { labelFontSize = 14 } = $$props;
	let { labelFontWeight = 400 } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(19, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(20, className = $$new_props.class);
		if ('type' in $$new_props) $$invalidate(21, type = $$new_props.type);
		if ('value' in $$new_props) $$invalidate(22, value = $$new_props.value);
		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
		if ('bgColor' in $$new_props) $$invalidate(1, bgColor = $$new_props.bgColor);
		if ('borderBgColor' in $$new_props) $$invalidate(2, borderBgColor = $$new_props.borderBgColor);
		if ('borderColor' in $$new_props) $$invalidate(3, borderColor = $$new_props.borderColor);
		if ('borderWidth' in $$new_props) $$invalidate(4, borderWidth = $$new_props.borderWidth);
		if ('valueText' in $$new_props) $$invalidate(5, valueText = $$new_props.valueText);
		if ('valueTextColor' in $$new_props) $$invalidate(6, valueTextColor = $$new_props.valueTextColor);
		if ('valueFontSize' in $$new_props) $$invalidate(7, valueFontSize = $$new_props.valueFontSize);
		if ('valueFontWeight' in $$new_props) $$invalidate(8, valueFontWeight = $$new_props.valueFontWeight);
		if ('labelText' in $$new_props) $$invalidate(9, labelText = $$new_props.labelText);
		if ('labelTextColor' in $$new_props) $$invalidate(10, labelTextColor = $$new_props.labelTextColor);
		if ('labelFontSize' in $$new_props) $$invalidate(11, labelFontSize = $$new_props.labelFontSize);
		if ('labelFontWeight' in $$new_props) $$invalidate(12, labelFontWeight = $$new_props.labelFontWeight);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 1048576) {
			$: $$invalidate(17, classes = classNames(className, 'gauge'));
		}

		if ($$self.$$.dirty & /*type*/ 2097152) {
			$: $$invalidate(16, semiCircle = type === 'semicircle');
		}

		if ($$self.$$.dirty & /*size, borderWidth*/ 17) {
			$: $$invalidate(13, radius = size / 2 - borderWidth / 2);
		}

		if ($$self.$$.dirty & /*radius*/ 8192) {
			$: $$invalidate(15, length = 2 * Math.PI * radius);
		}

		if ($$self.$$.dirty & /*value*/ 4194304) {
			$: $$invalidate(14, progress = Math.max(Math.min(value, 1), 0));
		}
	};

	return [
		size,
		bgColor,
		borderBgColor,
		borderColor,
		borderWidth,
		valueText,
		valueTextColor,
		valueFontSize,
		valueFontWeight,
		labelText,
		labelTextColor,
		labelFontSize,
		labelFontWeight,
		radius,
		progress,
		length,
		semiCircle,
		classes,
		$$restProps,
		lec,
		className,
		type,
		value
	];
}

class Gauge extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$N, create_fragment$V, safe_not_equal, {
			lec: 19,
			class: 20,
			type: 21,
			value: 22,
			size: 0,
			bgColor: 1,
			borderBgColor: 2,
			borderColor: 3,
			borderWidth: 4,
			valueText: 5,
			valueTextColor: 6,
			valueFontSize: 7,
			valueFontWeight: 8,
			labelText: 9,
			labelTextColor: 10,
			labelFontSize: 11,
			labelFontWeight: 12
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/toggle.liquivelte generated by Svelte v3.50.0 */

function create_fragment$U(ctx) {
	let label;
	let input;
	let input_value_value;
	let t;
	let span;
	let useTooltip_action;
	let mounted;
	let dispose;
	let label_levels = [{ class: /*classes*/ ctx[9] }, restProps(/*$$restProps*/ ctx[11])];
	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	return {
		c() {
			label = element("label");
			input = element("input");
			t = space();
			span = element("span");
			this.h();
		},
		l(nodes) {
			label = claim_element(nodes, "LABEL", { class: true });
			var label_nodes = children(label);
			input = claim_element(label_nodes, "INPUT", { type: true, name: true });
			t = claim_space(label_nodes);
			span = claim_element(label_nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			label_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(input, "type", "checkbox");
			attr(input, "name", /*name*/ ctx[3]);
			input.disabled = /*disabled*/ ctx[1];
			input.readOnly = /*readonly*/ ctx[2];
			input.checked = /*checked*/ ctx[0];

			input.value = input_value_value = typeof /*value*/ ctx[4] === 'undefined'
			? ''
			: /*value*/ ctx[4];

			attr(span, "class", "toggle-icon");
			set_attributes(label, label_data);
		},
		m(target, anchor) {
			insert_hydration(target, label, anchor);
			append_hydration(label, input);
			/*input_binding*/ ctx[16](input);
			append_hydration(label, t);
			append_hydration(label, span);
			/*label_binding*/ ctx[17](label);

			if (!mounted) {
				dispose = [
					listen(input, "change", /*onChange*/ ctx[10]),
					action_destroyer(useTooltip_action = useTooltip.call(null, label, {
						tooltip: /*tooltip*/ ctx[5],
						tooltipTrigger: /*tooltipTrigger*/ ctx[6]
					}))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*name*/ 8) {
				attr(input, "name", /*name*/ ctx[3]);
			}

			if (dirty & /*disabled*/ 2) {
				input.disabled = /*disabled*/ ctx[1];
			}

			if (dirty & /*readonly*/ 4) {
				input.readOnly = /*readonly*/ ctx[2];
			}

			if (dirty & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (dirty & /*value*/ 16 && input_value_value !== (input_value_value = typeof /*value*/ ctx[4] === 'undefined'
			? ''
			: /*value*/ ctx[4])) {
				input.value = input_value_value;
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				dirty & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
				dirty & /*$$restProps*/ 2048 && restProps(/*$$restProps*/ ctx[11])
			]));

			if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/ 96) useTooltip_action.update.call(null, {
				tooltip: /*tooltip*/ ctx[5],
				tooltipTrigger: /*tooltipTrigger*/ ctx[6]
			});
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(label);
			/*input_binding*/ ctx[16](null);
			/*label_binding*/ ctx[17](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

let index$W = 0;

function instance_1$8($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"lec","class","init","checked","disabled","readonly","name","value","tooltip","tooltipTrigger","instance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { init = true } = $$props;
	let { checked = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let { name = undefined } = $$props;
	let { value = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let el;
	let inputEl;
	let f7Toggle;

	function instance() {
		return f7Toggle;
	}

	let initialWatched = false;

	function watchChecked(isChecked) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7Toggle) return;
		f7Toggle.checked = isChecked;
	}

	function onChange(event) {
		emit('change', [event]);
	}

	onMount(() => {
		if (!init) return;

		f7ready(() => {
			f7Toggle = app.f7.toggle.create({
				el,
				on: {
					change(toggle) {
						emit('toggleChange', [toggle.checked]);
						$$invalidate(0, checked = toggle.checked);
					}
				}
			});
		});
	});

	onDestroy(() => {
		if (f7Toggle && f7Toggle.destroy && f7Toggle.$el) {
			f7Toggle.destroy();
			f7Toggle = null;
		}
	});

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(8, inputEl);
		});
	}

	function label_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(7, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(12, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(13, className = $$new_props.class);
		if ('init' in $$new_props) $$invalidate(14, init = $$new_props.init);
		if ('checked' in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ('disabled' in $$new_props) $$invalidate(1, disabled = $$new_props.disabled);
		if ('readonly' in $$new_props) $$invalidate(2, readonly = $$new_props.readonly);
		if ('name' in $$new_props) $$invalidate(3, name = $$new_props.name);
		if ('value' in $$new_props) $$invalidate(4, value = $$new_props.value);
		if ('tooltip' in $$new_props) $$invalidate(5, tooltip = $$new_props.tooltip);
		if ('tooltipTrigger' in $$new_props) $$invalidate(6, tooltipTrigger = $$new_props.tooltipTrigger);
	};

	$$self.$$.update = () => {
		$: $$invalidate(9, classes = classNames('toggle', className, { disabled }, colorClasses($$props)));

		if ($$self.$$.dirty & /*checked*/ 1) {
			$: watchChecked(checked);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		checked,
		disabled,
		readonly,
		name,
		value,
		tooltip,
		tooltipTrigger,
		el,
		inputEl,
		classes,
		onChange,
		$$restProps,
		lec,
		className,
		init,
		instance,
		input_binding,
		label_binding
	];
}

class Toggle extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance_1$8, create_fragment$U, safe_not_equal, {
			lec: 12,
			class: 13,
			init: 14,
			checked: 0,
			disabled: 1,
			readonly: 2,
			name: 3,
			value: 4,
			tooltip: 5,
			tooltipTrigger: 6,
			instance: 15
		});
	}

	get instance() {
		return this.$$.ctx[15];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/range.liquivelte generated by Svelte v3.50.0 */
const get_default_slot_changes$5 = dirty => ({ range: dirty[0] & /*f7Range*/ 16 });
const get_default_slot_context$5 = ctx => ({ range: /*f7Range*/ ctx[4] });

// (109:2) {#if input}
function create_if_block$r(ctx) {
	let input_1;

	return {
		c() {
			input_1 = element("input");
			this.h();
		},
		l(nodes) {
			input_1 = claim_element(nodes, "INPUT", { type: true, name: true, id: true });
			this.h();
		},
		h() {
			attr(input_1, "type", "range");
			attr(input_1, "name", /*name*/ ctx[0]);
			attr(input_1, "id", /*inputId*/ ctx[2]);
		},
		m(target, anchor) {
			insert_hydration(target, input_1, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*name*/ 1) {
				attr(input_1, "name", /*name*/ ctx[0]);
			}

			if (dirty[0] & /*inputId*/ 4) {
				attr(input_1, "id", /*inputId*/ ctx[2]);
			}
		},
		d(detaching) {
			if (detaching) detach(input_1);
		}
	};
}

function create_fragment$T(ctx) {
	let div;
	let t;
	let current;
	let if_block = /*input*/ ctx[1] && create_if_block$r(ctx);
	const default_slot_template = /*#slots*/ ctx[28].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[27], get_default_slot_context$5);
	let div_levels = [{ class: /*classes*/ ctx[5] }, restProps(/*$$restProps*/ ctx[6])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[29](div);
			current = true;
		},
		p(ctx, dirty) {
			if (/*input*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$r(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope, f7Range*/ 134217744)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[27],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[27])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[27], dirty, get_default_slot_changes$5),
						get_default_slot_context$5
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 32) && { class: /*classes*/ ctx[5] },
				dirty[0] & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[29](null);
		}
	};
}

let index$V = 0;

function instance_1$7($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"lec","class","init","value","min","max","step","label","dual","vertical","verticalReversed","draggableBar","formatLabel","scale","scaleSteps","scaleSubSteps","formatScaleLabel","limitKnobPosition","name","input","inputId","disabled","instance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { init = true } = $$props;
	let { value = 0 } = $$props;
	let { min = 0 } = $$props;
	let { max = 100 } = $$props;
	let { step = 1 } = $$props;
	let { label = false } = $$props;
	let { dual = false } = $$props;
	let { vertical = false } = $$props;
	let { verticalReversed = false } = $$props;
	let { draggableBar = true } = $$props;
	let { formatLabel = undefined } = $$props;
	let { scale = false } = $$props;
	let { scaleSteps = 5 } = $$props;
	let { scaleSubSteps = 0 } = $$props;
	let { formatScaleLabel = undefined } = $$props;
	let { limitKnobPosition = undefined } = $$props;
	let { name = undefined } = $$props;
	let { input = false } = $$props;
	let { inputId = undefined } = $$props;
	let { disabled = false } = $$props;
	let el;
	let f7Range;

	function instance() {
		return f7Range;
	}

	function watchValue(newValue) {
		if (!f7Range) return;
		f7Range.setValue(newValue);
	}

	onMount(() => {
		if (!init) return;

		f7ready(() => {
			$$invalidate(4, f7Range = app.f7.range.create(noUndefinedProps({
				el,
				value,
				min,
				max,
				step,
				label,
				dual,
				draggableBar,
				vertical,
				verticalReversed,
				formatLabel,
				scale,
				scaleSteps,
				scaleSubSteps,
				formatScaleLabel,
				limitKnobPosition,
				on: {
					change(range, val) {
						emit('rangeChange', [val]);
					},
					changed(range, val) {
						emit('rangeChanged', [val]);
						$$invalidate(7, value = val);
					}
				}
			})));
		});
	});

	onDestroy(() => {
		if (f7Range && f7Range.destroy) {
			f7Range.destroy();
			$$invalidate(4, f7Range = null);
		}
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(33, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(8, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(9, className = $$new_props.class);
		if ('init' in $$new_props) $$invalidate(10, init = $$new_props.init);
		if ('value' in $$new_props) $$invalidate(7, value = $$new_props.value);
		if ('min' in $$new_props) $$invalidate(11, min = $$new_props.min);
		if ('max' in $$new_props) $$invalidate(12, max = $$new_props.max);
		if ('step' in $$new_props) $$invalidate(13, step = $$new_props.step);
		if ('label' in $$new_props) $$invalidate(14, label = $$new_props.label);
		if ('dual' in $$new_props) $$invalidate(15, dual = $$new_props.dual);
		if ('vertical' in $$new_props) $$invalidate(16, vertical = $$new_props.vertical);
		if ('verticalReversed' in $$new_props) $$invalidate(17, verticalReversed = $$new_props.verticalReversed);
		if ('draggableBar' in $$new_props) $$invalidate(18, draggableBar = $$new_props.draggableBar);
		if ('formatLabel' in $$new_props) $$invalidate(19, formatLabel = $$new_props.formatLabel);
		if ('scale' in $$new_props) $$invalidate(20, scale = $$new_props.scale);
		if ('scaleSteps' in $$new_props) $$invalidate(21, scaleSteps = $$new_props.scaleSteps);
		if ('scaleSubSteps' in $$new_props) $$invalidate(22, scaleSubSteps = $$new_props.scaleSubSteps);
		if ('formatScaleLabel' in $$new_props) $$invalidate(23, formatScaleLabel = $$new_props.formatScaleLabel);
		if ('limitKnobPosition' in $$new_props) $$invalidate(24, limitKnobPosition = $$new_props.limitKnobPosition);
		if ('name' in $$new_props) $$invalidate(0, name = $$new_props.name);
		if ('input' in $$new_props) $$invalidate(1, input = $$new_props.input);
		if ('inputId' in $$new_props) $$invalidate(2, inputId = $$new_props.inputId);
		if ('disabled' in $$new_props) $$invalidate(25, disabled = $$new_props.disabled);
		if ('$$scope' in $$new_props) $$invalidate(27, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(5, classes = classNames(
			className,
			'range-slider',
			{
				'range-slider-horizontal': !vertical,
				'range-slider-vertical': vertical,
				'range-slider-vertical-reversed': vertical && verticalReversed,
				disabled
			},
			colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*value*/ 128) {
			$: watchValue(value);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		name,
		input,
		inputId,
		el,
		f7Range,
		classes,
		$$restProps,
		value,
		lec,
		className,
		init,
		min,
		max,
		step,
		label,
		dual,
		vertical,
		verticalReversed,
		draggableBar,
		formatLabel,
		scale,
		scaleSteps,
		scaleSubSteps,
		formatScaleLabel,
		limitKnobPosition,
		disabled,
		instance,
		$$scope,
		slots,
		div_binding
	];
}

class Range extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance_1$7,
			create_fragment$T,
			safe_not_equal,
			{
				lec: 8,
				class: 9,
				init: 10,
				value: 7,
				min: 11,
				max: 12,
				step: 13,
				label: 14,
				dual: 15,
				vertical: 16,
				verticalReversed: 17,
				draggableBar: 18,
				formatLabel: 19,
				scale: 20,
				scaleSteps: 21,
				scaleSubSteps: 22,
				formatScaleLabel: 23,
				limitKnobPosition: 24,
				name: 0,
				input: 1,
				inputId: 2,
				disabled: 25,
				instance: 26
			},
			null,
			[-1, -1]
		);
	}

	get instance() {
		return this.$$.ctx[26];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/text-editor.liquivelte generated by Svelte v3.50.0 */

const get_root_slot_changes$3 = dirty => ({
	textEditor: dirty[0] & /*f7TextEditor*/ 2
});

const get_root_slot_context$3 = ctx => ({ textEditor: /*f7TextEditor*/ ctx[1] });

const get_root_end_slot_changes$3 = dirty => ({
	textEditor: dirty[0] & /*f7TextEditor*/ 2
});

const get_root_end_slot_context$3 = ctx => ({ textEditor: /*f7TextEditor*/ ctx[1] });

const get_default_slot_changes$4 = dirty => ({
	textEditor: dirty[0] & /*f7TextEditor*/ 2
});

const get_default_slot_context$4 = ctx => ({ textEditor: /*f7TextEditor*/ ctx[1] });

const get_root_start_slot_changes$3 = dirty => ({
	textEditor: dirty[0] & /*f7TextEditor*/ 2
});

const get_root_start_slot_context$3 = ctx => ({ textEditor: /*f7TextEditor*/ ctx[1] });

function create_fragment$S(ctx) {
	let div1;
	let t0;
	let div0;
	let t1;
	let t2;
	let current;
	const root_start_slot_template = /*#slots*/ ctx[18]["root-start"];
	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[17], get_root_start_slot_context$3);
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], get_default_slot_context$4);
	const root_end_slot_template = /*#slots*/ ctx[18]["root-end"];
	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[17], get_root_end_slot_context$3);
	const root_slot_template = /*#slots*/ ctx[18].root;
	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[17], get_root_slot_context$3);
	let div1_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	return {
		c() {
			div1 = element("div");
			if (root_start_slot) root_start_slot.c();
			t0 = space();
			div0 = element("div");
			if (default_slot) default_slot.c();
			t1 = space();
			if (root_end_slot) root_end_slot.c();
			t2 = space();
			if (root_slot) root_slot.c();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (root_start_slot) root_start_slot.l(div1_nodes);
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true, contenteditable: true });
			var div0_nodes = children(div0);
			if (default_slot) default_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			t1 = claim_space(div1_nodes);
			if (root_end_slot) root_end_slot.l(div1_nodes);
			t2 = claim_space(div1_nodes);
			if (root_slot) root_slot.l(div1_nodes);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "text-editor-content");
			attr(div0, "contenteditable", "");
			set_attributes(div1, div1_data);
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);

			if (root_start_slot) {
				root_start_slot.m(div1, null);
			}

			append_hydration(div1, t0);
			append_hydration(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			append_hydration(div1, t1);

			if (root_end_slot) {
				root_end_slot.m(div1, null);
			}

			append_hydration(div1, t2);

			if (root_slot) {
				root_slot.m(div1, null);
			}

			/*div1_binding*/ ctx[19](div1);
			current = true;
		},
		p(ctx, dirty) {
			if (root_start_slot) {
				if (root_start_slot.p && (!current || dirty[0] & /*$$scope, f7TextEditor*/ 131074)) {
					update_slot_base(
						root_start_slot,
						root_start_slot_template,
						ctx,
						/*$$scope*/ ctx[17],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
						: get_slot_changes(root_start_slot_template, /*$$scope*/ ctx[17], dirty, get_root_start_slot_changes$3),
						get_root_start_slot_context$3
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope, f7TextEditor*/ 131074)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[17],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, get_default_slot_changes$4),
						get_default_slot_context$4
					);
				}
			}

			if (root_end_slot) {
				if (root_end_slot.p && (!current || dirty[0] & /*$$scope, f7TextEditor*/ 131074)) {
					update_slot_base(
						root_end_slot,
						root_end_slot_template,
						ctx,
						/*$$scope*/ ctx[17],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
						: get_slot_changes(root_end_slot_template, /*$$scope*/ ctx[17], dirty, get_root_end_slot_changes$3),
						get_root_end_slot_context$3
					);
				}
			}

			if (root_slot) {
				if (root_slot.p && (!current || dirty[0] & /*$$scope, f7TextEditor*/ 131074)) {
					update_slot_base(
						root_slot,
						root_slot_template,
						ctx,
						/*$$scope*/ ctx[17],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
						: get_slot_changes(root_slot_template, /*$$scope*/ ctx[17], dirty, get_root_slot_changes$3),
						get_root_slot_context$3
					);
				}
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty[0] & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty[0] & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(root_start_slot, local);
			transition_in(default_slot, local);
			transition_in(root_end_slot, local);
			transition_in(root_slot, local);
			current = true;
		},
		o(local) {
			transition_out(root_start_slot, local);
			transition_out(default_slot, local);
			transition_out(root_end_slot, local);
			transition_out(root_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (root_start_slot) root_start_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (root_end_slot) root_end_slot.d(detaching);
			if (root_slot) root_slot.d(detaching);
			/*div1_binding*/ ctx[19](null);
		}
	};
}

let index$U = 0;

function instance_1$6($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"lec","class","mode","value","buttons","customButtons","dividers","imageUrlText","linkUrlText","placeholder","clearFormattingOnPaste","resizable","instance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { mode = undefined } = $$props;
	let { value = undefined } = $$props;
	let { buttons = undefined } = $$props;
	let { customButtons = undefined } = $$props;
	let { dividers = undefined } = $$props;
	let { imageUrlText = undefined } = $$props;
	let { linkUrlText = undefined } = $$props;
	let { placeholder = undefined } = $$props;
	let { clearFormattingOnPaste = undefined } = $$props;
	let { resizable = false } = $$props;
	let el;
	let f7TextEditor;

	function instance() {
		return f7TextEditor;
	}

	function watchValue(newValue) {
		if (f7TextEditor) {
			f7TextEditor.setValue(newValue);
		}
	}

	function onChange(editor, editorValue) {
		emit('textEditorChange', [editorValue]);
	}

	function onInput(editor, editorValue) {
		emit('textEditorInput', [editorValue]);
	}

	function onFocus() {
		emit('textEditorFocus');
	}

	function onBlur() {
		emit('textEditorBlur');
	}

	function onButtonClick(editor, button) {
		emit('textEditorButtonClick', [button]);
	}

	function onKeyboardOpen() {
		emit('textEditorKeyboardOpen');
	}

	function onKeyboardClose() {
		emit('textEditorKeyboardClose');
	}

	function onPopoverOpen() {
		emit('textEditorPopoverOpen');
	}

	function onPopoverClose() {
		emit('textEditorPopoverClose');
	}

	const onInsertLink = (editor, url) => {
		emit('textEditorInsertLink', [url]);
	};

	const onInsertImage = (editor, url) => {
		emit('textEditorInsertImage', [url]);
	};

	onMount(() => {
		const params = noUndefinedProps({
			el,
			mode,
			value,
			buttons,
			customButtons,
			dividers,
			imageUrlText,
			linkUrlText,
			placeholder,
			clearFormattingOnPaste,
			on: {
				change: onChange,
				input: onInput,
				focus: onFocus,
				blur: onBlur,
				buttonClick: onButtonClick,
				keyboardOpen: onKeyboardOpen,
				keyboardClose: onKeyboardClose,
				popoverOpen: onPopoverOpen,
				popoverClose: onPopoverClose,
				insertLink: onInsertLink,
				insertImage: onInsertImage
			}
		});

		f7ready(() => {
			$$invalidate(1, f7TextEditor = app.f7.textEditor.create(params));
		});
	});

	onDestroy(() => {
		if (f7TextEditor && f7TextEditor.destroy) {
			f7TextEditor.destroy();
			$$invalidate(1, f7TextEditor = null);
		}
	});

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(34, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(4, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ('mode' in $$new_props) $$invalidate(6, mode = $$new_props.mode);
		if ('value' in $$new_props) $$invalidate(7, value = $$new_props.value);
		if ('buttons' in $$new_props) $$invalidate(8, buttons = $$new_props.buttons);
		if ('customButtons' in $$new_props) $$invalidate(9, customButtons = $$new_props.customButtons);
		if ('dividers' in $$new_props) $$invalidate(10, dividers = $$new_props.dividers);
		if ('imageUrlText' in $$new_props) $$invalidate(11, imageUrlText = $$new_props.imageUrlText);
		if ('linkUrlText' in $$new_props) $$invalidate(12, linkUrlText = $$new_props.linkUrlText);
		if ('placeholder' in $$new_props) $$invalidate(13, placeholder = $$new_props.placeholder);
		if ('clearFormattingOnPaste' in $$new_props) $$invalidate(14, clearFormattingOnPaste = $$new_props.clearFormattingOnPaste);
		if ('resizable' in $$new_props) $$invalidate(15, resizable = $$new_props.resizable);
		if ('$$scope' in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(2, classes = classNames(className, 'text-editor', resizable && 'text-editor-resizable', colorClasses($$props)));

		if ($$self.$$.dirty[0] & /*value*/ 128) {
			$: watchValue(value);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		f7TextEditor,
		classes,
		$$restProps,
		lec,
		className,
		mode,
		value,
		buttons,
		customButtons,
		dividers,
		imageUrlText,
		linkUrlText,
		placeholder,
		clearFormattingOnPaste,
		resizable,
		instance,
		$$scope,
		slots,
		div1_binding
	];
}

class Text_editor extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance_1$6,
			create_fragment$S,
			safe_not_equal,
			{
				lec: 4,
				class: 5,
				mode: 6,
				value: 7,
				buttons: 8,
				customButtons: 9,
				dividers: 10,
				imageUrlText: 11,
				linkUrlText: 12,
				placeholder: 13,
				clearFormattingOnPaste: 14,
				resizable: 15,
				instance: 16
			},
			null,
			[-1, -1]
		);
	}

	get instance() {
		return this.$$.ctx[16];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/input.liquivelte generated by Svelte v3.50.0 */
const get_info_slot_changes$1 = dirty => ({});
const get_info_slot_context$1 = ctx => ({});
const get_error_message_slot_changes$1 = dirty => ({});
const get_error_message_slot_context$1 = ctx => ({});

// (631:0) {:else}
function create_else_block_1$3(ctx) {
	let input;
	let input_validate_value;
	let input_data_validate_value;
	let input_data_validate_on_blur_value;
	let input_data_error_message_value;
	let input_value_value;
	let mounted;
	let dispose;

	let input_levels = [
		{ style: /*inputStyle*/ ctx[24] },
		{ name: /*name*/ ctx[3] },
		{ type: /*inputType*/ ctx[36] },
		{ placeholder: /*placeholder*/ ctx[4] },
		{ id: /*inputId*/ ctx[5] },
		{ size: /*size*/ ctx[6] },
		{ accept: /*accept*/ ctx[7] },
		{ autocomplete: /*autocomplete*/ ctx[8] },
		{ autocorrect: /*autocorrect*/ ctx[9] },
		{
			autocapitalize: /*autocapitalize*/ ctx[10]
		},
		{ spellcheck: /*spellcheck*/ ctx[11] },
		{ autofocus: /*autofocus*/ ctx[12] },
		{ autosave: /*autosave*/ ctx[13] },
		{ checked: /*checked*/ ctx[14] },
		{ disabled: /*disabled*/ ctx[15] },
		{ max: /*max*/ ctx[16] },
		{ maxlength: /*maxlength*/ ctx[19] },
		{ min: /*min*/ ctx[17] },
		{ minlength: /*minlength*/ ctx[20] },
		{ step: /*step*/ ctx[18] },
		{ multiple: /*multiple*/ ctx[21] },
		{ readOnly: /*readonly*/ ctx[22] },
		{ required: /*required*/ ctx[23] },
		{ pattern: /*pattern*/ ctx[25] },
		{
			validate: input_validate_value = typeof /*validate*/ ctx[26] === 'string' && /*validate*/ ctx[26].length
			? /*validate*/ ctx[26]
			: undefined
		},
		{
			"data-validate": input_data_validate_value = /*validate*/ ctx[26] === true || /*validate*/ ctx[26] === '' || /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined
		},
		{
			"data-validate-on-blur": input_data_validate_on_blur_value = /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined
		},
		{ tabindex: /*tabindex*/ ctx[28] },
		{
			"data-error-message": input_data_error_message_value = /*errorMessageForce*/ ctx[32]
			? undefined
			: /*errorMessage*/ ctx[31]
		},
		{ class: /*inputClassName*/ ctx[40] },
		{
			value: input_value_value = /*type*/ ctx[2] === 'datepicker' || /*type*/ ctx[2] === 'colorpicker' || /*type*/ ctx[2] === 'file'
			? ''
			: /*inputValue*/ ctx[42]
		},
		restProps(/*$$restProps*/ ctx[47])
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	return {
		c() {
			input = element("input");
			this.h();
		},
		l(nodes) {
			input = claim_element(nodes, "INPUT", {
				style: true,
				name: true,
				type: true,
				placeholder: true,
				id: true,
				size: true,
				accept: true,
				autocomplete: true,
				autocorrect: true,
				autocapitalize: true,
				spellcheck: true,
				autosave: true,
				max: true,
				maxlength: true,
				min: true,
				minlength: true,
				step: true,
				pattern: true,
				validate: true,
				"data-validate": true,
				"data-validate-on-blur": true,
				tabindex: true,
				"data-error-message": true,
				class: true
			});

			this.h();
		},
		h() {
			set_attributes(input, input_data);
		},
		m(target, anchor) {
			insert_hydration(target, input, anchor);
			input.value = input_data.value;
			if (input.autofocus) input.focus();
			/*input_binding_1*/ ctx[66](input);

			if (!mounted) {
				dispose = [
					listen(input, "focus", /*onFocus*/ ctx[44]),
					listen(input, "blur", /*onBlur*/ ctx[45]),
					listen(input, "input", /*onInput*/ ctx[43]),
					listen(input, "change", /*onChange*/ ctx[46])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*inputStyle*/ 16777216 && { style: /*inputStyle*/ ctx[24] },
				dirty[0] & /*name*/ 8 && { name: /*name*/ ctx[3] },
				dirty[1] & /*inputType*/ 32 && { type: /*inputType*/ ctx[36] },
				dirty[0] & /*placeholder*/ 16 && { placeholder: /*placeholder*/ ctx[4] },
				dirty[0] & /*inputId*/ 32 && { id: /*inputId*/ ctx[5] },
				dirty[0] & /*size*/ 64 && { size: /*size*/ ctx[6] },
				dirty[0] & /*accept*/ 128 && { accept: /*accept*/ ctx[7] },
				dirty[0] & /*autocomplete*/ 256 && { autocomplete: /*autocomplete*/ ctx[8] },
				dirty[0] & /*autocorrect*/ 512 && { autocorrect: /*autocorrect*/ ctx[9] },
				dirty[0] & /*autocapitalize*/ 1024 && {
					autocapitalize: /*autocapitalize*/ ctx[10]
				},
				dirty[0] & /*spellcheck*/ 2048 && { spellcheck: /*spellcheck*/ ctx[11] },
				dirty[0] & /*autofocus*/ 4096 && { autofocus: /*autofocus*/ ctx[12] },
				dirty[0] & /*autosave*/ 8192 && { autosave: /*autosave*/ ctx[13] },
				dirty[0] & /*checked*/ 16384 && { checked: /*checked*/ ctx[14] },
				dirty[0] & /*disabled*/ 32768 && { disabled: /*disabled*/ ctx[15] },
				dirty[0] & /*max*/ 65536 && { max: /*max*/ ctx[16] },
				dirty[0] & /*maxlength*/ 524288 && { maxlength: /*maxlength*/ ctx[19] },
				dirty[0] & /*min*/ 131072 && { min: /*min*/ ctx[17] },
				dirty[0] & /*minlength*/ 1048576 && { minlength: /*minlength*/ ctx[20] },
				dirty[0] & /*step*/ 262144 && { step: /*step*/ ctx[18] },
				dirty[0] & /*multiple*/ 2097152 && { multiple: /*multiple*/ ctx[21] },
				dirty[0] & /*readonly*/ 4194304 && { readOnly: /*readonly*/ ctx[22] },
				dirty[0] & /*required*/ 8388608 && { required: /*required*/ ctx[23] },
				dirty[0] & /*pattern*/ 33554432 && { pattern: /*pattern*/ ctx[25] },
				dirty[0] & /*validate*/ 67108864 && input_validate_value !== (input_validate_value = typeof /*validate*/ ctx[26] === 'string' && /*validate*/ ctx[26].length
				? /*validate*/ ctx[26]
				: undefined) && { validate: input_validate_value },
				dirty[0] & /*validate, validateOnBlur*/ 201326592 && input_data_validate_value !== (input_data_validate_value = /*validate*/ ctx[26] === true || /*validate*/ ctx[26] === '' || /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
				? true
				: undefined) && {
					"data-validate": input_data_validate_value
				},
				dirty[0] & /*validateOnBlur*/ 134217728 && input_data_validate_on_blur_value !== (input_data_validate_on_blur_value = /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
				? true
				: undefined) && {
					"data-validate-on-blur": input_data_validate_on_blur_value
				},
				dirty[0] & /*tabindex*/ 268435456 && { tabindex: /*tabindex*/ ctx[28] },
				dirty[1] & /*errorMessageForce, errorMessage*/ 3 && input_data_error_message_value !== (input_data_error_message_value = /*errorMessageForce*/ ctx[32]
				? undefined
				: /*errorMessage*/ ctx[31]) && {
					"data-error-message": input_data_error_message_value
				},
				dirty[1] & /*inputClassName*/ 512 && { class: /*inputClassName*/ ctx[40] },
				dirty[0] & /*type*/ 4 | dirty[1] & /*inputValue*/ 2048 && input_value_value !== (input_value_value = /*type*/ ctx[2] === 'datepicker' || /*type*/ ctx[2] === 'colorpicker' || /*type*/ ctx[2] === 'file'
				? ''
				: /*inputValue*/ ctx[42]) && input.value !== input_value_value && { value: input_value_value },
				dirty[1] & /*$$restProps*/ 65536 && restProps(/*$$restProps*/ ctx[47])
			]));

			if ('value' in input_data) {
				input.value = input_data.value;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(input);
			/*input_binding_1*/ ctx[66](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (619:32) 
function create_if_block_13$2(ctx) {
	let texteditor;
	let current;

	const texteditor_spread_levels = [
		{
			value: typeof /*value*/ ctx[0] === 'undefined'
			? ''
			: /*value*/ ctx[0]
		},
		{ resizable: /*resizable*/ ctx[29] },
		{ placeholder: /*placeholder*/ ctx[4] },
		{ onTextEditorFocus: /*onFocus*/ ctx[44] },
		{ onTextEditorBlur: /*onBlur*/ ctx[45] },
		{ onTextEditorInput: /*onInput*/ ctx[43] },
		{ onTextEditorChange: /*onChange*/ ctx[46] },
		/*textEditorParams*/ ctx[35],
		restProps(/*$$restProps*/ ctx[47]),
		{ lec: /*lec*/ ctx[1] }
	];

	let texteditor_props = {};

	for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
		texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
	}

	texteditor = new Text_editor({ props: texteditor_props });

	return {
		c() {
			create_component(texteditor.$$.fragment);
		},
		l(nodes) {
			claim_component(texteditor.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(texteditor, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const texteditor_changes = (dirty[0] & /*value, resizable, placeholder, lec*/ 536870931 | dirty[1] & /*onFocus, onBlur, onInput, onChange, textEditorParams, $$restProps*/ 126992)
			? get_spread_update(texteditor_spread_levels, [
					dirty[0] & /*value*/ 1 && {
						value: typeof /*value*/ ctx[0] === 'undefined'
						? ''
						: /*value*/ ctx[0]
					},
					dirty[0] & /*resizable*/ 536870912 && { resizable: /*resizable*/ ctx[29] },
					dirty[0] & /*placeholder*/ 16 && { placeholder: /*placeholder*/ ctx[4] },
					dirty[1] & /*onFocus*/ 8192 && { onTextEditorFocus: /*onFocus*/ ctx[44] },
					dirty[1] & /*onBlur*/ 16384 && { onTextEditorBlur: /*onBlur*/ ctx[45] },
					dirty[1] & /*onInput*/ 4096 && { onTextEditorInput: /*onInput*/ ctx[43] },
					dirty[1] & /*onChange*/ 32768 && { onTextEditorChange: /*onChange*/ ctx[46] },
					dirty[1] & /*textEditorParams*/ 16 && get_spread_object(/*textEditorParams*/ ctx[35]),
					dirty[1] & /*$$restProps*/ 65536 && get_spread_object(restProps(/*$$restProps*/ ctx[47])),
					dirty[0] & /*lec*/ 2 && { lec: /*lec*/ ctx[1] }
				])
			: {};

			texteditor.$set(texteditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(texteditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(texteditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(texteditor, detaching);
		}
	};
}

// (606:27) 
function create_if_block_12$2(ctx) {
	let range;
	let current;

	const range_spread_levels = [
		{ value: /*value*/ ctx[0] },
		{ disabled: /*disabled*/ ctx[15] },
		{ min: /*min*/ ctx[17] },
		{ max: /*max*/ ctx[16] },
		{ step: /*step*/ ctx[18] },
		{ name: /*name*/ ctx[3] },
		{ id: /*inputId*/ ctx[5] },
		{ input: true },
		restProps(/*$$restProps*/ ctx[47]),
		{ lec: /*lec*/ ctx[1] }
	];

	let range_props = {};

	for (let i = 0; i < range_spread_levels.length; i += 1) {
		range_props = assign(range_props, range_spread_levels[i]);
	}

	range = new Range({ props: range_props });
	range.$on("rangeChange", /*onChange*/ ctx[46]);

	return {
		c() {
			create_component(range.$$.fragment);
		},
		l(nodes) {
			claim_component(range.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(range, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const range_changes = (dirty[0] & /*value, disabled, min, max, step, name, inputId, lec*/ 491563 | dirty[1] & /*$$restProps*/ 65536)
			? get_spread_update(range_spread_levels, [
					dirty[0] & /*value*/ 1 && { value: /*value*/ ctx[0] },
					dirty[0] & /*disabled*/ 32768 && { disabled: /*disabled*/ ctx[15] },
					dirty[0] & /*min*/ 131072 && { min: /*min*/ ctx[17] },
					dirty[0] & /*max*/ 65536 && { max: /*max*/ ctx[16] },
					dirty[0] & /*step*/ 262144 && { step: /*step*/ ctx[18] },
					dirty[0] & /*name*/ 8 && { name: /*name*/ ctx[3] },
					dirty[0] & /*inputId*/ 32 && { id: /*inputId*/ ctx[5] },
					range_spread_levels[7],
					dirty[1] & /*$$restProps*/ 65536 && get_spread_object(restProps(/*$$restProps*/ ctx[47])),
					dirty[0] & /*lec*/ 2 && { lec: /*lec*/ ctx[1] }
				])
			: {};

			range.$set(range_changes);
		},
		i(local) {
			if (current) return;
			transition_in(range.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(range.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(range, detaching);
		}
	};
}

// (595:28) 
function create_if_block_11$2(ctx) {
	let toggle;
	let current;

	const toggle_spread_levels = [
		{ checked: /*checked*/ ctx[14] },
		{ readonly: /*readonly*/ ctx[22] },
		{ name: /*name*/ ctx[3] },
		{ value: /*value*/ ctx[0] },
		{ disabled: /*disabled*/ ctx[15] },
		{ id: /*inputId*/ ctx[5] },
		restProps(/*$$restProps*/ ctx[47]),
		{ lec: /*lec*/ ctx[1] }
	];

	let toggle_props = {};

	for (let i = 0; i < toggle_spread_levels.length; i += 1) {
		toggle_props = assign(toggle_props, toggle_spread_levels[i]);
	}

	toggle = new Toggle({ props: toggle_props });
	toggle.$on("change", /*onChange*/ ctx[46]);

	return {
		c() {
			create_component(toggle.$$.fragment);
		},
		l(nodes) {
			claim_component(toggle.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(toggle, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const toggle_changes = (dirty[0] & /*checked, readonly, name, value, disabled, inputId, lec*/ 4243499 | dirty[1] & /*$$restProps*/ 65536)
			? get_spread_update(toggle_spread_levels, [
					dirty[0] & /*checked*/ 16384 && { checked: /*checked*/ ctx[14] },
					dirty[0] & /*readonly*/ 4194304 && { readonly: /*readonly*/ ctx[22] },
					dirty[0] & /*name*/ 8 && { name: /*name*/ ctx[3] },
					dirty[0] & /*value*/ 1 && { value: /*value*/ ctx[0] },
					dirty[0] & /*disabled*/ 32768 && { disabled: /*disabled*/ ctx[15] },
					dirty[0] & /*inputId*/ 32 && { id: /*inputId*/ ctx[5] },
					dirty[1] & /*$$restProps*/ 65536 && get_spread_object(restProps(/*$$restProps*/ ctx[47])),
					dirty[0] & /*lec*/ 2 && { lec: /*lec*/ ctx[1] }
				])
			: {};

			toggle.$set(toggle_changes);
		},
		i(local) {
			if (current) return;
			transition_in(toggle.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(toggle.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(toggle, detaching);
		}
	};
}

// (551:30) 
function create_if_block_10$3(ctx) {
	let textarea;
	let textarea_validate_value;
	let textarea_data_validate_value;
	let textarea_data_validate_on_blur_value;
	let textarea_data_error_message_value;
	let mounted;
	let dispose;

	let textarea_levels = [
		{ style: /*inputStyle*/ ctx[24] },
		{ name: /*name*/ ctx[3] },
		{ placeholder: /*placeholder*/ ctx[4] },
		{ id: /*inputId*/ ctx[5] },
		{ size: /*size*/ ctx[6] },
		{ accept: /*accept*/ ctx[7] },
		{ autocomplete: /*autocomplete*/ ctx[8] },
		{ autocorrect: /*autocorrect*/ ctx[9] },
		{
			autocapitalize: /*autocapitalize*/ ctx[10]
		},
		{ spellcheck: /*spellcheck*/ ctx[11] },
		{ autofocus: /*autofocus*/ ctx[12] },
		{ autosave: /*autosave*/ ctx[13] },
		{ checked: /*checked*/ ctx[14] },
		{ disabled: /*disabled*/ ctx[15] },
		{ max: /*max*/ ctx[16] },
		{ maxlength: /*maxlength*/ ctx[19] },
		{ min: /*min*/ ctx[17] },
		{ minlength: /*minlength*/ ctx[20] },
		{ step: /*step*/ ctx[18] },
		{ multiple: /*multiple*/ ctx[21] },
		{ readOnly: /*readonly*/ ctx[22] },
		{ required: /*required*/ ctx[23] },
		{ pattern: /*pattern*/ ctx[25] },
		{
			validate: textarea_validate_value = typeof /*validate*/ ctx[26] === 'string' && /*validate*/ ctx[26].length
			? /*validate*/ ctx[26]
			: undefined
		},
		{
			"data-validate": textarea_data_validate_value = /*validate*/ ctx[26] === true || /*validate*/ ctx[26] === '' || /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined
		},
		{
			"data-validate-on-blur": textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined
		},
		{ tabindex: /*tabindex*/ ctx[28] },
		{
			"data-error-message": textarea_data_error_message_value = /*errorMessageForce*/ ctx[32]
			? undefined
			: /*errorMessage*/ ctx[31]
		},
		{ class: /*inputClassName*/ ctx[40] },
		{ value: /*inputValue*/ ctx[42] },
		restProps(/*$$restProps*/ ctx[47])
	];

	let textarea_data = {};

	for (let i = 0; i < textarea_levels.length; i += 1) {
		textarea_data = assign(textarea_data, textarea_levels[i]);
	}

	return {
		c() {
			textarea = element("textarea");
			this.h();
		},
		l(nodes) {
			textarea = claim_element(nodes, "TEXTAREA", {
				style: true,
				name: true,
				placeholder: true,
				id: true,
				size: true,
				accept: true,
				autocomplete: true,
				autocorrect: true,
				autocapitalize: true,
				spellcheck: true,
				autosave: true,
				checked: true,
				max: true,
				maxlength: true,
				min: true,
				minlength: true,
				step: true,
				multiple: true,
				pattern: true,
				validate: true,
				"data-validate": true,
				"data-validate-on-blur": true,
				tabindex: true,
				"data-error-message": true,
				class: true
			});

			children(textarea).forEach(detach);
			this.h();
		},
		h() {
			set_attributes(textarea, textarea_data);
		},
		m(target, anchor) {
			insert_hydration(target, textarea, anchor);
			if (textarea.autofocus) textarea.focus();
			/*textarea_binding_1*/ ctx[65](textarea);

			if (!mounted) {
				dispose = [
					listen(textarea, "focus", /*onFocus*/ ctx[44]),
					listen(textarea, "blur", /*onBlur*/ ctx[45]),
					listen(textarea, "input", /*onInput*/ ctx[43]),
					listen(textarea, "change", /*onChange*/ ctx[46])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
				dirty[0] & /*inputStyle*/ 16777216 && { style: /*inputStyle*/ ctx[24] },
				dirty[0] & /*name*/ 8 && { name: /*name*/ ctx[3] },
				dirty[0] & /*placeholder*/ 16 && { placeholder: /*placeholder*/ ctx[4] },
				dirty[0] & /*inputId*/ 32 && { id: /*inputId*/ ctx[5] },
				dirty[0] & /*size*/ 64 && { size: /*size*/ ctx[6] },
				dirty[0] & /*accept*/ 128 && { accept: /*accept*/ ctx[7] },
				dirty[0] & /*autocomplete*/ 256 && { autocomplete: /*autocomplete*/ ctx[8] },
				dirty[0] & /*autocorrect*/ 512 && { autocorrect: /*autocorrect*/ ctx[9] },
				dirty[0] & /*autocapitalize*/ 1024 && {
					autocapitalize: /*autocapitalize*/ ctx[10]
				},
				dirty[0] & /*spellcheck*/ 2048 && { spellcheck: /*spellcheck*/ ctx[11] },
				dirty[0] & /*autofocus*/ 4096 && { autofocus: /*autofocus*/ ctx[12] },
				dirty[0] & /*autosave*/ 8192 && { autosave: /*autosave*/ ctx[13] },
				dirty[0] & /*checked*/ 16384 && { checked: /*checked*/ ctx[14] },
				dirty[0] & /*disabled*/ 32768 && { disabled: /*disabled*/ ctx[15] },
				dirty[0] & /*max*/ 65536 && { max: /*max*/ ctx[16] },
				dirty[0] & /*maxlength*/ 524288 && { maxlength: /*maxlength*/ ctx[19] },
				dirty[0] & /*min*/ 131072 && { min: /*min*/ ctx[17] },
				dirty[0] & /*minlength*/ 1048576 && { minlength: /*minlength*/ ctx[20] },
				dirty[0] & /*step*/ 262144 && { step: /*step*/ ctx[18] },
				dirty[0] & /*multiple*/ 2097152 && { multiple: /*multiple*/ ctx[21] },
				dirty[0] & /*readonly*/ 4194304 && { readOnly: /*readonly*/ ctx[22] },
				dirty[0] & /*required*/ 8388608 && { required: /*required*/ ctx[23] },
				dirty[0] & /*pattern*/ 33554432 && { pattern: /*pattern*/ ctx[25] },
				dirty[0] & /*validate*/ 67108864 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/ ctx[26] === 'string' && /*validate*/ ctx[26].length
				? /*validate*/ ctx[26]
				: undefined) && { validate: textarea_validate_value },
				dirty[0] & /*validate, validateOnBlur*/ 201326592 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/ ctx[26] === true || /*validate*/ ctx[26] === '' || /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
				? true
				: undefined) && {
					"data-validate": textarea_data_validate_value
				},
				dirty[0] & /*validateOnBlur*/ 134217728 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
				? true
				: undefined) && {
					"data-validate-on-blur": textarea_data_validate_on_blur_value
				},
				dirty[0] & /*tabindex*/ 268435456 && { tabindex: /*tabindex*/ ctx[28] },
				dirty[1] & /*errorMessageForce, errorMessage*/ 3 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/ ctx[32]
				? undefined
				: /*errorMessage*/ ctx[31]) && {
					"data-error-message": textarea_data_error_message_value
				},
				dirty[1] & /*inputClassName*/ 512 && { class: /*inputClassName*/ ctx[40] },
				dirty[1] & /*inputValue*/ 2048 && { value: /*inputValue*/ ctx[42] },
				dirty[1] & /*$$restProps*/ 65536 && restProps(/*$$restProps*/ ctx[47])
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(textarea);
			/*textarea_binding_1*/ ctx[65](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (505:28) 
function create_if_block_9$3(ctx) {
	let select;
	let select_validate_value;
	let select_data_validate_value;
	let select_data_validate_on_blur_value;
	let select_data_error_message_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[60].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[59], null);

	let select_levels = [
		{ style: /*inputStyle*/ ctx[24] },
		{ name: /*name*/ ctx[3] },
		{ placeholder: /*placeholder*/ ctx[4] },
		{ id: /*inputId*/ ctx[5] },
		{ size: /*size*/ ctx[6] },
		{ accept: /*accept*/ ctx[7] },
		{ autocomplete: /*autocomplete*/ ctx[8] },
		{ autocorrect: /*autocorrect*/ ctx[9] },
		{
			autocapitalize: /*autocapitalize*/ ctx[10]
		},
		{ spellcheck: /*spellcheck*/ ctx[11] },
		{ autofocus: /*autofocus*/ ctx[12] },
		{ autosave: /*autosave*/ ctx[13] },
		{ checked: /*checked*/ ctx[14] },
		{ disabled: /*disabled*/ ctx[15] },
		{ max: /*max*/ ctx[16] },
		{ maxlength: /*maxlength*/ ctx[19] },
		{ min: /*min*/ ctx[17] },
		{ minlength: /*minlength*/ ctx[20] },
		{ step: /*step*/ ctx[18] },
		{ multiple: /*multiple*/ ctx[21] },
		{ readonly: /*readonly*/ ctx[22] },
		{ required: /*required*/ ctx[23] },
		{ pattern: /*pattern*/ ctx[25] },
		{
			validate: select_validate_value = typeof /*validate*/ ctx[26] === 'string' && /*validate*/ ctx[26].length
			? /*validate*/ ctx[26]
			: undefined
		},
		{
			"data-validate": select_data_validate_value = /*validate*/ ctx[26] === true || /*validate*/ ctx[26] === '' || /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined
		},
		{
			"data-validate-on-blur": select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined
		},
		{ tabindex: /*tabindex*/ ctx[28] },
		{
			"data-error-message": select_data_error_message_value = /*errorMessageForce*/ ctx[32]
			? undefined
			: /*errorMessage*/ ctx[31]
		},
		{ class: /*inputClassName*/ ctx[40] },
		{ value: /*inputValue*/ ctx[42] },
		restProps(/*$$restProps*/ ctx[47])
	];

	let select_data = {};

	for (let i = 0; i < select_levels.length; i += 1) {
		select_data = assign(select_data, select_levels[i]);
	}

	return {
		c() {
			select = element("select");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			select = claim_element(nodes, "SELECT", {
				style: true,
				name: true,
				placeholder: true,
				id: true,
				size: true,
				accept: true,
				autocomplete: true,
				autocorrect: true,
				autocapitalize: true,
				spellcheck: true,
				autosave: true,
				checked: true,
				max: true,
				maxlength: true,
				min: true,
				minlength: true,
				step: true,
				readonly: true,
				pattern: true,
				validate: true,
				"data-validate": true,
				"data-validate-on-blur": true,
				tabindex: true,
				"data-error-message": true,
				class: true
			});

			var select_nodes = children(select);
			if (default_slot) default_slot.l(select_nodes);
			select_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(select, select_data);
		},
		m(target, anchor) {
			insert_hydration(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			(select_data.multiple ? select_options : select_option)(select, select_data.value);
			if (select.autofocus) select.focus();
			/*select_binding_1*/ ctx[64](select);
			current = true;

			if (!mounted) {
				dispose = [
					listen(select, "focus", /*onFocus*/ ctx[44]),
					listen(select, "blur", /*onBlur*/ ctx[45]),
					listen(select, "input", /*onInput*/ ctx[43]),
					listen(select, "change", /*onChange*/ ctx[46])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 268435456)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[59],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[59])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[59], dirty, null),
						null
					);
				}
			}

			set_attributes(select, select_data = get_spread_update(select_levels, [
				(!current || dirty[0] & /*inputStyle*/ 16777216) && { style: /*inputStyle*/ ctx[24] },
				(!current || dirty[0] & /*name*/ 8) && { name: /*name*/ ctx[3] },
				(!current || dirty[0] & /*placeholder*/ 16) && { placeholder: /*placeholder*/ ctx[4] },
				(!current || dirty[0] & /*inputId*/ 32) && { id: /*inputId*/ ctx[5] },
				(!current || dirty[0] & /*size*/ 64) && { size: /*size*/ ctx[6] },
				(!current || dirty[0] & /*accept*/ 128) && { accept: /*accept*/ ctx[7] },
				(!current || dirty[0] & /*autocomplete*/ 256) && { autocomplete: /*autocomplete*/ ctx[8] },
				(!current || dirty[0] & /*autocorrect*/ 512) && { autocorrect: /*autocorrect*/ ctx[9] },
				(!current || dirty[0] & /*autocapitalize*/ 1024) && {
					autocapitalize: /*autocapitalize*/ ctx[10]
				},
				(!current || dirty[0] & /*spellcheck*/ 2048) && { spellcheck: /*spellcheck*/ ctx[11] },
				(!current || dirty[0] & /*autofocus*/ 4096) && { autofocus: /*autofocus*/ ctx[12] },
				(!current || dirty[0] & /*autosave*/ 8192) && { autosave: /*autosave*/ ctx[13] },
				(!current || dirty[0] & /*checked*/ 16384) && { checked: /*checked*/ ctx[14] },
				(!current || dirty[0] & /*disabled*/ 32768) && { disabled: /*disabled*/ ctx[15] },
				(!current || dirty[0] & /*max*/ 65536) && { max: /*max*/ ctx[16] },
				(!current || dirty[0] & /*maxlength*/ 524288) && { maxlength: /*maxlength*/ ctx[19] },
				(!current || dirty[0] & /*min*/ 131072) && { min: /*min*/ ctx[17] },
				(!current || dirty[0] & /*minlength*/ 1048576) && { minlength: /*minlength*/ ctx[20] },
				(!current || dirty[0] & /*step*/ 262144) && { step: /*step*/ ctx[18] },
				(!current || dirty[0] & /*multiple*/ 2097152) && { multiple: /*multiple*/ ctx[21] },
				(!current || dirty[0] & /*readonly*/ 4194304) && { readonly: /*readonly*/ ctx[22] },
				(!current || dirty[0] & /*required*/ 8388608) && { required: /*required*/ ctx[23] },
				(!current || dirty[0] & /*pattern*/ 33554432) && { pattern: /*pattern*/ ctx[25] },
				(!current || dirty[0] & /*validate*/ 67108864 && select_validate_value !== (select_validate_value = typeof /*validate*/ ctx[26] === 'string' && /*validate*/ ctx[26].length
				? /*validate*/ ctx[26]
				: undefined)) && { validate: select_validate_value },
				(!current || dirty[0] & /*validate, validateOnBlur*/ 201326592 && select_data_validate_value !== (select_data_validate_value = /*validate*/ ctx[26] === true || /*validate*/ ctx[26] === '' || /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
				? true
				: undefined)) && {
					"data-validate": select_data_validate_value
				},
				(!current || dirty[0] & /*validateOnBlur*/ 134217728 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
				? true
				: undefined)) && {
					"data-validate-on-blur": select_data_validate_on_blur_value
				},
				(!current || dirty[0] & /*tabindex*/ 268435456) && { tabindex: /*tabindex*/ ctx[28] },
				(!current || dirty[1] & /*errorMessageForce, errorMessage*/ 3 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/ ctx[32]
				? undefined
				: /*errorMessage*/ ctx[31])) && {
					"data-error-message": select_data_error_message_value
				},
				(!current || dirty[1] & /*inputClassName*/ 512) && { class: /*inputClassName*/ ctx[40] },
				(!current || dirty[1] & /*inputValue*/ 2048) && { value: /*inputValue*/ ctx[42] },
				dirty[1] & /*$$restProps*/ 65536 && restProps(/*$$restProps*/ ctx[47])
			]));

			if (dirty[0] & /*inputStyle, name, placeholder, inputId, size, accept, autocomplete, autocorrect, autocapitalize, spellcheck, autofocus, autosave, checked, disabled, max, maxlength, min, minlength, step, multiple, readonly, required, pattern, validate, validateOnBlur, tabindex*/ 536870904 | dirty[1] & /*errorMessageForce, errorMessage, inputClassName, inputValue, $$restProps*/ 68099 && 'value' in select_data) (select_data.multiple ? select_options : select_option)(select, select_data.value);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(select);
			if (default_slot) default_slot.d(detaching);
			/*select_binding_1*/ ctx[64](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (331:0) {#if wrap}
function create_if_block$q(ctx) {
	let div;
	let current_block_type_index;
	let if_block0;
	let t0;
	let t1;
	let t2;
	let current;

	const if_block_creators = [
		create_if_block_4$6,
		create_if_block_5$4,
		create_if_block_6$3,
		create_if_block_7$3,
		create_if_block_8$3,
		create_else_block$c
	];

	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*type*/ ctx[2] === 'select') return 0;
		if (/*type*/ ctx[2] === 'textarea') return 1;
		if (/*type*/ ctx[2] === 'toggle') return 2;
		if (/*type*/ ctx[2] === 'range') return 3;
		if (/*type*/ ctx[2] === 'texteditor') return 4;
		return 5;
	}

	current_block_type_index = select_block_type_1(ctx, [-1, -1, -1]);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = (/*errorMessage*/ ctx[31] || /*hasErrorSlots*/ ctx[38]) && /*errorMessageForce*/ ctx[32] && create_if_block_3$a(ctx);
	let if_block2 = /*clearButton*/ ctx[30] && create_if_block_2$c(ctx);
	let if_block3 = (/*info*/ ctx[33] || /*hasInfoSlots*/ ctx[39]) && create_if_block_1$h(ctx);
	let div_levels = [{ class: /*wrapClasses*/ ctx[41] }, restProps(/*$$restProps*/ ctx[47])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block2) if_block2.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (if_block3) if_block3.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			append_hydration(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t1);
			if (if_block2) if_block2.m(div, null);
			append_hydration(div, t2);
			if (if_block3) if_block3.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(div, t0);
			}

			if ((/*errorMessage*/ ctx[31] || /*hasErrorSlots*/ ctx[38]) && /*errorMessageForce*/ ctx[32]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*errorMessage, hasErrorSlots, errorMessageForce*/ 131) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3$a(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*clearButton*/ ctx[30]) {
				if (if_block2) {
					
				} else {
					if_block2 = create_if_block_2$c(ctx);
					if_block2.c();
					if_block2.m(div, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*info*/ ctx[33] || /*hasInfoSlots*/ ctx[39]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*info, hasInfoSlots*/ 260) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_1$h(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div, null);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[1] & /*wrapClasses*/ 1024) && { class: /*wrapClasses*/ ctx[41] },
				dirty[1] & /*$$restProps*/ 65536 && restProps(/*$$restProps*/ ctx[47])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block3);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block3);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
		}
	};
}

// (446:4) {:else}
function create_else_block$c(ctx) {
	let input;
	let input_validate_value;
	let input_data_validate_value;
	let input_data_validate_on_blur_value;
	let input_data_error_message_value;
	let input_value_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			this.h();
		},
		l(nodes) {
			input = claim_element(nodes, "INPUT", {
				style: true,
				name: true,
				type: true,
				placeholder: true,
				id: true,
				size: true,
				accept: true,
				autocomplete: true,
				autocorrect: true,
				autocapitalize: true,
				spellcheck: true,
				autosave: true,
				max: true,
				maxlength: true,
				min: true,
				minlength: true,
				step: true,
				pattern: true,
				validate: true,
				"data-validate": true,
				"data-validate-on-blur": true,
				tabindex: true,
				"data-error-message": true,
				class: true
			});

			this.h();
		},
		h() {
			attr(input, "style", /*inputStyle*/ ctx[24]);
			attr(input, "name", /*name*/ ctx[3]);
			attr(input, "type", /*inputType*/ ctx[36]);
			attr(input, "placeholder", /*placeholder*/ ctx[4]);
			attr(input, "id", /*inputId*/ ctx[5]);
			attr(input, "size", /*size*/ ctx[6]);
			attr(input, "accept", /*accept*/ ctx[7]);
			attr(input, "autocomplete", /*autocomplete*/ ctx[8]);
			attr(input, "autocorrect", /*autocorrect*/ ctx[9]);
			attr(input, "autocapitalize", /*autocapitalize*/ ctx[10]);
			attr(input, "spellcheck", /*spellcheck*/ ctx[11]);
			input.autofocus = /*autofocus*/ ctx[12];
			attr(input, "autosave", /*autosave*/ ctx[13]);
			input.checked = /*checked*/ ctx[14];
			input.disabled = /*disabled*/ ctx[15];
			attr(input, "max", /*max*/ ctx[16]);
			attr(input, "maxlength", /*maxlength*/ ctx[19]);
			attr(input, "min", /*min*/ ctx[17]);
			attr(input, "minlength", /*minlength*/ ctx[20]);
			attr(input, "step", /*step*/ ctx[18]);
			input.multiple = /*multiple*/ ctx[21];
			input.readOnly = /*readonly*/ ctx[22];
			input.required = /*required*/ ctx[23];
			attr(input, "pattern", /*pattern*/ ctx[25]);

			attr(input, "validate", input_validate_value = typeof /*validate*/ ctx[26] === 'string' && /*validate*/ ctx[26].length
			? /*validate*/ ctx[26]
			: undefined);

			attr(input, "data-validate", input_data_validate_value = /*validate*/ ctx[26] === true || /*validate*/ ctx[26] === '' || /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined);

			attr(input, "data-validate-on-blur", input_data_validate_on_blur_value = /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined);

			attr(input, "tabindex", /*tabindex*/ ctx[28]);

			attr(input, "data-error-message", input_data_error_message_value = /*errorMessageForce*/ ctx[32]
			? undefined
			: /*errorMessage*/ ctx[31]);

			attr(input, "class", /*inputClassName*/ ctx[40]);

			input.value = input_value_value = /*type*/ ctx[2] === 'datepicker' || /*type*/ ctx[2] === 'colorpicker' || /*type*/ ctx[2] === 'file'
			? ''
			: /*inputValue*/ ctx[42];
		},
		m(target, anchor) {
			insert_hydration(target, input, anchor);
			/*input_binding*/ ctx[63](input);
			if (/*autofocus*/ ctx[12]) input.focus();

			if (!mounted) {
				dispose = [
					listen(input, "focus", /*onFocus*/ ctx[44]),
					listen(input, "blur", /*onBlur*/ ctx[45]),
					listen(input, "input", /*onInput*/ ctx[43]),
					listen(input, "change", /*onChange*/ ctx[46])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 16777216) {
				attr(input, "style", /*inputStyle*/ ctx[24]);
			}

			if (dirty[0] & /*name*/ 8) {
				attr(input, "name", /*name*/ ctx[3]);
			}

			if (dirty[1] & /*inputType*/ 32) {
				attr(input, "type", /*inputType*/ ctx[36]);
			}

			if (dirty[0] & /*placeholder*/ 16) {
				attr(input, "placeholder", /*placeholder*/ ctx[4]);
			}

			if (dirty[0] & /*inputId*/ 32) {
				attr(input, "id", /*inputId*/ ctx[5]);
			}

			if (dirty[0] & /*size*/ 64) {
				attr(input, "size", /*size*/ ctx[6]);
			}

			if (dirty[0] & /*accept*/ 128) {
				attr(input, "accept", /*accept*/ ctx[7]);
			}

			if (dirty[0] & /*autocomplete*/ 256) {
				attr(input, "autocomplete", /*autocomplete*/ ctx[8]);
			}

			if (dirty[0] & /*autocorrect*/ 512) {
				attr(input, "autocorrect", /*autocorrect*/ ctx[9]);
			}

			if (dirty[0] & /*autocapitalize*/ 1024) {
				attr(input, "autocapitalize", /*autocapitalize*/ ctx[10]);
			}

			if (dirty[0] & /*spellcheck*/ 2048) {
				attr(input, "spellcheck", /*spellcheck*/ ctx[11]);
			}

			if (dirty[0] & /*autofocus*/ 4096) {
				input.autofocus = /*autofocus*/ ctx[12];
			}

			if (dirty[0] & /*autosave*/ 8192) {
				attr(input, "autosave", /*autosave*/ ctx[13]);
			}

			if (dirty[0] & /*checked*/ 16384) {
				input.checked = /*checked*/ ctx[14];
			}

			if (dirty[0] & /*disabled*/ 32768) {
				input.disabled = /*disabled*/ ctx[15];
			}

			if (dirty[0] & /*max*/ 65536) {
				attr(input, "max", /*max*/ ctx[16]);
			}

			if (dirty[0] & /*maxlength*/ 524288) {
				attr(input, "maxlength", /*maxlength*/ ctx[19]);
			}

			if (dirty[0] & /*min*/ 131072) {
				attr(input, "min", /*min*/ ctx[17]);
			}

			if (dirty[0] & /*minlength*/ 1048576) {
				attr(input, "minlength", /*minlength*/ ctx[20]);
			}

			if (dirty[0] & /*step*/ 262144) {
				attr(input, "step", /*step*/ ctx[18]);
			}

			if (dirty[0] & /*multiple*/ 2097152) {
				input.multiple = /*multiple*/ ctx[21];
			}

			if (dirty[0] & /*readonly*/ 4194304) {
				input.readOnly = /*readonly*/ ctx[22];
			}

			if (dirty[0] & /*required*/ 8388608) {
				input.required = /*required*/ ctx[23];
			}

			if (dirty[0] & /*pattern*/ 33554432) {
				attr(input, "pattern", /*pattern*/ ctx[25]);
			}

			if (dirty[0] & /*validate*/ 67108864 && input_validate_value !== (input_validate_value = typeof /*validate*/ ctx[26] === 'string' && /*validate*/ ctx[26].length
			? /*validate*/ ctx[26]
			: undefined)) {
				attr(input, "validate", input_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 201326592 && input_data_validate_value !== (input_data_validate_value = /*validate*/ ctx[26] === true || /*validate*/ ctx[26] === '' || /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined)) {
				attr(input, "data-validate", input_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 134217728 && input_data_validate_on_blur_value !== (input_data_validate_on_blur_value = /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined)) {
				attr(input, "data-validate-on-blur", input_data_validate_on_blur_value);
			}

			if (dirty[0] & /*tabindex*/ 268435456) {
				attr(input, "tabindex", /*tabindex*/ ctx[28]);
			}

			if (dirty[1] & /*errorMessageForce, errorMessage*/ 3 && input_data_error_message_value !== (input_data_error_message_value = /*errorMessageForce*/ ctx[32]
			? undefined
			: /*errorMessage*/ ctx[31])) {
				attr(input, "data-error-message", input_data_error_message_value);
			}

			if (dirty[1] & /*inputClassName*/ 512) {
				attr(input, "class", /*inputClassName*/ ctx[40]);
			}

			if (dirty[0] & /*type*/ 4 | dirty[1] & /*inputValue*/ 2048 && input_value_value !== (input_value_value = /*type*/ ctx[2] === 'datepicker' || /*type*/ ctx[2] === 'colorpicker' || /*type*/ ctx[2] === 'file'
			? ''
			: /*inputValue*/ ctx[42]) && input.value !== input_value_value) {
				input.value = input_value_value;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(input);
			/*input_binding*/ ctx[63](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (435:36) 
function create_if_block_8$3(ctx) {
	let texteditor;
	let current;

	const texteditor_spread_levels = [
		{
			value: typeof /*value*/ ctx[0] === 'undefined'
			? ''
			: /*value*/ ctx[0]
		},
		{ resizable: /*resizable*/ ctx[29] },
		{ placeholder: /*placeholder*/ ctx[4] },
		{ onTextEditorFocus: /*onFocus*/ ctx[44] },
		{ onTextEditorBlur: /*onBlur*/ ctx[45] },
		{ onTextEditorInput: /*onInput*/ ctx[43] },
		{ onTextEditorChange: /*onChange*/ ctx[46] },
		/*textEditorParams*/ ctx[35],
		{ lec: /*lec*/ ctx[1] }
	];

	let texteditor_props = {};

	for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
		texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
	}

	texteditor = new Text_editor({ props: texteditor_props });

	return {
		c() {
			create_component(texteditor.$$.fragment);
		},
		l(nodes) {
			claim_component(texteditor.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(texteditor, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const texteditor_changes = (dirty[0] & /*value, resizable, placeholder, lec*/ 536870931 | dirty[1] & /*onFocus, onBlur, onInput, onChange, textEditorParams*/ 61456)
			? get_spread_update(texteditor_spread_levels, [
					dirty[0] & /*value*/ 1 && {
						value: typeof /*value*/ ctx[0] === 'undefined'
						? ''
						: /*value*/ ctx[0]
					},
					dirty[0] & /*resizable*/ 536870912 && { resizable: /*resizable*/ ctx[29] },
					dirty[0] & /*placeholder*/ 16 && { placeholder: /*placeholder*/ ctx[4] },
					dirty[1] & /*onFocus*/ 8192 && { onTextEditorFocus: /*onFocus*/ ctx[44] },
					dirty[1] & /*onBlur*/ 16384 && { onTextEditorBlur: /*onBlur*/ ctx[45] },
					dirty[1] & /*onInput*/ 4096 && { onTextEditorInput: /*onInput*/ ctx[43] },
					dirty[1] & /*onChange*/ 32768 && { onTextEditorChange: /*onChange*/ ctx[46] },
					dirty[1] & /*textEditorParams*/ 16 && get_spread_object(/*textEditorParams*/ ctx[35]),
					dirty[0] & /*lec*/ 2 && { lec: /*lec*/ ctx[1] }
				])
			: {};

			texteditor.$set(texteditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(texteditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(texteditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(texteditor, detaching);
		}
	};
}

// (423:31) 
function create_if_block_7$3(ctx) {
	let range;
	let current;

	range = new Range({
			props: {
				value: /*value*/ ctx[0],
				disabled: /*disabled*/ ctx[15],
				min: /*min*/ ctx[17],
				max: /*max*/ ctx[16],
				step: /*step*/ ctx[18],
				name: /*name*/ ctx[3],
				id: /*inputId*/ ctx[5],
				input: true,
				lec: /*lec*/ ctx[1]
			}
		});

	range.$on("rangeChange", /*onChange*/ ctx[46]);

	return {
		c() {
			create_component(range.$$.fragment);
		},
		l(nodes) {
			claim_component(range.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(range, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const range_changes = {};
			if (dirty[0] & /*value*/ 1) range_changes.value = /*value*/ ctx[0];
			if (dirty[0] & /*disabled*/ 32768) range_changes.disabled = /*disabled*/ ctx[15];
			if (dirty[0] & /*min*/ 131072) range_changes.min = /*min*/ ctx[17];
			if (dirty[0] & /*max*/ 65536) range_changes.max = /*max*/ ctx[16];
			if (dirty[0] & /*step*/ 262144) range_changes.step = /*step*/ ctx[18];
			if (dirty[0] & /*name*/ 8) range_changes.name = /*name*/ ctx[3];
			if (dirty[0] & /*inputId*/ 32) range_changes.id = /*inputId*/ ctx[5];
			if (dirty[0] & /*lec*/ 2) range_changes.lec = /*lec*/ ctx[1];
			range.$set(range_changes);
		},
		i(local) {
			if (current) return;
			transition_in(range.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(range.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(range, detaching);
		}
	};
}

// (421:32) 
function create_if_block_6$3(ctx) {
	let toggle;
	let current;

	toggle = new Toggle({
			props: {
				checked: /*checked*/ ctx[14],
				readonly: /*readonly*/ ctx[22],
				name: /*name*/ ctx[3],
				value: /*value*/ ctx[0],
				disabled: /*disabled*/ ctx[15],
				id: /*inputId*/ ctx[5],
				lec: /*lec*/ ctx[1]
			}
		});

	toggle.$on("change", /*onChange*/ ctx[46]);

	return {
		c() {
			create_component(toggle.$$.fragment);
		},
		l(nodes) {
			claim_component(toggle.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(toggle, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const toggle_changes = {};
			if (dirty[0] & /*checked*/ 16384) toggle_changes.checked = /*checked*/ ctx[14];
			if (dirty[0] & /*readonly*/ 4194304) toggle_changes.readonly = /*readonly*/ ctx[22];
			if (dirty[0] & /*name*/ 8) toggle_changes.name = /*name*/ ctx[3];
			if (dirty[0] & /*value*/ 1) toggle_changes.value = /*value*/ ctx[0];
			if (dirty[0] & /*disabled*/ 32768) toggle_changes.disabled = /*disabled*/ ctx[15];
			if (dirty[0] & /*inputId*/ 32) toggle_changes.id = /*inputId*/ ctx[5];
			if (dirty[0] & /*lec*/ 2) toggle_changes.lec = /*lec*/ ctx[1];
			toggle.$set(toggle_changes);
		},
		i(local) {
			if (current) return;
			transition_in(toggle.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(toggle.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(toggle, detaching);
		}
	};
}

// (378:34) 
function create_if_block_5$4(ctx) {
	let textarea;
	let textarea_validate_value;
	let textarea_data_validate_value;
	let textarea_data_validate_on_blur_value;
	let textarea_data_error_message_value;
	let mounted;
	let dispose;

	return {
		c() {
			textarea = element("textarea");
			this.h();
		},
		l(nodes) {
			textarea = claim_element(nodes, "TEXTAREA", {
				style: true,
				name: true,
				placeholder: true,
				id: true,
				size: true,
				accept: true,
				autocomplete: true,
				autocorrect: true,
				autocapitalize: true,
				spellcheck: true,
				autosave: true,
				checked: true,
				max: true,
				maxlength: true,
				min: true,
				minlength: true,
				step: true,
				multiple: true,
				pattern: true,
				validate: true,
				"data-validate": true,
				"data-validate-on-blur": true,
				tabindex: true,
				"data-error-message": true,
				class: true
			});

			children(textarea).forEach(detach);
			this.h();
		},
		h() {
			attr(textarea, "style", /*inputStyle*/ ctx[24]);
			attr(textarea, "name", /*name*/ ctx[3]);
			attr(textarea, "placeholder", /*placeholder*/ ctx[4]);
			attr(textarea, "id", /*inputId*/ ctx[5]);
			attr(textarea, "size", /*size*/ ctx[6]);
			attr(textarea, "accept", /*accept*/ ctx[7]);
			attr(textarea, "autocomplete", /*autocomplete*/ ctx[8]);
			attr(textarea, "autocorrect", /*autocorrect*/ ctx[9]);
			attr(textarea, "autocapitalize", /*autocapitalize*/ ctx[10]);
			attr(textarea, "spellcheck", /*spellcheck*/ ctx[11]);
			textarea.autofocus = /*autofocus*/ ctx[12];
			attr(textarea, "autosave", /*autosave*/ ctx[13]);
			attr(textarea, "checked", /*checked*/ ctx[14]);
			textarea.disabled = /*disabled*/ ctx[15];
			attr(textarea, "max", /*max*/ ctx[16]);
			attr(textarea, "maxlength", /*maxlength*/ ctx[19]);
			attr(textarea, "min", /*min*/ ctx[17]);
			attr(textarea, "minlength", /*minlength*/ ctx[20]);
			attr(textarea, "step", /*step*/ ctx[18]);
			attr(textarea, "multiple", /*multiple*/ ctx[21]);
			textarea.readOnly = /*readonly*/ ctx[22];
			textarea.required = /*required*/ ctx[23];
			attr(textarea, "pattern", /*pattern*/ ctx[25]);

			attr(textarea, "validate", textarea_validate_value = typeof /*validate*/ ctx[26] === 'string' && /*validate*/ ctx[26].length
			? /*validate*/ ctx[26]
			: undefined);

			attr(textarea, "data-validate", textarea_data_validate_value = /*validate*/ ctx[26] === true || /*validate*/ ctx[26] === '' || /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined);

			attr(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined);

			attr(textarea, "tabindex", /*tabindex*/ ctx[28]);

			attr(textarea, "data-error-message", textarea_data_error_message_value = /*errorMessageForce*/ ctx[32]
			? undefined
			: /*errorMessage*/ ctx[31]);

			attr(textarea, "class", /*inputClassName*/ ctx[40]);
			textarea.value = /*inputValue*/ ctx[42];
		},
		m(target, anchor) {
			insert_hydration(target, textarea, anchor);
			/*textarea_binding*/ ctx[62](textarea);
			if (/*autofocus*/ ctx[12]) textarea.focus();

			if (!mounted) {
				dispose = [
					listen(textarea, "focus", /*onFocus*/ ctx[44]),
					listen(textarea, "blur", /*onBlur*/ ctx[45]),
					listen(textarea, "input", /*onInput*/ ctx[43]),
					listen(textarea, "change", /*onChange*/ ctx[46])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 16777216) {
				attr(textarea, "style", /*inputStyle*/ ctx[24]);
			}

			if (dirty[0] & /*name*/ 8) {
				attr(textarea, "name", /*name*/ ctx[3]);
			}

			if (dirty[0] & /*placeholder*/ 16) {
				attr(textarea, "placeholder", /*placeholder*/ ctx[4]);
			}

			if (dirty[0] & /*inputId*/ 32) {
				attr(textarea, "id", /*inputId*/ ctx[5]);
			}

			if (dirty[0] & /*size*/ 64) {
				attr(textarea, "size", /*size*/ ctx[6]);
			}

			if (dirty[0] & /*accept*/ 128) {
				attr(textarea, "accept", /*accept*/ ctx[7]);
			}

			if (dirty[0] & /*autocomplete*/ 256) {
				attr(textarea, "autocomplete", /*autocomplete*/ ctx[8]);
			}

			if (dirty[0] & /*autocorrect*/ 512) {
				attr(textarea, "autocorrect", /*autocorrect*/ ctx[9]);
			}

			if (dirty[0] & /*autocapitalize*/ 1024) {
				attr(textarea, "autocapitalize", /*autocapitalize*/ ctx[10]);
			}

			if (dirty[0] & /*spellcheck*/ 2048) {
				attr(textarea, "spellcheck", /*spellcheck*/ ctx[11]);
			}

			if (dirty[0] & /*autofocus*/ 4096) {
				textarea.autofocus = /*autofocus*/ ctx[12];
			}

			if (dirty[0] & /*autosave*/ 8192) {
				attr(textarea, "autosave", /*autosave*/ ctx[13]);
			}

			if (dirty[0] & /*checked*/ 16384) {
				attr(textarea, "checked", /*checked*/ ctx[14]);
			}

			if (dirty[0] & /*disabled*/ 32768) {
				textarea.disabled = /*disabled*/ ctx[15];
			}

			if (dirty[0] & /*max*/ 65536) {
				attr(textarea, "max", /*max*/ ctx[16]);
			}

			if (dirty[0] & /*maxlength*/ 524288) {
				attr(textarea, "maxlength", /*maxlength*/ ctx[19]);
			}

			if (dirty[0] & /*min*/ 131072) {
				attr(textarea, "min", /*min*/ ctx[17]);
			}

			if (dirty[0] & /*minlength*/ 1048576) {
				attr(textarea, "minlength", /*minlength*/ ctx[20]);
			}

			if (dirty[0] & /*step*/ 262144) {
				attr(textarea, "step", /*step*/ ctx[18]);
			}

			if (dirty[0] & /*multiple*/ 2097152) {
				attr(textarea, "multiple", /*multiple*/ ctx[21]);
			}

			if (dirty[0] & /*readonly*/ 4194304) {
				textarea.readOnly = /*readonly*/ ctx[22];
			}

			if (dirty[0] & /*required*/ 8388608) {
				textarea.required = /*required*/ ctx[23];
			}

			if (dirty[0] & /*pattern*/ 33554432) {
				attr(textarea, "pattern", /*pattern*/ ctx[25]);
			}

			if (dirty[0] & /*validate*/ 67108864 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/ ctx[26] === 'string' && /*validate*/ ctx[26].length
			? /*validate*/ ctx[26]
			: undefined)) {
				attr(textarea, "validate", textarea_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 201326592 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/ ctx[26] === true || /*validate*/ ctx[26] === '' || /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined)) {
				attr(textarea, "data-validate", textarea_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 134217728 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined)) {
				attr(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value);
			}

			if (dirty[0] & /*tabindex*/ 268435456) {
				attr(textarea, "tabindex", /*tabindex*/ ctx[28]);
			}

			if (dirty[1] & /*errorMessageForce, errorMessage*/ 3 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/ ctx[32]
			? undefined
			: /*errorMessage*/ ctx[31])) {
				attr(textarea, "data-error-message", textarea_data_error_message_value);
			}

			if (dirty[1] & /*inputClassName*/ 512) {
				attr(textarea, "class", /*inputClassName*/ ctx[40]);
			}

			if (dirty[1] & /*inputValue*/ 2048) {
				textarea.value = /*inputValue*/ ctx[42];
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(textarea);
			/*textarea_binding*/ ctx[62](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (333:4) {#if type === 'select'}
function create_if_block_4$6(ctx) {
	let select;
	let select_validate_value;
	let select_data_validate_value;
	let select_data_validate_on_blur_value;
	let select_data_error_message_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[60].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[59], null);

	return {
		c() {
			select = element("select");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			select = claim_element(nodes, "SELECT", {
				style: true,
				name: true,
				placeholder: true,
				id: true,
				size: true,
				accept: true,
				autocomplete: true,
				autocorrect: true,
				autocapitalize: true,
				spellcheck: true,
				autosave: true,
				checked: true,
				max: true,
				maxlength: true,
				min: true,
				minlength: true,
				step: true,
				readonly: true,
				pattern: true,
				validate: true,
				"data-validate": true,
				"data-validate-on-blur": true,
				tabindex: true,
				"data-error-message": true,
				class: true
			});

			var select_nodes = children(select);
			if (default_slot) default_slot.l(select_nodes);
			select_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(select, "style", /*inputStyle*/ ctx[24]);
			attr(select, "name", /*name*/ ctx[3]);
			attr(select, "placeholder", /*placeholder*/ ctx[4]);
			attr(select, "id", /*inputId*/ ctx[5]);
			attr(select, "size", /*size*/ ctx[6]);
			attr(select, "accept", /*accept*/ ctx[7]);
			attr(select, "autocomplete", /*autocomplete*/ ctx[8]);
			attr(select, "autocorrect", /*autocorrect*/ ctx[9]);
			attr(select, "autocapitalize", /*autocapitalize*/ ctx[10]);
			attr(select, "spellcheck", /*spellcheck*/ ctx[11]);
			select.autofocus = /*autofocus*/ ctx[12];
			attr(select, "autosave", /*autosave*/ ctx[13]);
			attr(select, "checked", /*checked*/ ctx[14]);
			select.disabled = /*disabled*/ ctx[15];
			attr(select, "max", /*max*/ ctx[16]);
			attr(select, "maxlength", /*maxlength*/ ctx[19]);
			attr(select, "min", /*min*/ ctx[17]);
			attr(select, "minlength", /*minlength*/ ctx[20]);
			attr(select, "step", /*step*/ ctx[18]);
			select.multiple = /*multiple*/ ctx[21];
			attr(select, "readonly", /*readonly*/ ctx[22]);
			select.required = /*required*/ ctx[23];
			attr(select, "pattern", /*pattern*/ ctx[25]);

			attr(select, "validate", select_validate_value = typeof /*validate*/ ctx[26] === 'string' && /*validate*/ ctx[26].length
			? /*validate*/ ctx[26]
			: undefined);

			attr(select, "data-validate", select_data_validate_value = /*validate*/ ctx[26] === true || /*validate*/ ctx[26] === '' || /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined);

			attr(select, "data-validate-on-blur", select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined);

			attr(select, "tabindex", /*tabindex*/ ctx[28]);

			attr(select, "data-error-message", select_data_error_message_value = /*errorMessageForce*/ ctx[32]
			? undefined
			: /*errorMessage*/ ctx[31]);

			attr(select, "class", /*inputClassName*/ ctx[40]);
		},
		m(target, anchor) {
			insert_hydration(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			select_option(select, /*inputValue*/ ctx[42]);
			/*select_binding*/ ctx[61](select);
			current = true;
			if (/*autofocus*/ ctx[12]) select.focus();

			if (!mounted) {
				dispose = [
					listen(select, "focus", /*onFocus*/ ctx[44]),
					listen(select, "blur", /*onBlur*/ ctx[45]),
					listen(select, "input", /*onInput*/ ctx[43]),
					listen(select, "change", /*onChange*/ ctx[46])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 268435456)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[59],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[59])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[59], dirty, null),
						null
					);
				}
			}

			if (!current || dirty[0] & /*inputStyle*/ 16777216) {
				attr(select, "style", /*inputStyle*/ ctx[24]);
			}

			if (!current || dirty[0] & /*name*/ 8) {
				attr(select, "name", /*name*/ ctx[3]);
			}

			if (!current || dirty[0] & /*placeholder*/ 16) {
				attr(select, "placeholder", /*placeholder*/ ctx[4]);
			}

			if (!current || dirty[0] & /*inputId*/ 32) {
				attr(select, "id", /*inputId*/ ctx[5]);
			}

			if (!current || dirty[0] & /*size*/ 64) {
				attr(select, "size", /*size*/ ctx[6]);
			}

			if (!current || dirty[0] & /*accept*/ 128) {
				attr(select, "accept", /*accept*/ ctx[7]);
			}

			if (!current || dirty[0] & /*autocomplete*/ 256) {
				attr(select, "autocomplete", /*autocomplete*/ ctx[8]);
			}

			if (!current || dirty[0] & /*autocorrect*/ 512) {
				attr(select, "autocorrect", /*autocorrect*/ ctx[9]);
			}

			if (!current || dirty[0] & /*autocapitalize*/ 1024) {
				attr(select, "autocapitalize", /*autocapitalize*/ ctx[10]);
			}

			if (!current || dirty[0] & /*spellcheck*/ 2048) {
				attr(select, "spellcheck", /*spellcheck*/ ctx[11]);
			}

			if (!current || dirty[0] & /*autofocus*/ 4096) {
				select.autofocus = /*autofocus*/ ctx[12];
			}

			if (!current || dirty[0] & /*autosave*/ 8192) {
				attr(select, "autosave", /*autosave*/ ctx[13]);
			}

			if (!current || dirty[0] & /*checked*/ 16384) {
				attr(select, "checked", /*checked*/ ctx[14]);
			}

			if (!current || dirty[0] & /*disabled*/ 32768) {
				select.disabled = /*disabled*/ ctx[15];
			}

			if (!current || dirty[0] & /*max*/ 65536) {
				attr(select, "max", /*max*/ ctx[16]);
			}

			if (!current || dirty[0] & /*maxlength*/ 524288) {
				attr(select, "maxlength", /*maxlength*/ ctx[19]);
			}

			if (!current || dirty[0] & /*min*/ 131072) {
				attr(select, "min", /*min*/ ctx[17]);
			}

			if (!current || dirty[0] & /*minlength*/ 1048576) {
				attr(select, "minlength", /*minlength*/ ctx[20]);
			}

			if (!current || dirty[0] & /*step*/ 262144) {
				attr(select, "step", /*step*/ ctx[18]);
			}

			if (!current || dirty[0] & /*multiple*/ 2097152) {
				select.multiple = /*multiple*/ ctx[21];
			}

			if (!current || dirty[0] & /*readonly*/ 4194304) {
				attr(select, "readonly", /*readonly*/ ctx[22]);
			}

			if (!current || dirty[0] & /*required*/ 8388608) {
				select.required = /*required*/ ctx[23];
			}

			if (!current || dirty[0] & /*pattern*/ 33554432) {
				attr(select, "pattern", /*pattern*/ ctx[25]);
			}

			if (!current || dirty[0] & /*validate*/ 67108864 && select_validate_value !== (select_validate_value = typeof /*validate*/ ctx[26] === 'string' && /*validate*/ ctx[26].length
			? /*validate*/ ctx[26]
			: undefined)) {
				attr(select, "validate", select_validate_value);
			}

			if (!current || dirty[0] & /*validate, validateOnBlur*/ 201326592 && select_data_validate_value !== (select_data_validate_value = /*validate*/ ctx[26] === true || /*validate*/ ctx[26] === '' || /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined)) {
				attr(select, "data-validate", select_data_validate_value);
			}

			if (!current || dirty[0] & /*validateOnBlur*/ 134217728 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[27] === true || /*validateOnBlur*/ ctx[27] === ''
			? true
			: undefined)) {
				attr(select, "data-validate-on-blur", select_data_validate_on_blur_value);
			}

			if (!current || dirty[0] & /*tabindex*/ 268435456) {
				attr(select, "tabindex", /*tabindex*/ ctx[28]);
			}

			if (!current || dirty[1] & /*errorMessageForce, errorMessage*/ 3 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/ ctx[32]
			? undefined
			: /*errorMessage*/ ctx[31])) {
				attr(select, "data-error-message", select_data_error_message_value);
			}

			if (!current || dirty[1] & /*inputClassName*/ 512) {
				attr(select, "class", /*inputClassName*/ ctx[40]);
			}

			if (!current || dirty[1] & /*inputValue*/ 2048) {
				select_option(select, /*inputValue*/ ctx[42]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(select);
			if (default_slot) default_slot.d(detaching);
			/*select_binding*/ ctx[61](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (491:4) {#if (errorMessage || hasErrorSlots) && errorMessageForce}
function create_if_block_3$a(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	const error_message_slot_template = /*#slots*/ ctx[60]["error-message"];
	const error_message_slot = create_slot(error_message_slot_template, ctx, /*$$scope*/ ctx[59], get_error_message_slot_context$1);

	return {
		c() {
			div = element("div");
			t0 = text(/*errorMessage*/ ctx[31]);
			t1 = space();
			if (error_message_slot) error_message_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, /*errorMessage*/ ctx[31]);
			t1 = claim_space(div_nodes);
			if (error_message_slot) error_message_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "input-error-message");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (error_message_slot) {
				error_message_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty[1] & /*errorMessage*/ 1) set_data(t0, /*errorMessage*/ ctx[31]);

			if (error_message_slot) {
				if (error_message_slot.p && (!current || dirty[1] & /*$$scope*/ 268435456)) {
					update_slot_base(
						error_message_slot,
						error_message_slot_template,
						ctx,
						/*$$scope*/ ctx[59],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[59])
						: get_slot_changes(error_message_slot_template, /*$$scope*/ ctx[59], dirty, get_error_message_slot_changes$1),
						get_error_message_slot_context$1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(error_message_slot, local);
			current = true;
		},
		o(local) {
			transition_out(error_message_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (error_message_slot) error_message_slot.d(detaching);
		}
	};
}

// (497:4) {#if clearButton}
function create_if_block_2$c(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "input-clear-button");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (498:4) {#if info || hasInfoSlots}
function create_if_block_1$h(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	const info_slot_template = /*#slots*/ ctx[60].info;
	const info_slot = create_slot(info_slot_template, ctx, /*$$scope*/ ctx[59], get_info_slot_context$1);

	return {
		c() {
			div = element("div");
			t0 = text(/*info*/ ctx[33]);
			t1 = space();
			if (info_slot) info_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, /*info*/ ctx[33]);
			t1 = claim_space(div_nodes);
			if (info_slot) info_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "input-info");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (info_slot) {
				info_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty[1] & /*info*/ 4) set_data(t0, /*info*/ ctx[33]);

			if (info_slot) {
				if (info_slot.p && (!current || dirty[1] & /*$$scope*/ 268435456)) {
					update_slot_base(
						info_slot,
						info_slot_template,
						ctx,
						/*$$scope*/ ctx[59],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[59])
						: get_slot_changes(info_slot_template, /*$$scope*/ ctx[59], dirty, get_info_slot_changes$1),
						get_info_slot_context$1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(info_slot, local);
			current = true;
		},
		o(local) {
			transition_out(info_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (info_slot) info_slot.d(detaching);
		}
	};
}

function create_fragment$R(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block$q,
		create_if_block_9$3,
		create_if_block_10$3,
		create_if_block_11$2,
		create_if_block_12$2,
		create_if_block_13$2,
		create_else_block_1$3
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*wrap*/ ctx[34]) return 0;
		if (/*type*/ ctx[2] === 'select') return 1;
		if (/*type*/ ctx[2] === 'textarea') return 2;
		if (/*type*/ ctx[2] === 'toggle') return 3;
		if (/*type*/ ctx[2] === 'range') return 4;
		if (/*type*/ ctx[2] === 'texteditor') return 5;
		return 6;
	}

	current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

let index$T = 0;

function instance$M($$self, $$props, $$invalidate) {
	let inputType;
	let needsValue;
	let inputValue;
	let classes;
	let wrapClasses;
	let inputClassName;
	let hasInfoSlots;
	let hasErrorSlots;

	const omit_props_names = [
		"lec","class","type","name","value","placeholder","inputId","size","accept","autocomplete","autocorrect","autocapitalize","spellcheck","autofocus","autosave","checked","disabled","max","min","step","maxlength","minlength","multiple","readonly","required","inputStyle","pattern","validate","validateOnBlur","onValidate","tabindex","resizable","clearButton","noFormStoreData","noStoreData","ignoreStoreData","errorMessage","errorMessageForce","info","outline","wrap","dropdown","calendarParams","colorPickerParams","textEditorParams"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { type = undefined } = $$props;
	let { name = undefined } = $$props;
	let { value = undefined } = $$props;
	let { placeholder = undefined } = $$props;
	let { inputId = undefined } = $$props;
	let { size = undefined } = $$props;
	let { accept = undefined } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { autofocus = undefined } = $$props;
	let { autosave = undefined } = $$props;
	let { checked = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { max = undefined } = $$props;
	let { min = undefined } = $$props;
	let { step = undefined } = $$props;
	let { maxlength = undefined } = $$props;
	let { minlength = undefined } = $$props;
	let { multiple = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let { required = undefined } = $$props;
	let { inputStyle = undefined } = $$props;
	let { pattern = undefined } = $$props;
	let { validate = undefined } = $$props;
	let { validateOnBlur = undefined } = $$props;
	let { onValidate = undefined } = $$props;
	let { tabindex = undefined } = $$props;
	let { resizable = undefined } = $$props;
	let { clearButton = undefined } = $$props;
	let { noFormStoreData = undefined } = $$props;
	let { noStoreData = undefined } = $$props;
	let { ignoreStoreData = undefined } = $$props;
	let { errorMessage = undefined } = $$props;
	let { errorMessageForce = undefined } = $$props;
	let { info = undefined } = $$props;
	let { outline = undefined } = $$props;
	let { wrap = true } = $$props;
	let { dropdown = 'auto' } = $$props;
	let { calendarParams = undefined } = $$props;
	let { colorPickerParams = undefined } = $$props;
	let { textEditorParams = undefined } = $$props;

	// State
	let inputEl;

	let inputFocused = false;
	let inputInvalid = false;
	let updateInputOnDidUpdate = false;
	let f7Calendar;
	let f7ColorPicker;

	function domValue() {
		if (!inputEl) return undefined;
		return inputEl.value;
	}

	function inputHasValue() {
		if (type === 'datepicker' && Array.isArray(value) && value.length === 0) {
			return false;
		}

		const domV = domValue();

		return typeof value === 'undefined'
		? domV || domV === 0
		: value || value === 0;
	}

	function validateInput() {
		if (!app.f7 || !inputEl) return;
		const validity = inputEl.validity;
		if (!validity) return;

		if (!validity.valid) {
			if (onValidate) onValidate(false);

			if (inputInvalid !== true) {
				$$invalidate(58, inputInvalid = true);
			}
		} else {
			if (onValidate) onValidate(true);

			if (inputInvalid !== false) {
				$$invalidate(58, inputInvalid = false);
			}
		}
	}

	let initialWatched = false;

	function watchValue() {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (type === 'range' || type === 'toggle') return;
		if (!app.f7) return;
		updateInputOnDidUpdate = true;

		if (f7Calendar) {
			f7Calendar.setValue(value);
		}

		if (f7ColorPicker) {
			f7ColorPicker.setValue(value);
		}
	}

	function onTextareaResize(event) {
		emit('textareaResize', [event]);
	}

	function onInputNotEmpty(event) {
		emit('inputNotEmpty', [event]);
	}

	function onInputEmpty(event) {
		emit('inputEmpty', [event]);
	}

	function onInputClear(event) {
		emit('inputClear', [event]);
	}

	function onInput(...args) {
		emit('input', [...args]);

		if (!(validateOnBlur || validateOnBlur === '') && (validate || validate === '') && inputEl) {
			validateInput(inputEl);
		}

		if (inputEl && type !== 'texteditor' && type !== 'colorpicker' && type !== 'datepicker') {
			$$invalidate(0, value = inputEl.value);
		}
	}

	function onFocus(...args) {
		emit('focus', [...args]);
		$$invalidate(57, inputFocused = true);
	}

	function onBlur(...args) {
		emit('blur', [...args]);

		if ((validate || validate === '' || validateOnBlur || validateOnBlur === '') && inputEl) {
			validateInput();
		}

		$$invalidate(57, inputFocused = false);
	}

	function onChange(...args) {
		emit('change', [...args]);

		if (type === 'texteditor') {
			emit('textEditorChange', [args[1]]);
			$$invalidate(0, value = args[1]);
		}
	}

	onMount(() => {
		f7ready(() => {
			if (type === 'range' || type === 'toggle') return;
			if (!inputEl) return;
			inputEl.addEventListener('input:notempty', onInputNotEmpty, false);

			if (type === 'textarea' && resizable) {
				inputEl.addEventListener('textarea:resize', onTextareaResize, false);
			}

			if (clearButton) {
				inputEl.addEventListener('input:empty', onInputEmpty, false);
				inputEl.addEventListener('input:clear', onInputClear, false);
			}

			if (type === 'datepicker') {
				f7Calendar = app.f7.calendar.create({
					inputEl,
					value,
					on: {
						change(calendar, calendarValue) {
							emit('calendarChange', [calendarValue]);
							$$invalidate(0, value = calendarValue);
						}
					},
					...calendarParams || {}
				});
			}

			if (type === 'colorpicker') {
				f7ColorPicker = app.f7.colorPicker.create({
					inputEl,
					value,
					on: {
						change(colorPicker, colorPickerValue) {
							emit('colorpickerChange', [colorPickerValue]);
							$$invalidate(0, value = colorPickerValue);
						}
					},
					...colorPickerParams || {}
				});
			}

			app.f7.input.checkEmptyState(inputEl);

			if (!(validateOnBlur || validateOnBlur === '') && (validate || validate === '') && typeof value !== 'undefined' && value !== null && value !== '') {
				setTimeout(
					() => {
						validateInput();
					},
					0
				);
			}

			if (resizable) {
				app.f7.input.resizeTextarea(inputEl);
			}
		});
	});

	afterUpdate(() => {
		if (!app.f7) return;

		if (updateInputOnDidUpdate) {
			if (!inputEl) return;
			updateInputOnDidUpdate = false;
			app.f7.input.checkEmptyState(inputEl);

			if (validate && !validateOnBlur) {
				validateInput();
			}

			if (resizable) {
				app.f7.input.resizeTextarea(inputEl);
			}
		}
	});

	onDestroy(() => {
		if (type === 'range' || type === 'toggle') return;
		if (!inputEl) return;
		inputEl.removeEventListener('input:notempty', onInputNotEmpty, false);

		if (type === 'textarea' && resizable) {
			inputEl.removeEventListener('textarea:resize', onTextareaResize, false);
		}

		if (clearButton) {
			inputEl.removeEventListener('input:empty', onInputEmpty, false);
			inputEl.removeEventListener('input:clear', onInputClear, false);
		}

		if (f7Calendar && f7Calendar.destroy) {
			f7Calendar.destroy();
		}

		if (f7ColorPicker && f7ColorPicker.destroy) {
			f7ColorPicker.destroy();
		}

		f7Calendar = null;
		f7ColorPicker = null;
	});

	function select_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(37, inputEl);
		});
	}

	function textarea_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(37, inputEl);
		});
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(37, inputEl);
		});
	}

	function select_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(37, inputEl);
		});
	}

	function textarea_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(37, inputEl);
		});
	}

	function input_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(37, inputEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(84, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(47, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(1, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(48, className = $$new_props.class);
		if ('type' in $$new_props) $$invalidate(2, type = $$new_props.type);
		if ('name' in $$new_props) $$invalidate(3, name = $$new_props.name);
		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ('placeholder' in $$new_props) $$invalidate(4, placeholder = $$new_props.placeholder);
		if ('inputId' in $$new_props) $$invalidate(5, inputId = $$new_props.inputId);
		if ('size' in $$new_props) $$invalidate(6, size = $$new_props.size);
		if ('accept' in $$new_props) $$invalidate(7, accept = $$new_props.accept);
		if ('autocomplete' in $$new_props) $$invalidate(8, autocomplete = $$new_props.autocomplete);
		if ('autocorrect' in $$new_props) $$invalidate(9, autocorrect = $$new_props.autocorrect);
		if ('autocapitalize' in $$new_props) $$invalidate(10, autocapitalize = $$new_props.autocapitalize);
		if ('spellcheck' in $$new_props) $$invalidate(11, spellcheck = $$new_props.spellcheck);
		if ('autofocus' in $$new_props) $$invalidate(12, autofocus = $$new_props.autofocus);
		if ('autosave' in $$new_props) $$invalidate(13, autosave = $$new_props.autosave);
		if ('checked' in $$new_props) $$invalidate(14, checked = $$new_props.checked);
		if ('disabled' in $$new_props) $$invalidate(15, disabled = $$new_props.disabled);
		if ('max' in $$new_props) $$invalidate(16, max = $$new_props.max);
		if ('min' in $$new_props) $$invalidate(17, min = $$new_props.min);
		if ('step' in $$new_props) $$invalidate(18, step = $$new_props.step);
		if ('maxlength' in $$new_props) $$invalidate(19, maxlength = $$new_props.maxlength);
		if ('minlength' in $$new_props) $$invalidate(20, minlength = $$new_props.minlength);
		if ('multiple' in $$new_props) $$invalidate(21, multiple = $$new_props.multiple);
		if ('readonly' in $$new_props) $$invalidate(22, readonly = $$new_props.readonly);
		if ('required' in $$new_props) $$invalidate(23, required = $$new_props.required);
		if ('inputStyle' in $$new_props) $$invalidate(24, inputStyle = $$new_props.inputStyle);
		if ('pattern' in $$new_props) $$invalidate(25, pattern = $$new_props.pattern);
		if ('validate' in $$new_props) $$invalidate(26, validate = $$new_props.validate);
		if ('validateOnBlur' in $$new_props) $$invalidate(27, validateOnBlur = $$new_props.validateOnBlur);
		if ('onValidate' in $$new_props) $$invalidate(49, onValidate = $$new_props.onValidate);
		if ('tabindex' in $$new_props) $$invalidate(28, tabindex = $$new_props.tabindex);
		if ('resizable' in $$new_props) $$invalidate(29, resizable = $$new_props.resizable);
		if ('clearButton' in $$new_props) $$invalidate(30, clearButton = $$new_props.clearButton);
		if ('noFormStoreData' in $$new_props) $$invalidate(50, noFormStoreData = $$new_props.noFormStoreData);
		if ('noStoreData' in $$new_props) $$invalidate(51, noStoreData = $$new_props.noStoreData);
		if ('ignoreStoreData' in $$new_props) $$invalidate(52, ignoreStoreData = $$new_props.ignoreStoreData);
		if ('errorMessage' in $$new_props) $$invalidate(31, errorMessage = $$new_props.errorMessage);
		if ('errorMessageForce' in $$new_props) $$invalidate(32, errorMessageForce = $$new_props.errorMessageForce);
		if ('info' in $$new_props) $$invalidate(33, info = $$new_props.info);
		if ('outline' in $$new_props) $$invalidate(53, outline = $$new_props.outline);
		if ('wrap' in $$new_props) $$invalidate(34, wrap = $$new_props.wrap);
		if ('dropdown' in $$new_props) $$invalidate(54, dropdown = $$new_props.dropdown);
		if ('calendarParams' in $$new_props) $$invalidate(55, calendarParams = $$new_props.calendarParams);
		if ('colorPickerParams' in $$new_props) $$invalidate(56, colorPickerParams = $$new_props.colorPickerParams);
		if ('textEditorParams' in $$new_props) $$invalidate(35, textEditorParams = $$new_props.textEditorParams);
		if ('$$scope' in $$new_props) $$invalidate(59, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value*/ 1) {
			$: watchValue(value);
		}

		if ($$self.$$.dirty[0] & /*type*/ 4) {
			$: $$invalidate(36, inputType = type === 'datepicker' || type === 'colorpicker'
			? 'text'
			: type);
		}

		if ($$self.$$.dirty[0] & /*type*/ 4) {
			$: needsValue = type !== 'file' && type !== 'datepicker' && type !== 'colorpicker';
		}

		if ($$self.$$.dirty[0] & /*value*/ 1) {
			$: $$invalidate(42, inputValue = (() => {
				let v;

				if (typeof value !== 'undefined') {
					v = value;
				} else {
					v = domValue();
				}

				if (typeof v === 'undefined' || v === null) return '';
				return v;
			})());
		}

		if ($$self.$$.dirty[0] & /*resizable*/ 536870912 | $$self.$$.dirty[1] & /*wrap, className, inputType, noFormStoreData, noStoreData, ignoreStoreData, errorMessage, errorMessageForce, inputInvalid, inputFocused*/ 205127723) {
			$: classes = classNames(!wrap && className, {
				resizable: inputType === 'textarea' && resizable,
				'no-store-data': noFormStoreData || noStoreData || ignoreStoreData,
				'input-invalid': errorMessage && errorMessageForce || inputInvalid,
				'input-with-value': inputHasValue(),
				'input-focused': inputFocused
			});
		}

		$: $$invalidate(41, wrapClasses = classNames(
			className,
			'input',
			{
				'input-outline': outline,
				'input-dropdown': dropdown === 'auto' ? type === 'select' : dropdown,
				'input-invalid': errorMessage && errorMessageForce || inputInvalid
			},
			colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*resizable*/ 536870912 | $$self.$$.dirty[1] & /*wrap, className, inputType, noFormStoreData, noStoreData, ignoreStoreData, errorMessage, errorMessageForce, inputInvalid, inputFocused*/ 205127723) {
			$: $$invalidate(40, inputClassName = classNames(!wrap && className, {
				resizable: inputType === 'textarea' && resizable,
				'no-store-data': noFormStoreData || noStoreData || ignoreStoreData,
				'input-invalid': errorMessage && errorMessageForce || inputInvalid,
				'input-with-value': inputHasValue(),
				'input-focused': inputFocused
			}));
		}
	};

	$: $$invalidate(39, hasInfoSlots = $$slots.info);

	// eslint-disable-next-line
	$: $$invalidate(38, hasErrorSlots = $$slots['error-message']);

	$$props = exclude_internal_props($$props);

	return [
		value,
		lec,
		type,
		name,
		placeholder,
		inputId,
		size,
		accept,
		autocomplete,
		autocorrect,
		autocapitalize,
		spellcheck,
		autofocus,
		autosave,
		checked,
		disabled,
		max,
		min,
		step,
		maxlength,
		minlength,
		multiple,
		readonly,
		required,
		inputStyle,
		pattern,
		validate,
		validateOnBlur,
		tabindex,
		resizable,
		clearButton,
		errorMessage,
		errorMessageForce,
		info,
		wrap,
		textEditorParams,
		inputType,
		inputEl,
		hasErrorSlots,
		hasInfoSlots,
		inputClassName,
		wrapClasses,
		inputValue,
		onInput,
		onFocus,
		onBlur,
		onChange,
		$$restProps,
		className,
		onValidate,
		noFormStoreData,
		noStoreData,
		ignoreStoreData,
		outline,
		dropdown,
		calendarParams,
		colorPickerParams,
		inputFocused,
		inputInvalid,
		$$scope,
		slots,
		select_binding,
		textarea_binding,
		input_binding,
		select_binding_1,
		textarea_binding_1,
		input_binding_1
	];
}

class Input extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$M,
			create_fragment$R,
			safe_not_equal,
			{
				lec: 1,
				class: 48,
				type: 2,
				name: 3,
				value: 0,
				placeholder: 4,
				inputId: 5,
				size: 6,
				accept: 7,
				autocomplete: 8,
				autocorrect: 9,
				autocapitalize: 10,
				spellcheck: 11,
				autofocus: 12,
				autosave: 13,
				checked: 14,
				disabled: 15,
				max: 16,
				min: 17,
				step: 18,
				maxlength: 19,
				minlength: 20,
				multiple: 21,
				readonly: 22,
				required: 23,
				inputStyle: 24,
				pattern: 25,
				validate: 26,
				validateOnBlur: 27,
				onValidate: 49,
				tabindex: 28,
				resizable: 29,
				clearButton: 30,
				noFormStoreData: 50,
				noStoreData: 51,
				ignoreStoreData: 52,
				errorMessage: 31,
				errorMessageForce: 32,
				info: 33,
				outline: 53,
				wrap: 34,
				dropdown: 54,
				calendarParams: 55,
				colorPickerParams: 56,
				textEditorParams: 35
			},
			null,
			[-1, -1, -1]
		);
	}
}

// eslint-disable-next-line
const useSmartSelect = (props, setInstance, getEl) => {
  let f7SmartSelect;
  onMount(() => {
    f7ready(() => {
      if (props.smartSelect) {
        const ssParams = extend({
          el: getEl()
        }, props.smartSelectParams || {});
        f7SmartSelect = app.f7.smartSelect.create(ssParams);
        setInstance(f7SmartSelect);
      }
    });
  });
  onDestroy(() => {
    if (f7SmartSelect && f7SmartSelect.destroy) {
      f7SmartSelect.destroy();
    }
    f7SmartSelect = null;
    setInstance(f7SmartSelect);
  });
};

// eslint-disable-next-line
const getReactiveContext = (name, setValue) => {
  const ctx = getContext(name);
  if (!ctx) return undefined;
  const {
    value,
    subscribe,
    unsubscribe
  } = ctx;
  subscribe(setValue);
  onDestroy(() => {
    unsubscribe(setValue);
  });
  return value;
};

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/link.liquivelte generated by Svelte v3.50.0 */

function create_if_block_2$b(ctx) {
	let useicon;
	let current;

	useicon = new Use_icon({
			props: {
				icon: /*icon*/ ctx[9],
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(useicon.$$.fragment);
		},
		l(nodes) {
			claim_component(useicon.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(useicon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const useicon_changes = {};
			if (dirty[0] & /*icon*/ 512) useicon_changes.icon = /*icon*/ ctx[9];
			if (dirty[0] & /*lec*/ 1) useicon_changes.lec = /*lec*/ ctx[0];
			useicon.$set(useicon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(useicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(useicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(useicon, detaching);
		}
	};
}

// (123:2) {#if typeof text !== 'undefined' || typeof badge !== 'undefined'}
function create_if_block$p(ctx) {
	let span;
	let t0_value = plainText(/*text*/ ctx[1]) + "";
	let t0;
	let t1;
	let current;
	let if_block = typeof /*badge*/ ctx[2] !== 'undefined' && create_if_block_1$g(ctx);

	return {
		c() {
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, t0_value);
			t1 = claim_space(span_nodes);
			if (if_block) if_block.l(span_nodes);
			span_nodes.forEach(detach);
			this.h();
		},
		h() {
			toggle_class(span, "tabbar-label", /*isTabbarLabel*/ ctx[7]);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t0);
			append_hydration(span, t1);
			if (if_block) if_block.m(span, null);
			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 2) && t0_value !== (t0_value = plainText(/*text*/ ctx[1]) + "")) set_data(t0, t0_value);

			if (typeof /*badge*/ ctx[2] !== 'undefined') {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$g(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(span, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*isTabbarLabel*/ 128) {
				toggle_class(span, "tabbar-label", /*isTabbarLabel*/ ctx[7]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block) if_block.d();
		}
	};
}

// (126:6) {#if typeof badge !== 'undefined'}
function create_if_block_1$g(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[3],
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(badge_1.$$.fragment);
		},
		l(nodes) {
			claim_component(badge_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 8) badge_1_changes.color = /*badgeColor*/ ctx[3];
			if (dirty[0] & /*lec*/ 1) badge_1_changes.lec = /*lec*/ ctx[0];

			if (dirty[0] & /*$$scope, badge*/ 1073741828) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(badge_1, detaching);
		}
	};
}

// (126:40) <Badge  color={badgeColor}     lec={lec} >
function create_default_slot$6(ctx) {
	let t_value = plainText(/*badge*/ ctx[2]) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*badge*/ 4 && t_value !== (t_value = plainText(/*badge*/ ctx[2]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$Q(ctx) {
	let a;
	let t0;
	let t1;
	let useTooltip_action;
	let useRouteProps_action;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*icon*/ ctx[9] && create_if_block_2$b(ctx);
	const default_slot_template = /*#slots*/ ctx[28].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[30], null);
	let if_block1 = (typeof /*text*/ ctx[1] !== 'undefined' || typeof /*badge*/ ctx[2] !== 'undefined') && create_if_block$p(ctx);
	let a_levels = [{ class: /*classes*/ ctx[10] }, /*attrs*/ ctx[11]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = element("a");
			if (if_block0) if_block0.c();
			t0 = space();
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l(nodes) {
			a = claim_element(nodes, "A", { class: true });
			var a_nodes = children(a);
			if (if_block0) if_block0.l(a_nodes);
			t0 = claim_space(a_nodes);
			if (default_slot) default_slot.l(a_nodes);
			t1 = claim_space(a_nodes);
			if (if_block1) if_block1.l(a_nodes);
			a_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(a, a_data);
		},
		m(target, anchor) {
			insert_hydration(target, a, anchor);
			if (if_block0) if_block0.m(a, null);
			append_hydration(a, t0);

			if (default_slot) {
				default_slot.m(a, null);
			}

			append_hydration(a, t1);
			if (if_block1) if_block1.m(a, null);
			/*a_binding*/ ctx[29](a);
			current = true;

			if (!mounted) {
				dispose = [
					listen(a, "click", /*onClick*/ ctx[12]),
					action_destroyer(useTooltip_action = useTooltip.call(null, a, {
						tooltip: /*tooltip*/ ctx[4],
						tooltipTrigger: /*tooltipTrigger*/ ctx[5]
					})),
					action_destroyer(useRouteProps_action = useRouteProps.call(null, a, /*routeProps*/ ctx[6]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[9]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*icon*/ 512) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$b(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(a, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 1073741824)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[30],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[30])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[30], dirty, null),
						null
					);
				}
			}

			if (typeof /*text*/ ctx[1] !== 'undefined' || typeof /*badge*/ ctx[2] !== 'undefined') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*text, badge*/ 6) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$p(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(a, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty[0] & /*classes*/ 1024) && { class: /*classes*/ ctx[10] },
				dirty[0] & /*attrs*/ 2048 && /*attrs*/ ctx[11]
			]));

			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 48) useTooltip_action.update.call(null, {
				tooltip: /*tooltip*/ ctx[4],
				tooltipTrigger: /*tooltipTrigger*/ ctx[5]
			});

			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 64) useRouteProps_action.update.call(null, /*routeProps*/ ctx[6]);
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
			/*a_binding*/ ctx[29](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

let index$S = 0;

function instance$L($$self, $$props, $$invalidate) {
	let isTabbarLabel;
	let hrefComputed;
	let attrs;
	let hasDefaultSlots;
	let iconOnlyComputed;
	let classes;
	let icon;

	const omit_props_names = [
		"lec","class","noLinkClass","text","tabLink","tabLinkActive","tabbarLabel","iconOnly","badge","badgeColor","href","target","tooltip","tooltipTrigger","routeProps","smartSelect","smartSelectParams","smartSelectInstance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { noLinkClass = false } = $$props;
	let { text = undefined } = $$props;
	let { tabLink = undefined } = $$props;
	let { tabLinkActive = false } = $$props;
	let { tabbarLabel = false } = $$props;
	let { iconOnly = false } = $$props;
	let { badge = undefined } = $$props;
	let { badgeColor = undefined } = $$props;
	let { href = '#' } = $$props;
	let { target = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let { routeProps = undefined } = $$props;
	let { smartSelect = false } = $$props;
	let { smartSelectParams = undefined } = $$props;
	let el;
	let f7SmartSelect;

	function smartSelectInstance() {
		return f7SmartSelect;
	}

	let TabbarContext = getReactiveContext('TabbarContext', newValue => {
		$$invalidate(24, TabbarContext = newValue);
	}) || {};

	function onClick() {
		emit('click');
	}

	useSmartSelect(
		{ smartSelect, smartSelectParams },
		instance => {
			f7SmartSelect = instance;
		},
		() => el
	);

	function a_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(8, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(34, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(36, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(0, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(13, className = $$new_props.class);
		if ('noLinkClass' in $$new_props) $$invalidate(14, noLinkClass = $$new_props.noLinkClass);
		if ('text' in $$new_props) $$invalidate(1, text = $$new_props.text);
		if ('tabLink' in $$new_props) $$invalidate(15, tabLink = $$new_props.tabLink);
		if ('tabLinkActive' in $$new_props) $$invalidate(16, tabLinkActive = $$new_props.tabLinkActive);
		if ('tabbarLabel' in $$new_props) $$invalidate(17, tabbarLabel = $$new_props.tabbarLabel);
		if ('iconOnly' in $$new_props) $$invalidate(18, iconOnly = $$new_props.iconOnly);
		if ('badge' in $$new_props) $$invalidate(2, badge = $$new_props.badge);
		if ('badgeColor' in $$new_props) $$invalidate(3, badgeColor = $$new_props.badgeColor);
		if ('href' in $$new_props) $$invalidate(19, href = $$new_props.href);
		if ('target' in $$new_props) $$invalidate(20, target = $$new_props.target);
		if ('tooltip' in $$new_props) $$invalidate(4, tooltip = $$new_props.tooltip);
		if ('tooltipTrigger' in $$new_props) $$invalidate(5, tooltipTrigger = $$new_props.tooltipTrigger);
		if ('routeProps' in $$new_props) $$invalidate(6, routeProps = $$new_props.routeProps);
		if ('smartSelect' in $$new_props) $$invalidate(21, smartSelect = $$new_props.smartSelect);
		if ('smartSelectParams' in $$new_props) $$invalidate(22, smartSelectParams = $$new_props.smartSelectParams);
		if ('$$scope' in $$new_props) $$invalidate(30, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*tabbarLabel, TabbarContext*/ 16908288) {
			$: $$invalidate(7, isTabbarLabel = tabbarLabel || TabbarContext.tabbarHasLabels);
		}

		if ($$self.$$.dirty[0] & /*href*/ 524288) {
			$: $$invalidate(27, hrefComputed = href === true ? '#' : href || undefined);
		}

		$: $$invalidate(11, attrs = extend(
			{
				href: hrefComputed,
				target,
				'data-tab': isStringProp(tabLink) && tabLink || undefined,
				...restProps($$restProps)
			},
			routerAttrs($$props),
			actionsAttrs($$props)
		));

		if ($$self.$$.dirty[0] & /*iconOnly, text, hasDefaultSlots*/ 67371010) {
			$: $$invalidate(25, iconOnlyComputed = iconOnly || !text && !hasDefaultSlots);
		}

		$: $$invalidate(10, classes = classNames(
			className,
			{
				link: !(noLinkClass || isTabbarLabel),
				'icon-only': iconOnlyComputed,
				'tab-link': tabLink || tabLink === '',
				'tab-link-active': tabLinkActive,
				'smart-select': smartSelect
			},
			colorClasses($$props),
			routerClasses($$props),
			actionsClasses($$props)
		));

		$: $$invalidate(9, icon = useIcon($$props));
	};

	$: $$invalidate(26, hasDefaultSlots = $$slots.default);
	$$props = exclude_internal_props($$props);

	return [
		lec,
		text,
		badge,
		badgeColor,
		tooltip,
		tooltipTrigger,
		routeProps,
		isTabbarLabel,
		el,
		icon,
		classes,
		attrs,
		onClick,
		className,
		noLinkClass,
		tabLink,
		tabLinkActive,
		tabbarLabel,
		iconOnly,
		href,
		target,
		smartSelect,
		smartSelectParams,
		smartSelectInstance,
		TabbarContext,
		iconOnlyComputed,
		hasDefaultSlots,
		hrefComputed,
		slots,
		a_binding,
		$$scope
	];
}

class Link extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$L,
			create_fragment$Q,
			safe_not_equal,
			{
				lec: 0,
				class: 13,
				noLinkClass: 14,
				text: 1,
				tabLink: 15,
				tabLinkActive: 16,
				tabbarLabel: 17,
				iconOnly: 18,
				badge: 2,
				badgeColor: 3,
				href: 19,
				target: 20,
				tooltip: 4,
				tooltipTrigger: 5,
				routeProps: 6,
				smartSelect: 21,
				smartSelectParams: 22,
				smartSelectInstance: 23
			},
			null,
			[-1, -1]
		);
	}

	get smartSelectInstance() {
		return this.$$.ctx[23];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/list-button.liquivelte generated by Svelte v3.50.0 */

function create_fragment$P(ctx) {
	let li;
	let a;
	let t0_value = plainText(/*title*/ ctx[1]) + "";
	let t0;
	let t1;
	let t2_value = plainText(/*text*/ ctx[2]) + "";
	let t2;
	let t3;
	let useRouteProps_action;
	let useTooltip_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[19].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);
	let a_levels = [{ class: /*classes*/ ctx[7] }, /*attrs*/ ctx[8]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	let li_levels = [{ class: /*className*/ ctx[0] }, restProps(/*$$restProps*/ ctx[10])];
	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	return {
		c() {
			li = element("li");
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			t2 = text(t2_value);
			t3 = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			a = claim_element(li_nodes, "A", { class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			t1 = claim_space(a_nodes);
			t2 = claim_text(a_nodes, t2_value);
			t3 = claim_space(a_nodes);
			if (default_slot) default_slot.l(a_nodes);
			a_nodes.forEach(detach);
			li_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(a, a_data);
			set_attributes(li, li_data);
		},
		m(target, anchor) {
			insert_hydration(target, li, anchor);
			append_hydration(li, a);
			append_hydration(a, t0);
			append_hydration(a, t1);
			append_hydration(a, t2);
			append_hydration(a, t3);

			if (default_slot) {
				default_slot.m(a, null);
			}

			/*li_binding*/ ctx[20](li);
			current = true;

			if (!mounted) {
				dispose = [
					listen(a, "click", /*onClick*/ ctx[9]),
					action_destroyer(useRouteProps_action = useRouteProps.call(null, li, /*routeProps*/ ctx[5])),
					action_destroyer(useTooltip_action = useTooltip.call(null, li, {
						tooltip: /*tooltip*/ ctx[3],
						tooltipTrigger: /*tooltipTrigger*/ ctx[4]
					}))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*title*/ 2) && t0_value !== (t0_value = plainText(/*title*/ ctx[1]) + "")) set_data(t0, t0_value);
			if ((!current || dirty & /*text*/ 4) && t2_value !== (t2_value = plainText(/*text*/ ctx[2]) + "")) set_data(t2, t2_value);

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[18],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, null),
						null
					);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
				dirty & /*attrs*/ 256 && /*attrs*/ ctx[8]
			]));

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
				dirty & /*$$restProps*/ 1024 && restProps(/*$$restProps*/ ctx[10])
			]));

			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty & /*routeProps*/ 32) useRouteProps_action.update.call(null, /*routeProps*/ ctx[5]);

			if (useTooltip_action && is_function(useTooltip_action.update) && dirty & /*tooltip, tooltipTrigger*/ 24) useTooltip_action.update.call(null, {
				tooltip: /*tooltip*/ ctx[3],
				tooltipTrigger: /*tooltipTrigger*/ ctx[4]
			});
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (default_slot) default_slot.d(detaching);
			/*li_binding*/ ctx[20](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

let index$R = 0;

function instance$K($$self, $$props, $$invalidate) {
	let hrefComputed;
	let attrs;
	let classes;

	const omit_props_names = [
		"lec","class","title","text","tabLink","tabLinkActive","link","href","target","tooltip","tooltipTrigger","routeProps"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { title = undefined } = $$props;
	let { text = undefined } = $$props;
	let { tabLink = undefined } = $$props;
	let { tabLinkActive = false } = $$props;
	let { link = undefined } = $$props;
	let { href = undefined } = $$props;
	let { target = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let { routeProps = undefined } = $$props;
	let el;

	function onClick() {
		emit('click');
	}

	function li_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(6, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(11, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
		if ('title' in $$new_props) $$invalidate(1, title = $$new_props.title);
		if ('text' in $$new_props) $$invalidate(2, text = $$new_props.text);
		if ('tabLink' in $$new_props) $$invalidate(12, tabLink = $$new_props.tabLink);
		if ('tabLinkActive' in $$new_props) $$invalidate(13, tabLinkActive = $$new_props.tabLinkActive);
		if ('link' in $$new_props) $$invalidate(14, link = $$new_props.link);
		if ('href' in $$new_props) $$invalidate(15, href = $$new_props.href);
		if ('target' in $$new_props) $$invalidate(16, target = $$new_props.target);
		if ('tooltip' in $$new_props) $$invalidate(3, tooltip = $$new_props.tooltip);
		if ('tooltipTrigger' in $$new_props) $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
		if ('routeProps' in $$new_props) $$invalidate(5, routeProps = $$new_props.routeProps);
		if ('$$scope' in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*link, href*/ 49152) {
			$: $$invalidate(17, hrefComputed = typeof link === 'boolean' && typeof href === 'boolean'
			? '#'
			: link || href);
		}

		$: $$invalidate(8, attrs = extend(
			{
				href: hrefComputed,
				target,
				'data-tab': isStringProp(tabLink) && tabLink || undefined
			},
			routerAttrs($$props),
			actionsAttrs($$props)
		));

		$: $$invalidate(7, classes = classNames(
			{
				'list-button': true,
				'tab-link': tabLink || tabLink === '',
				'tab-link-active': tabLinkActive
			},
			colorClasses($$props),
			routerClasses($$props),
			actionsClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		className,
		title,
		text,
		tooltip,
		tooltipTrigger,
		routeProps,
		el,
		classes,
		attrs,
		onClick,
		$$restProps,
		lec,
		tabLink,
		tabLinkActive,
		link,
		href,
		target,
		hrefComputed,
		$$scope,
		slots,
		li_binding
	];
}

class List_button extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$K, create_fragment$P, safe_not_equal, {
			lec: 11,
			class: 0,
			title: 1,
			text: 2,
			tabLink: 12,
			tabLinkActive: 13,
			link: 14,
			href: 15,
			target: 16,
			tooltip: 3,
			tooltipTrigger: 4,
			routeProps: 5
		});
	}
}

// eslint-disable-next-line
const setReactiveContext = (name, getValue) => {
  const contextCallbacks = [];
  const contextSubscribe = callback => {
    contextCallbacks.push(callback);
  };
  const contextUnsubscribe = callback => {
    if (contextCallbacks.indexOf(callback) >= 0) {
      contextCallbacks.splice(contextCallbacks.indexOf, callback);
    }
  };
  const contextRunCallbacks = () => {
    contextCallbacks.forEach(callback => {
      callback(getValue());
    });
  };
  setContext(name, {
    value: getValue(),
    subscribe: contextSubscribe,
    unsubscribe: contextUnsubscribe
  });
  beforeUpdate(() => {
    contextRunCallbacks();
  });
};

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/list-group.liquivelte generated by Svelte v3.50.0 */

function create_fragment$O(ctx) {
	let div;
	let ul;
	let div_data_sortable_move_elements_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

	let div_levels = [
		{ class: /*classes*/ ctx[1] },
		{
			"data-sortable-move-elements": div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[0] !== 'undefined'
			? /*sortableMoveElements*/ ctx[0].toString()
			: undefined
		},
		restProps(/*$$restProps*/ ctx[2])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			ul = element("ul");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {
				class: true,
				"data-sortable-move-elements": true
			});

			var div_nodes = children(div);
			ul = claim_element(div_nodes, "UL", {});
			var ul_nodes = children(ul);
			if (default_slot) default_slot.l(ul_nodes);
			ul_nodes.forEach(detach);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, ul);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[10],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				(!current || dirty & /*sortableMoveElements*/ 1 && div_data_sortable_move_elements_value !== (div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[0] !== 'undefined'
				? /*sortableMoveElements*/ ctx[0].toString()
				: undefined)) && {
					"data-sortable-move-elements": div_data_sortable_move_elements_value
				},
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$Q = 0;

function instance$J($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"lec","class","mediaList","sortable","sortableOpposite","sortableTapHold","sortableMoveElements","simpleList"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let { mediaList = undefined } = $$props;
	let { sortable = undefined } = $$props;
	let { sortableOpposite = undefined } = $$props;
	let { sortableTapHold = false } = $$props;
	let { sortableMoveElements = undefined } = $$props;
	let { simpleList = undefined } = $$props;

	let ListContext = getReactiveContext('ListContext', value => {
		ListContext = value || {};
	}) || {};

	setReactiveContext('ListContext', () => ({
		listIsMedia: mediaList || ListContext.listIsMedia,
		listIsSimple: simpleList || ListContext.listIsSimple,
		listIsSortable: sortable || ListContext.listIsSortable,
		listIsSortableOpposite: sortableOpposite || ListContext.listIsSortableOpposite
	}));

	$$self.$$set = $$new_props => {
		$$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(3, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('mediaList' in $$new_props) $$invalidate(5, mediaList = $$new_props.mediaList);
		if ('sortable' in $$new_props) $$invalidate(6, sortable = $$new_props.sortable);
		if ('sortableOpposite' in $$new_props) $$invalidate(7, sortableOpposite = $$new_props.sortableOpposite);
		if ('sortableTapHold' in $$new_props) $$invalidate(8, sortableTapHold = $$new_props.sortableTapHold);
		if ('sortableMoveElements' in $$new_props) $$invalidate(0, sortableMoveElements = $$new_props.sortableMoveElements);
		if ('simpleList' in $$new_props) $$invalidate(9, simpleList = $$new_props.simpleList);
		if ('$$scope' in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(1, classes = classNames(
			className,
			'list-group',
			{
				'media-list': mediaList,
				sortable,
				'sortable-tap-hold': sortableTapHold,
				'sortable-opposite': sortableOpposite
			},
			colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		sortableMoveElements,
		classes,
		$$restProps,
		lec,
		className,
		mediaList,
		sortable,
		sortableOpposite,
		sortableTapHold,
		simpleList,
		$$scope,
		slots
	];
}

class List_group extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$J, create_fragment$O, safe_not_equal, {
			lec: 3,
			class: 4,
			mediaList: 5,
			sortable: 6,
			sortableOpposite: 7,
			sortableTapHold: 8,
			sortableMoveElements: 0,
			simpleList: 9
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/list-index.liquivelte generated by Svelte v3.50.0 */
const get_default_slot_changes$3 = dirty => ({ listIndex: dirty & /*f7ListIndex*/ 4 });
const get_default_slot_context$3 = ctx => ({ listIndex: /*f7ListIndex*/ ctx[2] });

function create_fragment$N(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[19].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], get_default_slot_context$3);

	let div_levels = [
		{ class: /*classes*/ ctx[3] },
		{ "data-f7-slot": /*f7Slot*/ ctx[0] },
		restProps(/*$$restProps*/ ctx[4])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true, "data-f7-slot": true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[20](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope, f7ListIndex*/ 262148)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[18],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, get_default_slot_changes$3),
						get_default_slot_context$3
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				(!current || dirty & /*f7Slot*/ 1) && { "data-f7-slot": /*f7Slot*/ ctx[0] },
				dirty & /*$$restProps*/ 16 && restProps(/*$$restProps*/ ctx[4])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[20](null);
		}
	};
}

let index$P = 0;

function instance_1$5($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"lec","class","init","listEl","indexes","scrollList","label","iosItemHeight","mdItemHeight","auroraItemHeight","f7Slot","instance","update","scrollListToIndex"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { init = true } = $$props;
	let { listEl = undefined } = $$props;
	let { indexes = 'auto' } = $$props;
	let { scrollList = true } = $$props;
	let { label = false } = $$props;
	let { iosItemHeight = 14 } = $$props;
	let { mdItemHeight = 14 } = $$props;
	let { auroraItemHeight = 14 } = $$props;
	let { f7Slot = 'fixed' } = $$props;
	let el;
	let f7ListIndex;

	function instance() {
		return f7ListIndex;
	}

	function update() {
		if (!f7ListIndex) return;
		f7ListIndex.update();
	}

	function scrollListToIndex(indexContent) {
		if (!f7ListIndex) return;
		f7ListIndex.scrollListToIndex(indexContent);
	}

	let initialWatched = false;

	function watchIndexes() {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7ListIndex) return;
		$$invalidate(2, f7ListIndex.params.indexes = indexes, f7ListIndex);
		update();
	}

	onMount(() => {
		if (!init || !el) return;

		f7ready(() => {
			$$invalidate(2, f7ListIndex = app.f7.listIndex.create({
				el,
				listEl,
				indexes,
				iosItemHeight,
				mdItemHeight,
				auroraItemHeight,
				scrollList,
				label,
				on: {
					select(index, itemContent, itemIndex) {
						emit('listIndexSelect', [itemContent, itemIndex]);
					}
				}
			}));
		});
	});

	onDestroy(() => {
		if (f7ListIndex && f7ListIndex.destroy) f7ListIndex.destroy();
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(25, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(5, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('init' in $$new_props) $$invalidate(7, init = $$new_props.init);
		if ('listEl' in $$new_props) $$invalidate(8, listEl = $$new_props.listEl);
		if ('indexes' in $$new_props) $$invalidate(9, indexes = $$new_props.indexes);
		if ('scrollList' in $$new_props) $$invalidate(10, scrollList = $$new_props.scrollList);
		if ('label' in $$new_props) $$invalidate(11, label = $$new_props.label);
		if ('iosItemHeight' in $$new_props) $$invalidate(12, iosItemHeight = $$new_props.iosItemHeight);
		if ('mdItemHeight' in $$new_props) $$invalidate(13, mdItemHeight = $$new_props.mdItemHeight);
		if ('auroraItemHeight' in $$new_props) $$invalidate(14, auroraItemHeight = $$new_props.auroraItemHeight);
		if ('f7Slot' in $$new_props) $$invalidate(0, f7Slot = $$new_props.f7Slot);
		if ('$$scope' in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(3, classes = classNames(className, 'list-index', colorClasses($$props)));

		if ($$self.$$.dirty & /*indexes*/ 512) {
			$: watchIndexes(indexes);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		f7Slot,
		el,
		f7ListIndex,
		classes,
		$$restProps,
		lec,
		className,
		init,
		listEl,
		indexes,
		scrollList,
		label,
		iosItemHeight,
		mdItemHeight,
		auroraItemHeight,
		instance,
		update,
		scrollListToIndex,
		$$scope,
		slots,
		div_binding
	];
}

class List_index extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance_1$5, create_fragment$N, safe_not_equal, {
			lec: 5,
			class: 6,
			init: 7,
			listEl: 8,
			indexes: 9,
			scrollList: 10,
			label: 11,
			iosItemHeight: 12,
			mdItemHeight: 13,
			auroraItemHeight: 14,
			f7Slot: 0,
			instance: 15,
			update: 16,
			scrollListToIndex: 17
		});
	}

	get instance() {
		return this.$$.ctx[15];
	}

	get update() {
		return this.$$.ctx[16];
	}

	get scrollListToIndex() {
		return this.$$.ctx[17];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/list-input.liquivelte generated by Svelte v3.50.0 */
const get_content_end_slot_changes_1$2 = dirty => ({});
const get_content_end_slot_context_1$2 = ctx => ({});
const get_content_slot_changes_1$2 = dirty => ({});
const get_content_slot_context_1$2 = ctx => ({});
const get_inner_end_slot_changes_1$2 = dirty => ({});
const get_inner_end_slot_context_1$2 = ctx => ({});
const get_inner_slot_changes_1$1 = dirty => ({});
const get_inner_slot_context_1$1 = ctx => ({});
const get_info_slot_changes_1 = dirty => ({});
const get_info_slot_context_1 = ctx => ({});
const get_error_message_slot_changes_1 = dirty => ({});
const get_error_message_slot_context_1 = ctx => ({});
const get_input_slot_changes_1 = dirty => ({});
const get_input_slot_context_1 = ctx => ({});
const get_label_slot_changes_1$1 = dirty => ({});
const get_label_slot_context_1$1 = ctx => ({});
const get_inner_start_slot_changes_1$2 = dirty => ({});
const get_inner_start_slot_context_1$2 = ctx => ({});
const get_media_slot_changes_1$2 = dirty => ({});
const get_media_slot_context_1$2 = ctx => ({});
const get_content_start_slot_changes_1$2 = dirty => ({});
const get_content_start_slot_context_1$2 = ctx => ({});
const get_root_end_slot_changes$2 = dirty => ({});
const get_root_end_slot_context$2 = ctx => ({});
const get_root_slot_changes$2 = dirty => ({});
const get_root_slot_context$2 = ctx => ({});
const get_content_end_slot_changes$3 = dirty => ({});
const get_content_end_slot_context$3 = ctx => ({});
const get_content_slot_changes$2 = dirty => ({});
const get_content_slot_context$2 = ctx => ({});
const get_inner_end_slot_changes$3 = dirty => ({});
const get_inner_end_slot_context$3 = ctx => ({});
const get_inner_slot_changes$1 = dirty => ({});
const get_inner_slot_context$1 = ctx => ({});
const get_info_slot_changes = dirty => ({});
const get_info_slot_context = ctx => ({});
const get_error_message_slot_changes = dirty => ({});
const get_error_message_slot_context = ctx => ({});
const get_input_slot_changes = dirty => ({});
const get_input_slot_context = ctx => ({});
const get_label_slot_changes$1 = dirty => ({});
const get_label_slot_context$1 = ctx => ({});
const get_inner_start_slot_changes$3 = dirty => ({});
const get_inner_start_slot_context$3 = ctx => ({});
const get_media_slot_changes$2 = dirty => ({});
const get_media_slot_context$2 = ctx => ({});
const get_content_start_slot_changes$3 = dirty => ({});
const get_content_start_slot_context$3 = ctx => ({});
const get_root_start_slot_changes$2 = dirty => ({});
const get_root_start_slot_context$2 = ctx => ({});

// (582:0) {:else}
function create_else_block_1$2(ctx) {
	let div2;
	let t0;
	let t1;
	let t2;
	let div1;
	let t3;
	let t4;
	let div0;
	let t5;
	let t6;
	let t7;
	let t8;
	let t9;
	let t10;
	let t11;
	let t12;
	let current;
	const content_start_slot_template = /*#slots*/ ctx[78]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[77], get_content_start_slot_context_1$2);
	let if_block0 = /*isSortable*/ ctx[52] && /*isSortableOpposite*/ ctx[51] && create_if_block_23$1(ctx);
	let if_block1 = (/*media*/ ctx[2] || /*hasMediaSlots*/ ctx[49]) && create_if_block_21$1(ctx);
	const inner_start_slot_template = /*#slots*/ ctx[78]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[77], get_inner_start_slot_context_1$2);
	let if_block2 = (typeof /*label*/ ctx[37] !== 'undefined' || /*hasLabelSlots*/ ctx[48]) && create_if_block_20$1(ctx);
	let if_block3 = /*input*/ ctx[4] && create_if_block_16$1(ctx);
	const input_slot_template = /*#slots*/ ctx[78].input;
	const input_slot = create_slot(input_slot_template, ctx, /*$$scope*/ ctx[77], get_input_slot_context_1);
	let if_block4 = /*hasErrorMessage*/ ctx[39] && /*errorMessageForce*/ ctx[35] && create_if_block_15$1(ctx);
	let if_block5 = /*clearButton*/ ctx[33] && create_if_block_14$1(ctx);
	let if_block6 = (typeof /*info*/ ctx[36] !== 'undefined' || /*hasInfoSlots*/ ctx[40]) && create_if_block_13$1(ctx);
	const inner_slot_template = /*#slots*/ ctx[78].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[77], get_inner_slot_context_1$1);
	const inner_end_slot_template = /*#slots*/ ctx[78]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[77], get_inner_end_slot_context_1$2);
	const content_slot_template = /*#slots*/ ctx[78].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[77], get_content_slot_context_1$2);
	const content_end_slot_template = /*#slots*/ ctx[78]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[77], get_content_end_slot_context_1$2);
	let div2_levels = [{ class: /*itemContentClasses*/ ctx[46] }, restProps(/*$$restProps*/ ctx[57])];
	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	return {
		c() {
			div2 = element("div");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div1 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			div0 = element("div");
			if (if_block3) if_block3.c();
			t5 = space();
			if (input_slot) input_slot.c();
			t6 = space();
			if (if_block4) if_block4.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			t9 = space();
			if (inner_slot) inner_slot.c();
			t10 = space();
			if (inner_end_slot) inner_end_slot.c();
			t11 = space();
			if (content_slot) content_slot.c();
			t12 = space();
			if (content_end_slot) content_end_slot.c();
			this.h();
		},
		l(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			if (content_start_slot) content_start_slot.l(div2_nodes);
			t0 = claim_space(div2_nodes);
			if (if_block0) if_block0.l(div2_nodes);
			t1 = claim_space(div2_nodes);
			if (if_block1) if_block1.l(div2_nodes);
			t2 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (inner_start_slot) inner_start_slot.l(div1_nodes);
			t3 = claim_space(div1_nodes);
			if (if_block2) if_block2.l(div1_nodes);
			t4 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (if_block3) if_block3.l(div0_nodes);
			t5 = claim_space(div0_nodes);
			if (input_slot) input_slot.l(div0_nodes);
			t6 = claim_space(div0_nodes);
			if (if_block4) if_block4.l(div0_nodes);
			t7 = claim_space(div0_nodes);
			if (if_block5) if_block5.l(div0_nodes);
			t8 = claim_space(div0_nodes);
			if (if_block6) if_block6.l(div0_nodes);
			div0_nodes.forEach(detach);
			t9 = claim_space(div1_nodes);
			if (inner_slot) inner_slot.l(div1_nodes);
			t10 = claim_space(div1_nodes);
			if (inner_end_slot) inner_end_slot.l(div1_nodes);
			div1_nodes.forEach(detach);
			t11 = claim_space(div2_nodes);
			if (content_slot) content_slot.l(div2_nodes);
			t12 = claim_space(div2_nodes);
			if (content_end_slot) content_end_slot.l(div2_nodes);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", /*inputWrapClasses*/ ctx[44]);
			attr(div1, "class", "item-inner");
			set_attributes(div2, div2_data);
		},
		m(target, anchor) {
			insert_hydration(target, div2, anchor);

			if (content_start_slot) {
				content_start_slot.m(div2, null);
			}

			append_hydration(div2, t0);
			if (if_block0) if_block0.m(div2, null);
			append_hydration(div2, t1);
			if (if_block1) if_block1.m(div2, null);
			append_hydration(div2, t2);
			append_hydration(div2, div1);

			if (inner_start_slot) {
				inner_start_slot.m(div1, null);
			}

			append_hydration(div1, t3);
			if (if_block2) if_block2.m(div1, null);
			append_hydration(div1, t4);
			append_hydration(div1, div0);
			if (if_block3) if_block3.m(div0, null);
			append_hydration(div0, t5);

			if (input_slot) {
				input_slot.m(div0, null);
			}

			append_hydration(div0, t6);
			if (if_block4) if_block4.m(div0, null);
			append_hydration(div0, t7);
			if (if_block5) if_block5.m(div0, null);
			append_hydration(div0, t8);
			if (if_block6) if_block6.m(div0, null);
			append_hydration(div1, t9);

			if (inner_slot) {
				inner_slot.m(div1, null);
			}

			append_hydration(div1, t10);

			if (inner_end_slot) {
				inner_end_slot.m(div1, null);
			}

			append_hydration(div2, t11);

			if (content_slot) {
				content_slot.m(div2, null);
			}

			append_hydration(div2, t12);

			if (content_end_slot) {
				content_end_slot.m(div2, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						content_start_slot,
						content_start_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[77], dirty, get_content_start_slot_changes_1$2),
						get_content_start_slot_context_1$2
					);
				}
			}

			if (/*isSortable*/ ctx[52] && /*isSortableOpposite*/ ctx[51]) {
				if (if_block0) {
					
				} else {
					if_block0 = create_if_block_23$1(ctx);
					if_block0.c();
					if_block0.m(div2, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*media*/ ctx[2] || /*hasMediaSlots*/ ctx[49]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*media*/ 4 | dirty[1] & /*hasMediaSlots*/ 262144) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_21$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div2, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						inner_start_slot,
						inner_start_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[77], dirty, get_inner_start_slot_changes_1$2),
						get_inner_start_slot_context_1$2
					);
				}
			}

			if (typeof /*label*/ ctx[37] !== 'undefined' || /*hasLabelSlots*/ ctx[48]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*label, hasLabelSlots*/ 131136) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_20$1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, t4);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*input*/ ctx[4]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*input*/ 16) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_16$1(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div0, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (input_slot) {
				if (input_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						input_slot,
						input_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(input_slot_template, /*$$scope*/ ctx[77], dirty, get_input_slot_changes_1),
						get_input_slot_context_1
					);
				}
			}

			if (/*hasErrorMessage*/ ctx[39] && /*errorMessageForce*/ ctx[35]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasErrorMessage, errorMessageForce*/ 272) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_15$1(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(div0, t7);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (/*clearButton*/ ctx[33]) {
				if (if_block5) {
					
				} else {
					if_block5 = create_if_block_14$1(ctx);
					if_block5.c();
					if_block5.m(div0, t8);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (typeof /*info*/ ctx[36] !== 'undefined' || /*hasInfoSlots*/ ctx[40]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*info, hasInfoSlots*/ 544) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_13$1(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(div0, null);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}

			if (!current || dirty[1] & /*inputWrapClasses*/ 8192) {
				attr(div0, "class", /*inputWrapClasses*/ ctx[44]);
			}

			if (inner_slot) {
				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						inner_slot,
						inner_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[77], dirty, get_inner_slot_changes_1$1),
						get_inner_slot_context_1$1
					);
				}
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						inner_end_slot,
						inner_end_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[77], dirty, get_inner_end_slot_changes_1$2),
						get_inner_end_slot_context_1$2
					);
				}
			}

			if (content_slot) {
				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						content_slot,
						content_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[77], dirty, get_content_slot_changes_1$2),
						get_content_slot_context_1$2
					);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						content_end_slot,
						content_end_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[77], dirty, get_content_end_slot_changes_1$2),
						get_content_end_slot_context_1$2
					);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty[1] & /*itemContentClasses*/ 32768) && { class: /*itemContentClasses*/ ctx[46] },
				dirty[1] & /*$$restProps*/ 67108864 && restProps(/*$$restProps*/ ctx[57])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(input_slot, local);
			transition_in(if_block4);
			transition_in(if_block6);
			transition_in(inner_slot, local);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(input_slot, local);
			transition_out(if_block4);
			transition_out(if_block6);
			transition_out(inner_slot, local);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (input_slot) input_slot.d(detaching);
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			if (inner_slot) inner_slot.d(detaching);
			if (inner_end_slot) inner_end_slot.d(detaching);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
		}
	};
}

// (378:0) {#if wrap}
function create_if_block$o(ctx) {
	let li;
	let t0;
	let div2;
	let t1;
	let t2;
	let t3;
	let div1;
	let t4;
	let t5;
	let div0;
	let t6;
	let t7;
	let t8;
	let t9;
	let t10;
	let t11;
	let t12;
	let t13;
	let t14;
	let t15;
	let t16;
	let current;
	const root_start_slot_template = /*#slots*/ ctx[78]["root-start"];
	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[77], get_root_start_slot_context$2);
	const content_start_slot_template = /*#slots*/ ctx[78]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[77], get_content_start_slot_context$3);
	let if_block0 = /*isSortable*/ ctx[52] && /*isSortableOpposite*/ ctx[51] && create_if_block_12$1(ctx);
	let if_block1 = (/*media*/ ctx[2] || /*hasMediaSlots*/ ctx[49]) && create_if_block_10$2(ctx);
	const inner_start_slot_template = /*#slots*/ ctx[78]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[77], get_inner_start_slot_context$3);
	let if_block2 = (typeof /*label*/ ctx[37] !== 'undefined' || /*hasLabelSlots*/ ctx[48]) && create_if_block_9$2(ctx);
	let if_block3 = /*input*/ ctx[4] && create_if_block_5$3(ctx);
	const input_slot_template = /*#slots*/ ctx[78].input;
	const input_slot = create_slot(input_slot_template, ctx, /*$$scope*/ ctx[77], get_input_slot_context);
	let if_block4 = /*hasErrorMessage*/ ctx[39] && /*errorMessageForce*/ ctx[35] && create_if_block_4$5(ctx);
	let if_block5 = /*clearButton*/ ctx[33] && create_if_block_3$9(ctx);
	let if_block6 = (typeof /*info*/ ctx[36] !== 'undefined' || /*hasInfoSlots*/ ctx[40]) && create_if_block_2$a(ctx);
	const inner_slot_template = /*#slots*/ ctx[78].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[77], get_inner_slot_context$1);
	const inner_end_slot_template = /*#slots*/ ctx[78]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[77], get_inner_end_slot_context$3);
	const content_slot_template = /*#slots*/ ctx[78].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[77], get_content_slot_context$2);
	const content_end_slot_template = /*#slots*/ ctx[78]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[77], get_content_end_slot_context$3);
	let if_block7 = /*isSortable*/ ctx[52] && !/*isSortableOpposite*/ ctx[51] && create_if_block_1$f(ctx);
	const root_slot_template = /*#slots*/ ctx[78].root;
	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[77], get_root_slot_context$2);
	const root_end_slot_template = /*#slots*/ ctx[78]["root-end"];
	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[77], get_root_end_slot_context$2);
	let li_levels = [{ class: /*classes*/ ctx[43] }, restProps(/*$$restProps*/ ctx[57])];
	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	return {
		c() {
			li = element("li");
			if (root_start_slot) root_start_slot.c();
			t0 = space();
			div2 = element("div");
			if (content_start_slot) content_start_slot.c();
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			div1 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			t5 = space();
			div0 = element("div");
			if (if_block3) if_block3.c();
			t6 = space();
			if (input_slot) input_slot.c();
			t7 = space();
			if (if_block4) if_block4.c();
			t8 = space();
			if (if_block5) if_block5.c();
			t9 = space();
			if (if_block6) if_block6.c();
			t10 = space();
			if (inner_slot) inner_slot.c();
			t11 = space();
			if (inner_end_slot) inner_end_slot.c();
			t12 = space();
			if (content_slot) content_slot.c();
			t13 = space();
			if (content_end_slot) content_end_slot.c();
			t14 = space();
			if (if_block7) if_block7.c();
			t15 = space();
			if (root_slot) root_slot.c();
			t16 = space();
			if (root_end_slot) root_end_slot.c();
			this.h();
		},
		l(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			if (root_start_slot) root_start_slot.l(li_nodes);
			t0 = claim_space(li_nodes);
			div2 = claim_element(li_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			if (content_start_slot) content_start_slot.l(div2_nodes);
			t1 = claim_space(div2_nodes);
			if (if_block0) if_block0.l(div2_nodes);
			t2 = claim_space(div2_nodes);
			if (if_block1) if_block1.l(div2_nodes);
			t3 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (inner_start_slot) inner_start_slot.l(div1_nodes);
			t4 = claim_space(div1_nodes);
			if (if_block2) if_block2.l(div1_nodes);
			t5 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (if_block3) if_block3.l(div0_nodes);
			t6 = claim_space(div0_nodes);
			if (input_slot) input_slot.l(div0_nodes);
			t7 = claim_space(div0_nodes);
			if (if_block4) if_block4.l(div0_nodes);
			t8 = claim_space(div0_nodes);
			if (if_block5) if_block5.l(div0_nodes);
			t9 = claim_space(div0_nodes);
			if (if_block6) if_block6.l(div0_nodes);
			div0_nodes.forEach(detach);
			t10 = claim_space(div1_nodes);
			if (inner_slot) inner_slot.l(div1_nodes);
			t11 = claim_space(div1_nodes);
			if (inner_end_slot) inner_end_slot.l(div1_nodes);
			div1_nodes.forEach(detach);
			t12 = claim_space(div2_nodes);
			if (content_slot) content_slot.l(div2_nodes);
			t13 = claim_space(div2_nodes);
			if (content_end_slot) content_end_slot.l(div2_nodes);
			div2_nodes.forEach(detach);
			t14 = claim_space(li_nodes);
			if (if_block7) if_block7.l(li_nodes);
			t15 = claim_space(li_nodes);
			if (root_slot) root_slot.l(li_nodes);
			t16 = claim_space(li_nodes);
			if (root_end_slot) root_end_slot.l(li_nodes);
			li_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", /*inputWrapClasses*/ ctx[44]);
			attr(div1, "class", "item-inner");
			attr(div2, "class", /*itemContentClasses*/ ctx[46]);
			set_attributes(li, li_data);
		},
		m(target, anchor) {
			insert_hydration(target, li, anchor);

			if (root_start_slot) {
				root_start_slot.m(li, null);
			}

			append_hydration(li, t0);
			append_hydration(li, div2);

			if (content_start_slot) {
				content_start_slot.m(div2, null);
			}

			append_hydration(div2, t1);
			if (if_block0) if_block0.m(div2, null);
			append_hydration(div2, t2);
			if (if_block1) if_block1.m(div2, null);
			append_hydration(div2, t3);
			append_hydration(div2, div1);

			if (inner_start_slot) {
				inner_start_slot.m(div1, null);
			}

			append_hydration(div1, t4);
			if (if_block2) if_block2.m(div1, null);
			append_hydration(div1, t5);
			append_hydration(div1, div0);
			if (if_block3) if_block3.m(div0, null);
			append_hydration(div0, t6);

			if (input_slot) {
				input_slot.m(div0, null);
			}

			append_hydration(div0, t7);
			if (if_block4) if_block4.m(div0, null);
			append_hydration(div0, t8);
			if (if_block5) if_block5.m(div0, null);
			append_hydration(div0, t9);
			if (if_block6) if_block6.m(div0, null);
			append_hydration(div1, t10);

			if (inner_slot) {
				inner_slot.m(div1, null);
			}

			append_hydration(div1, t11);

			if (inner_end_slot) {
				inner_end_slot.m(div1, null);
			}

			append_hydration(div2, t12);

			if (content_slot) {
				content_slot.m(div2, null);
			}

			append_hydration(div2, t13);

			if (content_end_slot) {
				content_end_slot.m(div2, null);
			}

			append_hydration(li, t14);
			if (if_block7) if_block7.m(li, null);
			append_hydration(li, t15);

			if (root_slot) {
				root_slot.m(li, null);
			}

			append_hydration(li, t16);

			if (root_end_slot) {
				root_end_slot.m(li, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (root_start_slot) {
				if (root_start_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						root_start_slot,
						root_start_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(root_start_slot_template, /*$$scope*/ ctx[77], dirty, get_root_start_slot_changes$2),
						get_root_start_slot_context$2
					);
				}
			}

			if (content_start_slot) {
				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						content_start_slot,
						content_start_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[77], dirty, get_content_start_slot_changes$3),
						get_content_start_slot_context$3
					);
				}
			}

			if (/*isSortable*/ ctx[52] && /*isSortableOpposite*/ ctx[51]) {
				if (if_block0) {
					
				} else {
					if_block0 = create_if_block_12$1(ctx);
					if_block0.c();
					if_block0.m(div2, t2);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*media*/ ctx[2] || /*hasMediaSlots*/ ctx[49]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*media*/ 4 | dirty[1] & /*hasMediaSlots*/ 262144) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_10$2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div2, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						inner_start_slot,
						inner_start_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[77], dirty, get_inner_start_slot_changes$3),
						get_inner_start_slot_context$3
					);
				}
			}

			if (typeof /*label*/ ctx[37] !== 'undefined' || /*hasLabelSlots*/ ctx[48]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*label, hasLabelSlots*/ 131136) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_9$2(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, t5);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*input*/ ctx[4]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*input*/ 16) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_5$3(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div0, t6);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (input_slot) {
				if (input_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						input_slot,
						input_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(input_slot_template, /*$$scope*/ ctx[77], dirty, get_input_slot_changes),
						get_input_slot_context
					);
				}
			}

			if (/*hasErrorMessage*/ ctx[39] && /*errorMessageForce*/ ctx[35]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasErrorMessage, errorMessageForce*/ 272) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_4$5(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(div0, t8);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (/*clearButton*/ ctx[33]) {
				if (if_block5) {
					
				} else {
					if_block5 = create_if_block_3$9(ctx);
					if_block5.c();
					if_block5.m(div0, t9);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (typeof /*info*/ ctx[36] !== 'undefined' || /*hasInfoSlots*/ ctx[40]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*info, hasInfoSlots*/ 544) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_2$a(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(div0, null);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}

			if (!current || dirty[1] & /*inputWrapClasses*/ 8192) {
				attr(div0, "class", /*inputWrapClasses*/ ctx[44]);
			}

			if (inner_slot) {
				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						inner_slot,
						inner_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[77], dirty, get_inner_slot_changes$1),
						get_inner_slot_context$1
					);
				}
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						inner_end_slot,
						inner_end_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[77], dirty, get_inner_end_slot_changes$3),
						get_inner_end_slot_context$3
					);
				}
			}

			if (content_slot) {
				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						content_slot,
						content_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[77], dirty, get_content_slot_changes$2),
						get_content_slot_context$2
					);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						content_end_slot,
						content_end_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[77], dirty, get_content_end_slot_changes$3),
						get_content_end_slot_context$3
					);
				}
			}

			if (!current || dirty[1] & /*itemContentClasses*/ 32768) {
				attr(div2, "class", /*itemContentClasses*/ ctx[46]);
			}

			if (/*isSortable*/ ctx[52] && !/*isSortableOpposite*/ ctx[51]) {
				if (if_block7) {
					
				} else {
					if_block7 = create_if_block_1$f(ctx);
					if_block7.c();
					if_block7.m(li, t15);
				}
			} else if (if_block7) {
				if_block7.d(1);
				if_block7 = null;
			}

			if (root_slot) {
				if (root_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						root_slot,
						root_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(root_slot_template, /*$$scope*/ ctx[77], dirty, get_root_slot_changes$2),
						get_root_slot_context$2
					);
				}
			}

			if (root_end_slot) {
				if (root_end_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						root_end_slot,
						root_end_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(root_end_slot_template, /*$$scope*/ ctx[77], dirty, get_root_end_slot_changes$2),
						get_root_end_slot_context$2
					);
				}
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty[1] & /*classes*/ 4096) && { class: /*classes*/ ctx[43] },
				dirty[1] & /*$$restProps*/ 67108864 && restProps(/*$$restProps*/ ctx[57])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(root_start_slot, local);
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(input_slot, local);
			transition_in(if_block4);
			transition_in(if_block6);
			transition_in(inner_slot, local);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			transition_in(root_slot, local);
			transition_in(root_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(root_start_slot, local);
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(input_slot, local);
			transition_out(if_block4);
			transition_out(if_block6);
			transition_out(inner_slot, local);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			transition_out(root_slot, local);
			transition_out(root_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (root_start_slot) root_start_slot.d(detaching);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (input_slot) input_slot.d(detaching);
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			if (inner_slot) inner_slot.d(detaching);
			if (inner_end_slot) inner_end_slot.d(detaching);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			if (if_block7) if_block7.d();
			if (root_slot) root_slot.d(detaching);
			if (root_end_slot) root_end_slot.d(detaching);
		}
	};
}

// (585:4) {#if isSortable && isSortableOpposite}
function create_if_block_23$1(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "sortable-handler");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (589:4) {#if media || hasMediaSlots}
function create_if_block_21$1(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[2] !== 'undefined' && create_if_block_22$1(ctx);
	const media_slot_template = /*#slots*/ ctx[78].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[77], get_media_slot_context_1$2);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			if (media_slot) media_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-media");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (typeof /*media*/ ctx[2] !== 'undefined') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_22$1(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						media_slot,
						media_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[77], dirty, get_media_slot_changes_1$2),
						get_media_slot_context_1$2
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};
}

// (591:8) {#if typeof media !== 'undefined'}
function create_if_block_22$1(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			this.h();
		},
		l(nodes) {
			img = claim_element(nodes, "IMG", { src: true });
			this.h();
		},
		h() {
			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[2])) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert_hydration(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*media*/ 4 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[2])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (597:6) {#if typeof label !== 'undefined' || hasLabelSlots}
function create_if_block_20$1(ctx) {
	let div;
	let t0_value = plainText(/*label*/ ctx[37]) + "";
	let t0;
	let t1;
	let current;
	const label_slot_template = /*#slots*/ ctx[78].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[77], get_label_slot_context_1$1);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (label_slot) label_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (label_slot) label_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", /*labelClasses*/ ctx[45]);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (label_slot) {
				label_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[1] & /*label*/ 64) && t0_value !== (t0_value = plainText(/*label*/ ctx[37]) + "")) set_data(t0, t0_value);

			if (label_slot) {
				if (label_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						label_slot,
						label_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[77], dirty, get_label_slot_changes_1$1),
						get_label_slot_context_1$1
					);
				}
			}

			if (!current || dirty[1] & /*labelClasses*/ 16384) {
				attr(div, "class", /*labelClasses*/ ctx[45]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(label_slot, local);
			current = true;
		},
		o(local) {
			transition_out(label_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (label_slot) label_slot.d(detaching);
		}
	};
}

// (604:8) {#if input}
function create_if_block_16$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block_17$1,
		create_if_block_18$1,
		create_if_block_19$1,
		create_else_block_2$2
	];

	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*type*/ ctx[5] === 'select') return 0;
		if (/*type*/ ctx[5] === 'textarea') return 1;
		if (/*type*/ ctx[5] === 'texteditor') return 2;
		return 3;
	}

	current_block_type_index = select_block_type_2(ctx, [-1, -1, -1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (707:10) {:else}
function create_else_block_2$2(ctx) {
	let input_1;
	let input_1_validate_value;
	let input_1_data_validate_value;
	let input_1_data_validate_on_blur_value;
	let input_1_data_error_message_value;
	let input_1_value_value;
	let mounted;
	let dispose;

	return {
		c() {
			input_1 = element("input");
			this.h();
		},
		l(nodes) {
			input_1 = claim_element(nodes, "INPUT", {
				style: true,
				name: true,
				type: true,
				inputmode: true,
				placeholder: true,
				id: true,
				size: true,
				accept: true,
				autocomplete: true,
				autocorrect: true,
				autocapitalize: true,
				spellcheck: true,
				autosave: true,
				max: true,
				maxlength: true,
				min: true,
				minlength: true,
				step: true,
				pattern: true,
				validate: true,
				"data-validate": true,
				"data-validate-on-blur": true,
				tabindex: true,
				"data-error-message": true,
				class: true
			});

			this.h();
		},
		h() {
			attr(input_1, "style", /*inputStyle*/ ctx[27]);
			attr(input_1, "name", /*name*/ ctx[6]);
			attr(input_1, "type", /*inputType*/ ctx[41]);
			attr(input_1, "inputmode", /*inputmode*/ ctx[7]);
			attr(input_1, "placeholder", /*placeholder*/ ctx[11]);
			attr(input_1, "id", /*inputId*/ ctx[12]);
			attr(input_1, "size", /*size*/ ctx[13]);
			attr(input_1, "accept", /*accept*/ ctx[14]);
			attr(input_1, "autocomplete", /*autocomplete*/ ctx[15]);
			attr(input_1, "autocorrect", /*autocorrect*/ ctx[16]);
			attr(input_1, "autocapitalize", /*autocapitalize*/ ctx[17]);
			attr(input_1, "spellcheck", /*spellcheck*/ ctx[18]);
			input_1.autofocus = /*autofocus*/ ctx[19];
			attr(input_1, "autosave", /*autosave*/ ctx[20]);
			input_1.disabled = /*disabled*/ ctx[10];
			attr(input_1, "max", /*max*/ ctx[21]);
			attr(input_1, "maxlength", /*maxlength*/ ctx[24]);
			attr(input_1, "min", /*min*/ ctx[22]);
			attr(input_1, "minlength", /*minlength*/ ctx[25]);
			attr(input_1, "step", /*step*/ ctx[23]);
			input_1.multiple = /*multiple*/ ctx[26];
			input_1.readOnly = /*readonly*/ ctx[8];
			input_1.required = /*required*/ ctx[9];
			attr(input_1, "pattern", /*pattern*/ ctx[28]);

			attr(input_1, "validate", input_1_validate_value = typeof /*validate*/ ctx[29] === 'string' && /*validate*/ ctx[29].length
			? /*validate*/ ctx[29]
			: undefined);

			attr(input_1, "data-validate", input_1_data_validate_value = /*validate*/ ctx[29] === true || /*validate*/ ctx[29] === '' || /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined);

			attr(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined);

			attr(input_1, "tabindex", /*tabindex*/ ctx[31]);

			attr(input_1, "data-error-message", input_1_data_error_message_value = /*errorMessageForce*/ ctx[35]
			? undefined
			: /*errorMessage*/ ctx[34]);

			attr(input_1, "class", /*inputClasses*/ ctx[47]);

			input_1.value = input_1_value_value = /*type*/ ctx[5] === 'datepicker' || /*type*/ ctx[5] === 'colorpicker' || /*type*/ ctx[5] === 'file'
			? ''
			: /*inputValue*/ ctx[50];
		},
		m(target, anchor) {
			insert_hydration(target, input_1, anchor);
			/*input_1_binding_1*/ ctx[84](input_1);
			if (/*autofocus*/ ctx[19]) input_1.focus();

			if (!mounted) {
				dispose = [
					listen(input_1, "focus", /*onFocus*/ ctx[54]),
					listen(input_1, "blur", /*onBlur*/ ctx[55]),
					listen(input_1, "input", /*onInput*/ ctx[53]),
					listen(input_1, "change", /*onChange*/ ctx[56])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 134217728) {
				attr(input_1, "style", /*inputStyle*/ ctx[27]);
			}

			if (dirty[0] & /*name*/ 64) {
				attr(input_1, "name", /*name*/ ctx[6]);
			}

			if (dirty[1] & /*inputType*/ 1024) {
				attr(input_1, "type", /*inputType*/ ctx[41]);
			}

			if (dirty[0] & /*inputmode*/ 128) {
				attr(input_1, "inputmode", /*inputmode*/ ctx[7]);
			}

			if (dirty[0] & /*placeholder*/ 2048) {
				attr(input_1, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (dirty[0] & /*inputId*/ 4096) {
				attr(input_1, "id", /*inputId*/ ctx[12]);
			}

			if (dirty[0] & /*size*/ 8192) {
				attr(input_1, "size", /*size*/ ctx[13]);
			}

			if (dirty[0] & /*accept*/ 16384) {
				attr(input_1, "accept", /*accept*/ ctx[14]);
			}

			if (dirty[0] & /*autocomplete*/ 32768) {
				attr(input_1, "autocomplete", /*autocomplete*/ ctx[15]);
			}

			if (dirty[0] & /*autocorrect*/ 65536) {
				attr(input_1, "autocorrect", /*autocorrect*/ ctx[16]);
			}

			if (dirty[0] & /*autocapitalize*/ 131072) {
				attr(input_1, "autocapitalize", /*autocapitalize*/ ctx[17]);
			}

			if (dirty[0] & /*spellcheck*/ 262144) {
				attr(input_1, "spellcheck", /*spellcheck*/ ctx[18]);
			}

			if (dirty[0] & /*autofocus*/ 524288) {
				input_1.autofocus = /*autofocus*/ ctx[19];
			}

			if (dirty[0] & /*autosave*/ 1048576) {
				attr(input_1, "autosave", /*autosave*/ ctx[20]);
			}

			if (dirty[0] & /*disabled*/ 1024) {
				input_1.disabled = /*disabled*/ ctx[10];
			}

			if (dirty[0] & /*max*/ 2097152) {
				attr(input_1, "max", /*max*/ ctx[21]);
			}

			if (dirty[0] & /*maxlength*/ 16777216) {
				attr(input_1, "maxlength", /*maxlength*/ ctx[24]);
			}

			if (dirty[0] & /*min*/ 4194304) {
				attr(input_1, "min", /*min*/ ctx[22]);
			}

			if (dirty[0] & /*minlength*/ 33554432) {
				attr(input_1, "minlength", /*minlength*/ ctx[25]);
			}

			if (dirty[0] & /*step*/ 8388608) {
				attr(input_1, "step", /*step*/ ctx[23]);
			}

			if (dirty[0] & /*multiple*/ 67108864) {
				input_1.multiple = /*multiple*/ ctx[26];
			}

			if (dirty[0] & /*readonly*/ 256) {
				input_1.readOnly = /*readonly*/ ctx[8];
			}

			if (dirty[0] & /*required*/ 512) {
				input_1.required = /*required*/ ctx[9];
			}

			if (dirty[0] & /*pattern*/ 268435456) {
				attr(input_1, "pattern", /*pattern*/ ctx[28]);
			}

			if (dirty[0] & /*validate*/ 536870912 && input_1_validate_value !== (input_1_validate_value = typeof /*validate*/ ctx[29] === 'string' && /*validate*/ ctx[29].length
			? /*validate*/ ctx[29]
			: undefined)) {
				attr(input_1, "validate", input_1_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 1610612736 && input_1_data_validate_value !== (input_1_data_validate_value = /*validate*/ ctx[29] === true || /*validate*/ ctx[29] === '' || /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined)) {
				attr(input_1, "data-validate", input_1_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 1073741824 && input_1_data_validate_on_blur_value !== (input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined)) {
				attr(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value);
			}

			if (dirty[1] & /*tabindex*/ 1) {
				attr(input_1, "tabindex", /*tabindex*/ ctx[31]);
			}

			if (dirty[1] & /*errorMessageForce, errorMessage*/ 24 && input_1_data_error_message_value !== (input_1_data_error_message_value = /*errorMessageForce*/ ctx[35]
			? undefined
			: /*errorMessage*/ ctx[34])) {
				attr(input_1, "data-error-message", input_1_data_error_message_value);
			}

			if (dirty[1] & /*inputClasses*/ 65536) {
				attr(input_1, "class", /*inputClasses*/ ctx[47]);
			}

			if (dirty[0] & /*type*/ 32 | dirty[1] & /*inputValue*/ 524288 && input_1_value_value !== (input_1_value_value = /*type*/ ctx[5] === 'datepicker' || /*type*/ ctx[5] === 'colorpicker' || /*type*/ ctx[5] === 'file'
			? ''
			: /*inputValue*/ ctx[50]) && input_1.value !== input_1_value_value) {
				input_1.value = input_1_value_value;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(input_1);
			/*input_1_binding_1*/ ctx[84](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (696:42) 
function create_if_block_19$1(ctx) {
	let texteditor;
	let current;

	const texteditor_spread_levels = [
		{
			value: typeof /*value*/ ctx[0] === 'undefined'
			? ''
			: /*value*/ ctx[0]
		},
		{ resizable: /*resizable*/ ctx[32] },
		{ placeholder: /*placeholder*/ ctx[11] },
		{ onTextEditorFocus: /*onFocus*/ ctx[54] },
		{ onTextEditorBlur: /*onBlur*/ ctx[55] },
		{ onTextEditorInput: /*onInput*/ ctx[53] },
		{ onTextEditorChange: /*onChange*/ ctx[56] },
		/*textEditorParams*/ ctx[38],
		{ lec: /*lec*/ ctx[1] }
	];

	let texteditor_props = {};

	for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
		texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
	}

	texteditor = new Text_editor({ props: texteditor_props });

	return {
		c() {
			create_component(texteditor.$$.fragment);
		},
		l(nodes) {
			claim_component(texteditor.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(texteditor, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const texteditor_changes = (dirty[0] & /*value, placeholder, lec*/ 2051 | dirty[1] & /*resizable, onFocus, onBlur, onInput, onChange, textEditorParams*/ 62914690)
			? get_spread_update(texteditor_spread_levels, [
					dirty[0] & /*value*/ 1 && {
						value: typeof /*value*/ ctx[0] === 'undefined'
						? ''
						: /*value*/ ctx[0]
					},
					dirty[1] & /*resizable*/ 2 && { resizable: /*resizable*/ ctx[32] },
					dirty[0] & /*placeholder*/ 2048 && { placeholder: /*placeholder*/ ctx[11] },
					dirty[1] & /*onFocus*/ 8388608 && { onTextEditorFocus: /*onFocus*/ ctx[54] },
					dirty[1] & /*onBlur*/ 16777216 && { onTextEditorBlur: /*onBlur*/ ctx[55] },
					dirty[1] & /*onInput*/ 4194304 && { onTextEditorInput: /*onInput*/ ctx[53] },
					dirty[1] & /*onChange*/ 33554432 && { onTextEditorChange: /*onChange*/ ctx[56] },
					dirty[1] & /*textEditorParams*/ 128 && get_spread_object(/*textEditorParams*/ ctx[38]),
					dirty[0] & /*lec*/ 2 && { lec: /*lec*/ ctx[1] }
				])
			: {};

			texteditor.$set(texteditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(texteditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(texteditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(texteditor, detaching);
		}
	};
}

// (651:40) 
function create_if_block_18$1(ctx) {
	let textarea;
	let textarea_validate_value;
	let textarea_data_validate_value;
	let textarea_data_validate_on_blur_value;
	let textarea_data_error_message_value;
	let mounted;
	let dispose;

	return {
		c() {
			textarea = element("textarea");
			this.h();
		},
		l(nodes) {
			textarea = claim_element(nodes, "TEXTAREA", {
				style: true,
				name: true,
				placeholder: true,
				id: true,
				size: true,
				inputmode: true,
				accept: true,
				autocomplete: true,
				autocorrect: true,
				autocapitalize: true,
				spellcheck: true,
				autosave: true,
				max: true,
				maxlength: true,
				min: true,
				minlength: true,
				step: true,
				multiple: true,
				pattern: true,
				validate: true,
				"data-validate": true,
				"data-validate-on-blur": true,
				tabindex: true,
				"data-error-message": true,
				class: true
			});

			children(textarea).forEach(detach);
			this.h();
		},
		h() {
			attr(textarea, "style", /*inputStyle*/ ctx[27]);
			attr(textarea, "name", /*name*/ ctx[6]);
			attr(textarea, "placeholder", /*placeholder*/ ctx[11]);
			attr(textarea, "id", /*inputId*/ ctx[12]);
			attr(textarea, "size", /*size*/ ctx[13]);
			attr(textarea, "inputmode", /*inputmode*/ ctx[7]);
			attr(textarea, "accept", /*accept*/ ctx[14]);
			attr(textarea, "autocomplete", /*autocomplete*/ ctx[15]);
			attr(textarea, "autocorrect", /*autocorrect*/ ctx[16]);
			attr(textarea, "autocapitalize", /*autocapitalize*/ ctx[17]);
			attr(textarea, "spellcheck", /*spellcheck*/ ctx[18]);
			textarea.autofocus = /*autofocus*/ ctx[19];
			attr(textarea, "autosave", /*autosave*/ ctx[20]);
			textarea.disabled = /*disabled*/ ctx[10];
			attr(textarea, "max", /*max*/ ctx[21]);
			attr(textarea, "maxlength", /*maxlength*/ ctx[24]);
			attr(textarea, "min", /*min*/ ctx[22]);
			attr(textarea, "minlength", /*minlength*/ ctx[25]);
			attr(textarea, "step", /*step*/ ctx[23]);
			attr(textarea, "multiple", /*multiple*/ ctx[26]);
			textarea.readOnly = /*readonly*/ ctx[8];
			textarea.required = /*required*/ ctx[9];
			attr(textarea, "pattern", /*pattern*/ ctx[28]);

			attr(textarea, "validate", textarea_validate_value = typeof /*validate*/ ctx[29] === 'string' && /*validate*/ ctx[29].length
			? /*validate*/ ctx[29]
			: undefined);

			attr(textarea, "data-validate", textarea_data_validate_value = /*validate*/ ctx[29] === true || /*validate*/ ctx[29] === '' || /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined);

			attr(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined);

			attr(textarea, "tabindex", /*tabindex*/ ctx[31]);

			attr(textarea, "data-error-message", textarea_data_error_message_value = /*errorMessageForce*/ ctx[35]
			? undefined
			: /*errorMessage*/ ctx[34]);

			attr(textarea, "class", /*inputClasses*/ ctx[47]);
			textarea.value = /*inputValue*/ ctx[50];
		},
		m(target, anchor) {
			insert_hydration(target, textarea, anchor);
			/*textarea_binding_1*/ ctx[83](textarea);
			if (/*autofocus*/ ctx[19]) textarea.focus();

			if (!mounted) {
				dispose = [
					listen(textarea, "focus", /*onFocus*/ ctx[54]),
					listen(textarea, "blur", /*onBlur*/ ctx[55]),
					listen(textarea, "input", /*onInput*/ ctx[53]),
					listen(textarea, "change", /*onChange*/ ctx[56])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 134217728) {
				attr(textarea, "style", /*inputStyle*/ ctx[27]);
			}

			if (dirty[0] & /*name*/ 64) {
				attr(textarea, "name", /*name*/ ctx[6]);
			}

			if (dirty[0] & /*placeholder*/ 2048) {
				attr(textarea, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (dirty[0] & /*inputId*/ 4096) {
				attr(textarea, "id", /*inputId*/ ctx[12]);
			}

			if (dirty[0] & /*size*/ 8192) {
				attr(textarea, "size", /*size*/ ctx[13]);
			}

			if (dirty[0] & /*inputmode*/ 128) {
				attr(textarea, "inputmode", /*inputmode*/ ctx[7]);
			}

			if (dirty[0] & /*accept*/ 16384) {
				attr(textarea, "accept", /*accept*/ ctx[14]);
			}

			if (dirty[0] & /*autocomplete*/ 32768) {
				attr(textarea, "autocomplete", /*autocomplete*/ ctx[15]);
			}

			if (dirty[0] & /*autocorrect*/ 65536) {
				attr(textarea, "autocorrect", /*autocorrect*/ ctx[16]);
			}

			if (dirty[0] & /*autocapitalize*/ 131072) {
				attr(textarea, "autocapitalize", /*autocapitalize*/ ctx[17]);
			}

			if (dirty[0] & /*spellcheck*/ 262144) {
				attr(textarea, "spellcheck", /*spellcheck*/ ctx[18]);
			}

			if (dirty[0] & /*autofocus*/ 524288) {
				textarea.autofocus = /*autofocus*/ ctx[19];
			}

			if (dirty[0] & /*autosave*/ 1048576) {
				attr(textarea, "autosave", /*autosave*/ ctx[20]);
			}

			if (dirty[0] & /*disabled*/ 1024) {
				textarea.disabled = /*disabled*/ ctx[10];
			}

			if (dirty[0] & /*max*/ 2097152) {
				attr(textarea, "max", /*max*/ ctx[21]);
			}

			if (dirty[0] & /*maxlength*/ 16777216) {
				attr(textarea, "maxlength", /*maxlength*/ ctx[24]);
			}

			if (dirty[0] & /*min*/ 4194304) {
				attr(textarea, "min", /*min*/ ctx[22]);
			}

			if (dirty[0] & /*minlength*/ 33554432) {
				attr(textarea, "minlength", /*minlength*/ ctx[25]);
			}

			if (dirty[0] & /*step*/ 8388608) {
				attr(textarea, "step", /*step*/ ctx[23]);
			}

			if (dirty[0] & /*multiple*/ 67108864) {
				attr(textarea, "multiple", /*multiple*/ ctx[26]);
			}

			if (dirty[0] & /*readonly*/ 256) {
				textarea.readOnly = /*readonly*/ ctx[8];
			}

			if (dirty[0] & /*required*/ 512) {
				textarea.required = /*required*/ ctx[9];
			}

			if (dirty[0] & /*pattern*/ 268435456) {
				attr(textarea, "pattern", /*pattern*/ ctx[28]);
			}

			if (dirty[0] & /*validate*/ 536870912 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/ ctx[29] === 'string' && /*validate*/ ctx[29].length
			? /*validate*/ ctx[29]
			: undefined)) {
				attr(textarea, "validate", textarea_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 1610612736 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/ ctx[29] === true || /*validate*/ ctx[29] === '' || /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined)) {
				attr(textarea, "data-validate", textarea_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 1073741824 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined)) {
				attr(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value);
			}

			if (dirty[1] & /*tabindex*/ 1) {
				attr(textarea, "tabindex", /*tabindex*/ ctx[31]);
			}

			if (dirty[1] & /*errorMessageForce, errorMessage*/ 24 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/ ctx[35]
			? undefined
			: /*errorMessage*/ ctx[34])) {
				attr(textarea, "data-error-message", textarea_data_error_message_value);
			}

			if (dirty[1] & /*inputClasses*/ 65536) {
				attr(textarea, "class", /*inputClasses*/ ctx[47]);
			}

			if (dirty[1] & /*inputValue*/ 524288) {
				textarea.value = /*inputValue*/ ctx[50];
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(textarea);
			/*textarea_binding_1*/ ctx[83](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (605:10) {#if type === 'select'}
function create_if_block_17$1(ctx) {
	let select;
	let select_validate_value;
	let select_data_validate_value;
	let select_data_validate_on_blur_value;
	let select_data_error_message_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[78].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[77], null);

	return {
		c() {
			select = element("select");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			select = claim_element(nodes, "SELECT", {
				style: true,
				name: true,
				placeholder: true,
				id: true,
				size: true,
				accept: true,
				autocomplete: true,
				autocorrect: true,
				autocapitalize: true,
				spellcheck: true,
				autosave: true,
				max: true,
				maxlength: true,
				min: true,
				minlength: true,
				step: true,
				readonly: true,
				pattern: true,
				validate: true,
				"data-validate": true,
				"data-validate-on-blur": true,
				tabindex: true,
				"data-error-message": true,
				class: true
			});

			var select_nodes = children(select);
			if (default_slot) default_slot.l(select_nodes);
			select_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(select, "style", /*inputStyle*/ ctx[27]);
			attr(select, "name", /*name*/ ctx[6]);
			attr(select, "placeholder", /*placeholder*/ ctx[11]);
			attr(select, "id", /*inputId*/ ctx[12]);
			attr(select, "size", /*size*/ ctx[13]);
			attr(select, "accept", /*accept*/ ctx[14]);
			attr(select, "autocomplete", /*autocomplete*/ ctx[15]);
			attr(select, "autocorrect", /*autocorrect*/ ctx[16]);
			attr(select, "autocapitalize", /*autocapitalize*/ ctx[17]);
			attr(select, "spellcheck", /*spellcheck*/ ctx[18]);
			select.autofocus = /*autofocus*/ ctx[19];
			attr(select, "autosave", /*autosave*/ ctx[20]);
			select.disabled = /*disabled*/ ctx[10];
			attr(select, "max", /*max*/ ctx[21]);
			attr(select, "maxlength", /*maxlength*/ ctx[24]);
			attr(select, "min", /*min*/ ctx[22]);
			attr(select, "minlength", /*minlength*/ ctx[25]);
			attr(select, "step", /*step*/ ctx[23]);
			select.multiple = /*multiple*/ ctx[26];
			attr(select, "readonly", /*readonly*/ ctx[8]);
			select.required = /*required*/ ctx[9];
			attr(select, "pattern", /*pattern*/ ctx[28]);

			attr(select, "validate", select_validate_value = typeof /*validate*/ ctx[29] === 'string' && /*validate*/ ctx[29].length
			? /*validate*/ ctx[29]
			: undefined);

			attr(select, "data-validate", select_data_validate_value = /*validate*/ ctx[29] === true || /*validate*/ ctx[29] === '' || /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined);

			attr(select, "data-validate-on-blur", select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined);

			attr(select, "tabindex", /*tabindex*/ ctx[31]);

			attr(select, "data-error-message", select_data_error_message_value = /*errorMessageForce*/ ctx[35]
			? undefined
			: /*errorMessage*/ ctx[34]);

			attr(select, "class", /*inputClasses*/ ctx[47]);
		},
		m(target, anchor) {
			insert_hydration(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			select_option(select, /*inputValue*/ ctx[50]);
			/*select_binding_1*/ ctx[82](select);
			current = true;
			if (/*autofocus*/ ctx[19]) select.focus();

			if (!mounted) {
				dispose = [
					listen(select, "focus", /*onFocus*/ ctx[54]),
					listen(select, "blur", /*onBlur*/ ctx[55]),
					listen(select, "input", /*onInput*/ ctx[53]),
					listen(select, "change", /*onChange*/ ctx[56])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[77], dirty, null),
						null
					);
				}
			}

			if (!current || dirty[0] & /*inputStyle*/ 134217728) {
				attr(select, "style", /*inputStyle*/ ctx[27]);
			}

			if (!current || dirty[0] & /*name*/ 64) {
				attr(select, "name", /*name*/ ctx[6]);
			}

			if (!current || dirty[0] & /*placeholder*/ 2048) {
				attr(select, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (!current || dirty[0] & /*inputId*/ 4096) {
				attr(select, "id", /*inputId*/ ctx[12]);
			}

			if (!current || dirty[0] & /*size*/ 8192) {
				attr(select, "size", /*size*/ ctx[13]);
			}

			if (!current || dirty[0] & /*accept*/ 16384) {
				attr(select, "accept", /*accept*/ ctx[14]);
			}

			if (!current || dirty[0] & /*autocomplete*/ 32768) {
				attr(select, "autocomplete", /*autocomplete*/ ctx[15]);
			}

			if (!current || dirty[0] & /*autocorrect*/ 65536) {
				attr(select, "autocorrect", /*autocorrect*/ ctx[16]);
			}

			if (!current || dirty[0] & /*autocapitalize*/ 131072) {
				attr(select, "autocapitalize", /*autocapitalize*/ ctx[17]);
			}

			if (!current || dirty[0] & /*spellcheck*/ 262144) {
				attr(select, "spellcheck", /*spellcheck*/ ctx[18]);
			}

			if (!current || dirty[0] & /*autofocus*/ 524288) {
				select.autofocus = /*autofocus*/ ctx[19];
			}

			if (!current || dirty[0] & /*autosave*/ 1048576) {
				attr(select, "autosave", /*autosave*/ ctx[20]);
			}

			if (!current || dirty[0] & /*disabled*/ 1024) {
				select.disabled = /*disabled*/ ctx[10];
			}

			if (!current || dirty[0] & /*max*/ 2097152) {
				attr(select, "max", /*max*/ ctx[21]);
			}

			if (!current || dirty[0] & /*maxlength*/ 16777216) {
				attr(select, "maxlength", /*maxlength*/ ctx[24]);
			}

			if (!current || dirty[0] & /*min*/ 4194304) {
				attr(select, "min", /*min*/ ctx[22]);
			}

			if (!current || dirty[0] & /*minlength*/ 33554432) {
				attr(select, "minlength", /*minlength*/ ctx[25]);
			}

			if (!current || dirty[0] & /*step*/ 8388608) {
				attr(select, "step", /*step*/ ctx[23]);
			}

			if (!current || dirty[0] & /*multiple*/ 67108864) {
				select.multiple = /*multiple*/ ctx[26];
			}

			if (!current || dirty[0] & /*readonly*/ 256) {
				attr(select, "readonly", /*readonly*/ ctx[8]);
			}

			if (!current || dirty[0] & /*required*/ 512) {
				select.required = /*required*/ ctx[9];
			}

			if (!current || dirty[0] & /*pattern*/ 268435456) {
				attr(select, "pattern", /*pattern*/ ctx[28]);
			}

			if (!current || dirty[0] & /*validate*/ 536870912 && select_validate_value !== (select_validate_value = typeof /*validate*/ ctx[29] === 'string' && /*validate*/ ctx[29].length
			? /*validate*/ ctx[29]
			: undefined)) {
				attr(select, "validate", select_validate_value);
			}

			if (!current || dirty[0] & /*validate, validateOnBlur*/ 1610612736 && select_data_validate_value !== (select_data_validate_value = /*validate*/ ctx[29] === true || /*validate*/ ctx[29] === '' || /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined)) {
				attr(select, "data-validate", select_data_validate_value);
			}

			if (!current || dirty[0] & /*validateOnBlur*/ 1073741824 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined)) {
				attr(select, "data-validate-on-blur", select_data_validate_on_blur_value);
			}

			if (!current || dirty[1] & /*tabindex*/ 1) {
				attr(select, "tabindex", /*tabindex*/ ctx[31]);
			}

			if (!current || dirty[1] & /*errorMessageForce, errorMessage*/ 24 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/ ctx[35]
			? undefined
			: /*errorMessage*/ ctx[34])) {
				attr(select, "data-error-message", select_data_error_message_value);
			}

			if (!current || dirty[1] & /*inputClasses*/ 65536) {
				attr(select, "class", /*inputClasses*/ ctx[47]);
			}

			if (!current || dirty[1] & /*inputValue*/ 524288) {
				select_option(select, /*inputValue*/ ctx[50]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(select);
			if (default_slot) default_slot.d(detaching);
			/*select_binding_1*/ ctx[82](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (758:8) {#if hasErrorMessage && errorMessageForce}
function create_if_block_15$1(ctx) {
	let div;
	let t0_value = plainText(/*errorMessage*/ ctx[34]) + "";
	let t0;
	let t1;
	let current;
	const error_message_slot_template = /*#slots*/ ctx[78]["error-message"];
	const error_message_slot = create_slot(error_message_slot_template, ctx, /*$$scope*/ ctx[77], get_error_message_slot_context_1);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (error_message_slot) error_message_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (error_message_slot) error_message_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-input-error-message");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (error_message_slot) {
				error_message_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[1] & /*errorMessage*/ 8) && t0_value !== (t0_value = plainText(/*errorMessage*/ ctx[34]) + "")) set_data(t0, t0_value);

			if (error_message_slot) {
				if (error_message_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						error_message_slot,
						error_message_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(error_message_slot_template, /*$$scope*/ ctx[77], dirty, get_error_message_slot_changes_1),
						get_error_message_slot_context_1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(error_message_slot, local);
			current = true;
		},
		o(local) {
			transition_out(error_message_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (error_message_slot) error_message_slot.d(detaching);
		}
	};
}

// (764:8) {#if clearButton}
function create_if_block_14$1(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "input-clear-button");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (765:8) {#if typeof info !== 'undefined' || hasInfoSlots}
function create_if_block_13$1(ctx) {
	let div;
	let t0_value = plainText(/*info*/ ctx[36]) + "";
	let t0;
	let t1;
	let current;
	const info_slot_template = /*#slots*/ ctx[78].info;
	const info_slot = create_slot(info_slot_template, ctx, /*$$scope*/ ctx[77], get_info_slot_context_1);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (info_slot) info_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (info_slot) info_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-input-info");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (info_slot) {
				info_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[1] & /*info*/ 32) && t0_value !== (t0_value = plainText(/*info*/ ctx[36]) + "")) set_data(t0, t0_value);

			if (info_slot) {
				if (info_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						info_slot,
						info_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(info_slot_template, /*$$scope*/ ctx[77], dirty, get_info_slot_changes_1),
						get_info_slot_context_1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(info_slot, local);
			current = true;
		},
		o(local) {
			transition_out(info_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (info_slot) info_slot.d(detaching);
		}
	};
}

// (383:6) {#if isSortable && isSortableOpposite}
function create_if_block_12$1(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "sortable-handler");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (387:6) {#if media || hasMediaSlots}
function create_if_block_10$2(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[2] !== 'undefined' && create_if_block_11$1(ctx);
	const media_slot_template = /*#slots*/ ctx[78].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[77], get_media_slot_context$2);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			if (media_slot) media_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-media");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (typeof /*media*/ ctx[2] !== 'undefined') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_11$1(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						media_slot,
						media_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[77], dirty, get_media_slot_changes$2),
						get_media_slot_context$2
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};
}

// (389:10) {#if typeof media !== 'undefined'}
function create_if_block_11$1(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			this.h();
		},
		l(nodes) {
			img = claim_element(nodes, "IMG", { src: true });
			this.h();
		},
		h() {
			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[2])) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert_hydration(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*media*/ 4 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[2])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (395:8) {#if typeof label !== 'undefined' || hasLabelSlots}
function create_if_block_9$2(ctx) {
	let div;
	let t0_value = plainText(/*label*/ ctx[37]) + "";
	let t0;
	let t1;
	let current;
	const label_slot_template = /*#slots*/ ctx[78].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[77], get_label_slot_context$1);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (label_slot) label_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (label_slot) label_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", /*labelClasses*/ ctx[45]);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (label_slot) {
				label_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[1] & /*label*/ 64) && t0_value !== (t0_value = plainText(/*label*/ ctx[37]) + "")) set_data(t0, t0_value);

			if (label_slot) {
				if (label_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						label_slot,
						label_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[77], dirty, get_label_slot_changes$1),
						get_label_slot_context$1
					);
				}
			}

			if (!current || dirty[1] & /*labelClasses*/ 16384) {
				attr(div, "class", /*labelClasses*/ ctx[45]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(label_slot, local);
			current = true;
		},
		o(local) {
			transition_out(label_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (label_slot) label_slot.d(detaching);
		}
	};
}

// (402:10) {#if input}
function create_if_block_5$3(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_6$2, create_if_block_7$2, create_if_block_8$2, create_else_block$b];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*type*/ ctx[5] === 'select') return 0;
		if (/*type*/ ctx[5] === 'textarea') return 1;
		if (/*type*/ ctx[5] === 'texteditor') return 2;
		return 3;
	}

	current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (505:12) {:else}
function create_else_block$b(ctx) {
	let input_1;
	let input_1_validate_value;
	let input_1_data_validate_value;
	let input_1_data_validate_on_blur_value;
	let input_1_data_error_message_value;
	let input_1_value_value;
	let mounted;
	let dispose;

	return {
		c() {
			input_1 = element("input");
			this.h();
		},
		l(nodes) {
			input_1 = claim_element(nodes, "INPUT", {
				style: true,
				name: true,
				type: true,
				inputmode: true,
				placeholder: true,
				id: true,
				size: true,
				accept: true,
				autocomplete: true,
				autocorrect: true,
				autocapitalize: true,
				spellcheck: true,
				autosave: true,
				max: true,
				maxlength: true,
				min: true,
				minlength: true,
				step: true,
				pattern: true,
				validate: true,
				"data-validate": true,
				"data-validate-on-blur": true,
				tabindex: true,
				"data-error-message": true,
				class: true
			});

			this.h();
		},
		h() {
			attr(input_1, "style", /*inputStyle*/ ctx[27]);
			attr(input_1, "name", /*name*/ ctx[6]);
			attr(input_1, "type", /*inputType*/ ctx[41]);
			attr(input_1, "inputmode", /*inputmode*/ ctx[7]);
			attr(input_1, "placeholder", /*placeholder*/ ctx[11]);
			attr(input_1, "id", /*inputId*/ ctx[12]);
			attr(input_1, "size", /*size*/ ctx[13]);
			attr(input_1, "accept", /*accept*/ ctx[14]);
			attr(input_1, "autocomplete", /*autocomplete*/ ctx[15]);
			attr(input_1, "autocorrect", /*autocorrect*/ ctx[16]);
			attr(input_1, "autocapitalize", /*autocapitalize*/ ctx[17]);
			attr(input_1, "spellcheck", /*spellcheck*/ ctx[18]);
			input_1.autofocus = /*autofocus*/ ctx[19];
			attr(input_1, "autosave", /*autosave*/ ctx[20]);
			input_1.disabled = /*disabled*/ ctx[10];
			attr(input_1, "max", /*max*/ ctx[21]);
			attr(input_1, "maxlength", /*maxlength*/ ctx[24]);
			attr(input_1, "min", /*min*/ ctx[22]);
			attr(input_1, "minlength", /*minlength*/ ctx[25]);
			attr(input_1, "step", /*step*/ ctx[23]);
			input_1.multiple = /*multiple*/ ctx[26];
			input_1.readOnly = /*readonly*/ ctx[8];
			input_1.required = /*required*/ ctx[9];
			attr(input_1, "pattern", /*pattern*/ ctx[28]);

			attr(input_1, "validate", input_1_validate_value = typeof /*validate*/ ctx[29] === 'string' && /*validate*/ ctx[29].length
			? /*validate*/ ctx[29]
			: undefined);

			attr(input_1, "data-validate", input_1_data_validate_value = /*validate*/ ctx[29] === true || /*validate*/ ctx[29] === '' || /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined);

			attr(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined);

			attr(input_1, "tabindex", /*tabindex*/ ctx[31]);

			attr(input_1, "data-error-message", input_1_data_error_message_value = /*errorMessageForce*/ ctx[35]
			? undefined
			: /*errorMessage*/ ctx[34]);

			attr(input_1, "class", /*inputClasses*/ ctx[47]);

			input_1.value = input_1_value_value = /*type*/ ctx[5] === 'datepicker' || /*type*/ ctx[5] === 'colorpicker' || /*type*/ ctx[5] === 'file'
			? ''
			: /*inputValue*/ ctx[50];
		},
		m(target, anchor) {
			insert_hydration(target, input_1, anchor);
			/*input_1_binding*/ ctx[81](input_1);
			if (/*autofocus*/ ctx[19]) input_1.focus();

			if (!mounted) {
				dispose = [
					listen(input_1, "focus", /*onFocus*/ ctx[54]),
					listen(input_1, "blur", /*onBlur*/ ctx[55]),
					listen(input_1, "input", /*onInput*/ ctx[53]),
					listen(input_1, "change", /*onChange*/ ctx[56])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 134217728) {
				attr(input_1, "style", /*inputStyle*/ ctx[27]);
			}

			if (dirty[0] & /*name*/ 64) {
				attr(input_1, "name", /*name*/ ctx[6]);
			}

			if (dirty[1] & /*inputType*/ 1024) {
				attr(input_1, "type", /*inputType*/ ctx[41]);
			}

			if (dirty[0] & /*inputmode*/ 128) {
				attr(input_1, "inputmode", /*inputmode*/ ctx[7]);
			}

			if (dirty[0] & /*placeholder*/ 2048) {
				attr(input_1, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (dirty[0] & /*inputId*/ 4096) {
				attr(input_1, "id", /*inputId*/ ctx[12]);
			}

			if (dirty[0] & /*size*/ 8192) {
				attr(input_1, "size", /*size*/ ctx[13]);
			}

			if (dirty[0] & /*accept*/ 16384) {
				attr(input_1, "accept", /*accept*/ ctx[14]);
			}

			if (dirty[0] & /*autocomplete*/ 32768) {
				attr(input_1, "autocomplete", /*autocomplete*/ ctx[15]);
			}

			if (dirty[0] & /*autocorrect*/ 65536) {
				attr(input_1, "autocorrect", /*autocorrect*/ ctx[16]);
			}

			if (dirty[0] & /*autocapitalize*/ 131072) {
				attr(input_1, "autocapitalize", /*autocapitalize*/ ctx[17]);
			}

			if (dirty[0] & /*spellcheck*/ 262144) {
				attr(input_1, "spellcheck", /*spellcheck*/ ctx[18]);
			}

			if (dirty[0] & /*autofocus*/ 524288) {
				input_1.autofocus = /*autofocus*/ ctx[19];
			}

			if (dirty[0] & /*autosave*/ 1048576) {
				attr(input_1, "autosave", /*autosave*/ ctx[20]);
			}

			if (dirty[0] & /*disabled*/ 1024) {
				input_1.disabled = /*disabled*/ ctx[10];
			}

			if (dirty[0] & /*max*/ 2097152) {
				attr(input_1, "max", /*max*/ ctx[21]);
			}

			if (dirty[0] & /*maxlength*/ 16777216) {
				attr(input_1, "maxlength", /*maxlength*/ ctx[24]);
			}

			if (dirty[0] & /*min*/ 4194304) {
				attr(input_1, "min", /*min*/ ctx[22]);
			}

			if (dirty[0] & /*minlength*/ 33554432) {
				attr(input_1, "minlength", /*minlength*/ ctx[25]);
			}

			if (dirty[0] & /*step*/ 8388608) {
				attr(input_1, "step", /*step*/ ctx[23]);
			}

			if (dirty[0] & /*multiple*/ 67108864) {
				input_1.multiple = /*multiple*/ ctx[26];
			}

			if (dirty[0] & /*readonly*/ 256) {
				input_1.readOnly = /*readonly*/ ctx[8];
			}

			if (dirty[0] & /*required*/ 512) {
				input_1.required = /*required*/ ctx[9];
			}

			if (dirty[0] & /*pattern*/ 268435456) {
				attr(input_1, "pattern", /*pattern*/ ctx[28]);
			}

			if (dirty[0] & /*validate*/ 536870912 && input_1_validate_value !== (input_1_validate_value = typeof /*validate*/ ctx[29] === 'string' && /*validate*/ ctx[29].length
			? /*validate*/ ctx[29]
			: undefined)) {
				attr(input_1, "validate", input_1_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 1610612736 && input_1_data_validate_value !== (input_1_data_validate_value = /*validate*/ ctx[29] === true || /*validate*/ ctx[29] === '' || /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined)) {
				attr(input_1, "data-validate", input_1_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 1073741824 && input_1_data_validate_on_blur_value !== (input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined)) {
				attr(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value);
			}

			if (dirty[1] & /*tabindex*/ 1) {
				attr(input_1, "tabindex", /*tabindex*/ ctx[31]);
			}

			if (dirty[1] & /*errorMessageForce, errorMessage*/ 24 && input_1_data_error_message_value !== (input_1_data_error_message_value = /*errorMessageForce*/ ctx[35]
			? undefined
			: /*errorMessage*/ ctx[34])) {
				attr(input_1, "data-error-message", input_1_data_error_message_value);
			}

			if (dirty[1] & /*inputClasses*/ 65536) {
				attr(input_1, "class", /*inputClasses*/ ctx[47]);
			}

			if (dirty[0] & /*type*/ 32 | dirty[1] & /*inputValue*/ 524288 && input_1_value_value !== (input_1_value_value = /*type*/ ctx[5] === 'datepicker' || /*type*/ ctx[5] === 'colorpicker' || /*type*/ ctx[5] === 'file'
			? ''
			: /*inputValue*/ ctx[50]) && input_1.value !== input_1_value_value) {
				input_1.value = input_1_value_value;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(input_1);
			/*input_1_binding*/ ctx[81](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (494:44) 
function create_if_block_8$2(ctx) {
	let texteditor;
	let current;

	const texteditor_spread_levels = [
		{
			value: typeof /*value*/ ctx[0] === 'undefined'
			? ''
			: /*value*/ ctx[0]
		},
		{ resizable: /*resizable*/ ctx[32] },
		{ placeholder: /*placeholder*/ ctx[11] },
		{ onTextEditorFocus: /*onFocus*/ ctx[54] },
		{ onTextEditorBlur: /*onBlur*/ ctx[55] },
		{ onTextEditorInput: /*onInput*/ ctx[53] },
		{ onTextEditorChange: /*onChange*/ ctx[56] },
		/*textEditorParams*/ ctx[38],
		{ lec: /*lec*/ ctx[1] }
	];

	let texteditor_props = {};

	for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
		texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
	}

	texteditor = new Text_editor({ props: texteditor_props });

	return {
		c() {
			create_component(texteditor.$$.fragment);
		},
		l(nodes) {
			claim_component(texteditor.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(texteditor, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const texteditor_changes = (dirty[0] & /*value, placeholder, lec*/ 2051 | dirty[1] & /*resizable, onFocus, onBlur, onInput, onChange, textEditorParams*/ 62914690)
			? get_spread_update(texteditor_spread_levels, [
					dirty[0] & /*value*/ 1 && {
						value: typeof /*value*/ ctx[0] === 'undefined'
						? ''
						: /*value*/ ctx[0]
					},
					dirty[1] & /*resizable*/ 2 && { resizable: /*resizable*/ ctx[32] },
					dirty[0] & /*placeholder*/ 2048 && { placeholder: /*placeholder*/ ctx[11] },
					dirty[1] & /*onFocus*/ 8388608 && { onTextEditorFocus: /*onFocus*/ ctx[54] },
					dirty[1] & /*onBlur*/ 16777216 && { onTextEditorBlur: /*onBlur*/ ctx[55] },
					dirty[1] & /*onInput*/ 4194304 && { onTextEditorInput: /*onInput*/ ctx[53] },
					dirty[1] & /*onChange*/ 33554432 && { onTextEditorChange: /*onChange*/ ctx[56] },
					dirty[1] & /*textEditorParams*/ 128 && get_spread_object(/*textEditorParams*/ ctx[38]),
					dirty[0] & /*lec*/ 2 && { lec: /*lec*/ ctx[1] }
				])
			: {};

			texteditor.$set(texteditor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(texteditor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(texteditor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(texteditor, detaching);
		}
	};
}

// (449:42) 
function create_if_block_7$2(ctx) {
	let textarea;
	let textarea_validate_value;
	let textarea_data_validate_value;
	let textarea_data_validate_on_blur_value;
	let textarea_data_error_message_value;
	let mounted;
	let dispose;

	return {
		c() {
			textarea = element("textarea");
			this.h();
		},
		l(nodes) {
			textarea = claim_element(nodes, "TEXTAREA", {
				style: true,
				name: true,
				placeholder: true,
				id: true,
				size: true,
				inputmode: true,
				accept: true,
				autocomplete: true,
				autocorrect: true,
				autocapitalize: true,
				spellcheck: true,
				autosave: true,
				max: true,
				maxlength: true,
				min: true,
				minlength: true,
				step: true,
				multiple: true,
				pattern: true,
				validate: true,
				"data-validate": true,
				"data-validate-on-blur": true,
				tabindex: true,
				"data-error-message": true,
				class: true
			});

			children(textarea).forEach(detach);
			this.h();
		},
		h() {
			attr(textarea, "style", /*inputStyle*/ ctx[27]);
			attr(textarea, "name", /*name*/ ctx[6]);
			attr(textarea, "placeholder", /*placeholder*/ ctx[11]);
			attr(textarea, "id", /*inputId*/ ctx[12]);
			attr(textarea, "size", /*size*/ ctx[13]);
			attr(textarea, "inputmode", /*inputmode*/ ctx[7]);
			attr(textarea, "accept", /*accept*/ ctx[14]);
			attr(textarea, "autocomplete", /*autocomplete*/ ctx[15]);
			attr(textarea, "autocorrect", /*autocorrect*/ ctx[16]);
			attr(textarea, "autocapitalize", /*autocapitalize*/ ctx[17]);
			attr(textarea, "spellcheck", /*spellcheck*/ ctx[18]);
			textarea.autofocus = /*autofocus*/ ctx[19];
			attr(textarea, "autosave", /*autosave*/ ctx[20]);
			textarea.disabled = /*disabled*/ ctx[10];
			attr(textarea, "max", /*max*/ ctx[21]);
			attr(textarea, "maxlength", /*maxlength*/ ctx[24]);
			attr(textarea, "min", /*min*/ ctx[22]);
			attr(textarea, "minlength", /*minlength*/ ctx[25]);
			attr(textarea, "step", /*step*/ ctx[23]);
			attr(textarea, "multiple", /*multiple*/ ctx[26]);
			textarea.readOnly = /*readonly*/ ctx[8];
			textarea.required = /*required*/ ctx[9];
			attr(textarea, "pattern", /*pattern*/ ctx[28]);

			attr(textarea, "validate", textarea_validate_value = typeof /*validate*/ ctx[29] === 'string' && /*validate*/ ctx[29].length
			? /*validate*/ ctx[29]
			: undefined);

			attr(textarea, "data-validate", textarea_data_validate_value = /*validate*/ ctx[29] === true || /*validate*/ ctx[29] === '' || /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined);

			attr(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined);

			attr(textarea, "tabindex", /*tabindex*/ ctx[31]);

			attr(textarea, "data-error-message", textarea_data_error_message_value = /*errorMessageForce*/ ctx[35]
			? undefined
			: /*errorMessage*/ ctx[34]);

			attr(textarea, "class", /*inputClasses*/ ctx[47]);
			textarea.value = /*inputValue*/ ctx[50];
		},
		m(target, anchor) {
			insert_hydration(target, textarea, anchor);
			/*textarea_binding*/ ctx[80](textarea);
			if (/*autofocus*/ ctx[19]) textarea.focus();

			if (!mounted) {
				dispose = [
					listen(textarea, "focus", /*onFocus*/ ctx[54]),
					listen(textarea, "blur", /*onBlur*/ ctx[55]),
					listen(textarea, "input", /*onInput*/ ctx[53]),
					listen(textarea, "change", /*onChange*/ ctx[56])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 134217728) {
				attr(textarea, "style", /*inputStyle*/ ctx[27]);
			}

			if (dirty[0] & /*name*/ 64) {
				attr(textarea, "name", /*name*/ ctx[6]);
			}

			if (dirty[0] & /*placeholder*/ 2048) {
				attr(textarea, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (dirty[0] & /*inputId*/ 4096) {
				attr(textarea, "id", /*inputId*/ ctx[12]);
			}

			if (dirty[0] & /*size*/ 8192) {
				attr(textarea, "size", /*size*/ ctx[13]);
			}

			if (dirty[0] & /*inputmode*/ 128) {
				attr(textarea, "inputmode", /*inputmode*/ ctx[7]);
			}

			if (dirty[0] & /*accept*/ 16384) {
				attr(textarea, "accept", /*accept*/ ctx[14]);
			}

			if (dirty[0] & /*autocomplete*/ 32768) {
				attr(textarea, "autocomplete", /*autocomplete*/ ctx[15]);
			}

			if (dirty[0] & /*autocorrect*/ 65536) {
				attr(textarea, "autocorrect", /*autocorrect*/ ctx[16]);
			}

			if (dirty[0] & /*autocapitalize*/ 131072) {
				attr(textarea, "autocapitalize", /*autocapitalize*/ ctx[17]);
			}

			if (dirty[0] & /*spellcheck*/ 262144) {
				attr(textarea, "spellcheck", /*spellcheck*/ ctx[18]);
			}

			if (dirty[0] & /*autofocus*/ 524288) {
				textarea.autofocus = /*autofocus*/ ctx[19];
			}

			if (dirty[0] & /*autosave*/ 1048576) {
				attr(textarea, "autosave", /*autosave*/ ctx[20]);
			}

			if (dirty[0] & /*disabled*/ 1024) {
				textarea.disabled = /*disabled*/ ctx[10];
			}

			if (dirty[0] & /*max*/ 2097152) {
				attr(textarea, "max", /*max*/ ctx[21]);
			}

			if (dirty[0] & /*maxlength*/ 16777216) {
				attr(textarea, "maxlength", /*maxlength*/ ctx[24]);
			}

			if (dirty[0] & /*min*/ 4194304) {
				attr(textarea, "min", /*min*/ ctx[22]);
			}

			if (dirty[0] & /*minlength*/ 33554432) {
				attr(textarea, "minlength", /*minlength*/ ctx[25]);
			}

			if (dirty[0] & /*step*/ 8388608) {
				attr(textarea, "step", /*step*/ ctx[23]);
			}

			if (dirty[0] & /*multiple*/ 67108864) {
				attr(textarea, "multiple", /*multiple*/ ctx[26]);
			}

			if (dirty[0] & /*readonly*/ 256) {
				textarea.readOnly = /*readonly*/ ctx[8];
			}

			if (dirty[0] & /*required*/ 512) {
				textarea.required = /*required*/ ctx[9];
			}

			if (dirty[0] & /*pattern*/ 268435456) {
				attr(textarea, "pattern", /*pattern*/ ctx[28]);
			}

			if (dirty[0] & /*validate*/ 536870912 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/ ctx[29] === 'string' && /*validate*/ ctx[29].length
			? /*validate*/ ctx[29]
			: undefined)) {
				attr(textarea, "validate", textarea_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 1610612736 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/ ctx[29] === true || /*validate*/ ctx[29] === '' || /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined)) {
				attr(textarea, "data-validate", textarea_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 1073741824 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined)) {
				attr(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value);
			}

			if (dirty[1] & /*tabindex*/ 1) {
				attr(textarea, "tabindex", /*tabindex*/ ctx[31]);
			}

			if (dirty[1] & /*errorMessageForce, errorMessage*/ 24 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/ ctx[35]
			? undefined
			: /*errorMessage*/ ctx[34])) {
				attr(textarea, "data-error-message", textarea_data_error_message_value);
			}

			if (dirty[1] & /*inputClasses*/ 65536) {
				attr(textarea, "class", /*inputClasses*/ ctx[47]);
			}

			if (dirty[1] & /*inputValue*/ 524288) {
				textarea.value = /*inputValue*/ ctx[50];
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(textarea);
			/*textarea_binding*/ ctx[80](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (403:12) {#if type === 'select'}
function create_if_block_6$2(ctx) {
	let select;
	let select_validate_value;
	let select_data_validate_value;
	let select_data_validate_on_blur_value;
	let select_data_error_message_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[78].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[77], null);

	return {
		c() {
			select = element("select");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			select = claim_element(nodes, "SELECT", {
				style: true,
				name: true,
				placeholder: true,
				id: true,
				size: true,
				accept: true,
				autocomplete: true,
				autocorrect: true,
				autocapitalize: true,
				spellcheck: true,
				autosave: true,
				max: true,
				maxlength: true,
				min: true,
				minlength: true,
				step: true,
				readonly: true,
				pattern: true,
				validate: true,
				"data-validate": true,
				"data-validate-on-blur": true,
				tabindex: true,
				"data-error-message": true,
				class: true
			});

			var select_nodes = children(select);
			if (default_slot) default_slot.l(select_nodes);
			select_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(select, "style", /*inputStyle*/ ctx[27]);
			attr(select, "name", /*name*/ ctx[6]);
			attr(select, "placeholder", /*placeholder*/ ctx[11]);
			attr(select, "id", /*inputId*/ ctx[12]);
			attr(select, "size", /*size*/ ctx[13]);
			attr(select, "accept", /*accept*/ ctx[14]);
			attr(select, "autocomplete", /*autocomplete*/ ctx[15]);
			attr(select, "autocorrect", /*autocorrect*/ ctx[16]);
			attr(select, "autocapitalize", /*autocapitalize*/ ctx[17]);
			attr(select, "spellcheck", /*spellcheck*/ ctx[18]);
			select.autofocus = /*autofocus*/ ctx[19];
			attr(select, "autosave", /*autosave*/ ctx[20]);
			select.disabled = /*disabled*/ ctx[10];
			attr(select, "max", /*max*/ ctx[21]);
			attr(select, "maxlength", /*maxlength*/ ctx[24]);
			attr(select, "min", /*min*/ ctx[22]);
			attr(select, "minlength", /*minlength*/ ctx[25]);
			attr(select, "step", /*step*/ ctx[23]);
			select.multiple = /*multiple*/ ctx[26];
			attr(select, "readonly", /*readonly*/ ctx[8]);
			select.required = /*required*/ ctx[9];
			attr(select, "pattern", /*pattern*/ ctx[28]);

			attr(select, "validate", select_validate_value = typeof /*validate*/ ctx[29] === 'string' && /*validate*/ ctx[29].length
			? /*validate*/ ctx[29]
			: undefined);

			attr(select, "data-validate", select_data_validate_value = /*validate*/ ctx[29] === true || /*validate*/ ctx[29] === '' || /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined);

			attr(select, "data-validate-on-blur", select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined);

			attr(select, "tabindex", /*tabindex*/ ctx[31]);

			attr(select, "data-error-message", select_data_error_message_value = /*errorMessageForce*/ ctx[35]
			? undefined
			: /*errorMessage*/ ctx[34]);

			attr(select, "class", /*inputClasses*/ ctx[47]);
		},
		m(target, anchor) {
			insert_hydration(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			select_option(select, /*inputValue*/ ctx[50]);
			/*select_binding*/ ctx[79](select);
			current = true;
			if (/*autofocus*/ ctx[19]) select.focus();

			if (!mounted) {
				dispose = [
					listen(select, "focus", /*onFocus*/ ctx[54]),
					listen(select, "blur", /*onBlur*/ ctx[55]),
					listen(select, "input", /*onInput*/ ctx[53]),
					listen(select, "change", /*onChange*/ ctx[56])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[77], dirty, null),
						null
					);
				}
			}

			if (!current || dirty[0] & /*inputStyle*/ 134217728) {
				attr(select, "style", /*inputStyle*/ ctx[27]);
			}

			if (!current || dirty[0] & /*name*/ 64) {
				attr(select, "name", /*name*/ ctx[6]);
			}

			if (!current || dirty[0] & /*placeholder*/ 2048) {
				attr(select, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (!current || dirty[0] & /*inputId*/ 4096) {
				attr(select, "id", /*inputId*/ ctx[12]);
			}

			if (!current || dirty[0] & /*size*/ 8192) {
				attr(select, "size", /*size*/ ctx[13]);
			}

			if (!current || dirty[0] & /*accept*/ 16384) {
				attr(select, "accept", /*accept*/ ctx[14]);
			}

			if (!current || dirty[0] & /*autocomplete*/ 32768) {
				attr(select, "autocomplete", /*autocomplete*/ ctx[15]);
			}

			if (!current || dirty[0] & /*autocorrect*/ 65536) {
				attr(select, "autocorrect", /*autocorrect*/ ctx[16]);
			}

			if (!current || dirty[0] & /*autocapitalize*/ 131072) {
				attr(select, "autocapitalize", /*autocapitalize*/ ctx[17]);
			}

			if (!current || dirty[0] & /*spellcheck*/ 262144) {
				attr(select, "spellcheck", /*spellcheck*/ ctx[18]);
			}

			if (!current || dirty[0] & /*autofocus*/ 524288) {
				select.autofocus = /*autofocus*/ ctx[19];
			}

			if (!current || dirty[0] & /*autosave*/ 1048576) {
				attr(select, "autosave", /*autosave*/ ctx[20]);
			}

			if (!current || dirty[0] & /*disabled*/ 1024) {
				select.disabled = /*disabled*/ ctx[10];
			}

			if (!current || dirty[0] & /*max*/ 2097152) {
				attr(select, "max", /*max*/ ctx[21]);
			}

			if (!current || dirty[0] & /*maxlength*/ 16777216) {
				attr(select, "maxlength", /*maxlength*/ ctx[24]);
			}

			if (!current || dirty[0] & /*min*/ 4194304) {
				attr(select, "min", /*min*/ ctx[22]);
			}

			if (!current || dirty[0] & /*minlength*/ 33554432) {
				attr(select, "minlength", /*minlength*/ ctx[25]);
			}

			if (!current || dirty[0] & /*step*/ 8388608) {
				attr(select, "step", /*step*/ ctx[23]);
			}

			if (!current || dirty[0] & /*multiple*/ 67108864) {
				select.multiple = /*multiple*/ ctx[26];
			}

			if (!current || dirty[0] & /*readonly*/ 256) {
				attr(select, "readonly", /*readonly*/ ctx[8]);
			}

			if (!current || dirty[0] & /*required*/ 512) {
				select.required = /*required*/ ctx[9];
			}

			if (!current || dirty[0] & /*pattern*/ 268435456) {
				attr(select, "pattern", /*pattern*/ ctx[28]);
			}

			if (!current || dirty[0] & /*validate*/ 536870912 && select_validate_value !== (select_validate_value = typeof /*validate*/ ctx[29] === 'string' && /*validate*/ ctx[29].length
			? /*validate*/ ctx[29]
			: undefined)) {
				attr(select, "validate", select_validate_value);
			}

			if (!current || dirty[0] & /*validate, validateOnBlur*/ 1610612736 && select_data_validate_value !== (select_data_validate_value = /*validate*/ ctx[29] === true || /*validate*/ ctx[29] === '' || /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined)) {
				attr(select, "data-validate", select_data_validate_value);
			}

			if (!current || dirty[0] & /*validateOnBlur*/ 1073741824 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[30] === true || /*validateOnBlur*/ ctx[30] === ''
			? true
			: undefined)) {
				attr(select, "data-validate-on-blur", select_data_validate_on_blur_value);
			}

			if (!current || dirty[1] & /*tabindex*/ 1) {
				attr(select, "tabindex", /*tabindex*/ ctx[31]);
			}

			if (!current || dirty[1] & /*errorMessageForce, errorMessage*/ 24 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/ ctx[35]
			? undefined
			: /*errorMessage*/ ctx[34])) {
				attr(select, "data-error-message", select_data_error_message_value);
			}

			if (!current || dirty[1] & /*inputClasses*/ 65536) {
				attr(select, "class", /*inputClasses*/ ctx[47]);
			}

			if (!current || dirty[1] & /*inputValue*/ 524288) {
				select_option(select, /*inputValue*/ ctx[50]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(select);
			if (default_slot) default_slot.d(detaching);
			/*select_binding*/ ctx[79](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (556:10) {#if hasErrorMessage && errorMessageForce}
function create_if_block_4$5(ctx) {
	let div;
	let t0_value = plainText(/*errorMessage*/ ctx[34]) + "";
	let t0;
	let t1;
	let current;
	const error_message_slot_template = /*#slots*/ ctx[78]["error-message"];
	const error_message_slot = create_slot(error_message_slot_template, ctx, /*$$scope*/ ctx[77], get_error_message_slot_context);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (error_message_slot) error_message_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (error_message_slot) error_message_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-input-error-message");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (error_message_slot) {
				error_message_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[1] & /*errorMessage*/ 8) && t0_value !== (t0_value = plainText(/*errorMessage*/ ctx[34]) + "")) set_data(t0, t0_value);

			if (error_message_slot) {
				if (error_message_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						error_message_slot,
						error_message_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(error_message_slot_template, /*$$scope*/ ctx[77], dirty, get_error_message_slot_changes),
						get_error_message_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(error_message_slot, local);
			current = true;
		},
		o(local) {
			transition_out(error_message_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (error_message_slot) error_message_slot.d(detaching);
		}
	};
}

// (562:10) {#if clearButton}
function create_if_block_3$9(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "input-clear-button");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (563:10) {#if typeof info !== 'undefined' || hasInfoSlots}
function create_if_block_2$a(ctx) {
	let div;
	let t0_value = plainText(/*info*/ ctx[36]) + "";
	let t0;
	let t1;
	let current;
	const info_slot_template = /*#slots*/ ctx[78].info;
	const info_slot = create_slot(info_slot_template, ctx, /*$$scope*/ ctx[77], get_info_slot_context);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (info_slot) info_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (info_slot) info_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-input-info");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (info_slot) {
				info_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[1] & /*info*/ 32) && t0_value !== (t0_value = plainText(/*info*/ ctx[36]) + "")) set_data(t0, t0_value);

			if (info_slot) {
				if (info_slot.p && (!current || dirty[2] & /*$$scope*/ 32768)) {
					update_slot_base(
						info_slot,
						info_slot_template,
						ctx,
						/*$$scope*/ ctx[77],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[77])
						: get_slot_changes(info_slot_template, /*$$scope*/ ctx[77], dirty, get_info_slot_changes),
						get_info_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(info_slot, local);
			current = true;
		},
		o(local) {
			transition_out(info_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (info_slot) info_slot.d(detaching);
		}
	};
}

// (576:4) {#if isSortable && !isSortableOpposite}
function create_if_block_1$f(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "sortable-handler");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$M(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$o, create_else_block_1$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*wrap*/ ctx[3]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, [-1, -1, -1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

let index$O = 0;

function instance$I($$self, $$props, $$invalidate) {
	let isSortable;
	let isSortableOpposite;
	let inputType;
	let needsValue;
	let inputValue;
	let hasInfoSlots;
	let hasErrorSlots;
	let hasMediaSlots;
	let hasLabelSlots;
	let hasErrorMessage;
	let inputClasses;
	let itemContentClasses;
	let labelClasses;
	let inputWrapClasses;
	let classes;

	const omit_props_names = [
		"lec","class","sortable","sortableOpposite","media","dropdown","wrap","input","type","name","value","inputmode","readonly","required","disabled","placeholder","inputId","size","accept","autocomplete","autocorrect","autocapitalize","spellcheck","autofocus","autosave","max","min","step","maxlength","minlength","multiple","inputStyle","pattern","validate","validateOnBlur","onValidate","tabindex","resizable","clearButton","noFormStoreData","noStoreData","ignoreStoreData","errorMessage","errorMessageForce","info","outline","label","inlineLabel","floatingLabel","calendarParams","colorPickerParams","textEditorParams","calendarInstance","colorPickerInstance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { sortable = undefined } = $$props;
	let { sortableOpposite = undefined } = $$props;
	let { media = undefined } = $$props;
	let { dropdown = 'auto' } = $$props;
	let { wrap = true } = $$props;
	let { input = true } = $$props;
	let { type = 'text' } = $$props;
	let { name = undefined } = $$props;
	let { value = undefined } = $$props;
	let { inputmode = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let { required = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { placeholder = undefined } = $$props;
	let { inputId = undefined } = $$props;
	let { size = undefined } = $$props;
	let { accept = undefined } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { autofocus = undefined } = $$props;
	let { autosave = undefined } = $$props;
	let { max = undefined } = $$props;
	let { min = undefined } = $$props;
	let { step = undefined } = $$props;
	let { maxlength = undefined } = $$props;
	let { minlength = undefined } = $$props;
	let { multiple = undefined } = $$props;
	let { inputStyle = undefined } = $$props;
	let { pattern = undefined } = $$props;
	let { validate = undefined } = $$props;
	let { validateOnBlur = undefined } = $$props;
	let { onValidate = undefined } = $$props;
	let { tabindex = undefined } = $$props;
	let { resizable = undefined } = $$props;
	let { clearButton = undefined } = $$props;
	let { noFormStoreData = undefined } = $$props;
	let { noStoreData = undefined } = $$props;
	let { ignoreStoreData = undefined } = $$props;
	let { errorMessage = undefined } = $$props;
	let { errorMessageForce = undefined } = $$props;
	let { info = undefined } = $$props;
	let { outline = undefined } = $$props;
	let { label = undefined } = $$props;
	let { inlineLabel = undefined } = $$props;
	let { floatingLabel = undefined } = $$props;
	let { calendarParams = undefined } = $$props;
	let { colorPickerParams = undefined } = $$props;
	let { textEditorParams = undefined } = $$props;

	// State
	let inputEl;

	let inputFocused = false;
	let inputInvalid = false;
	let updateInputOnDidUpdate = false;
	let f7Calendar;
	let f7ColorPicker;

	function calendarInstance() {
		return f7Calendar;
	}

	function colorPickerInstance() {
		return f7ColorPicker;
	}

	let ListContext = getReactiveContext('ListContext', newValue => {
		$$invalidate(75, ListContext = newValue || {});
	}) || {};

	function domValue() {
		if (!inputEl) return undefined;
		return inputEl.value;
	}

	function inputHasValue() {
		if (type === 'datepicker' && Array.isArray(value) && value.length === 0) {
			return false;
		}

		const domV = domValue();

		return typeof value === 'undefined'
		? domV || domV === 0
		: value || value === 0;
	}

	function validateInput() {
		if (!app.f7 || !inputEl) return;
		const validity = inputEl.validity;
		if (!validity) return;

		if (!validity.valid) {
			if (onValidate) onValidate(false);

			if (inputInvalid !== true) {
				$$invalidate(74, inputInvalid = true);
			}
		} else {
			if (onValidate) onValidate(true);

			if (inputInvalid !== false) {
				$$invalidate(74, inputInvalid = false);
			}
		}
	}

	let initialWatched = false;

	function watchValue() {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (type === 'range' || type === 'toggle') return;
		if (!app.f7) return;
		updateInputOnDidUpdate = true;

		if (f7Calendar) {
			f7Calendar.setValue(value);
		}

		if (f7ColorPicker) {
			f7ColorPicker.setValue(value);
		}
	}

	function watchColorPickerParams() {
		if (!app.f7 || !f7ColorPicker) return;
		extend(f7ColorPicker.params, colorPickerParams || {});
	}

	function watchCalendarParams() {
		if (!app.f7 || !f7Calendar) return;
		extend(f7Calendar.params, calendarParams || {});
	}

	function onTextareaResize(event) {
		emit('textareaResize', [event]);
	}

	function onInputNotEmpty(event) {
		emit('inputNotEmpty', [event]);
	}

	function onInputEmpty(event) {
		emit('inputEmpty', [event]);
	}

	function onInputClear(event) {
		emit('inputClear', [event]);
	}

	function onInput(...args) {
		emit('input', [...args]);

		if (!(validateOnBlur || validateOnBlur === '') && (validate || validate === '') && inputEl) {
			validateInput(inputEl);
		}

		if (inputEl && type !== 'texteditor' && type !== 'colorpicker' && type !== 'datepicker') {
			$$invalidate(0, value = inputEl.value);
		}
	}

	function onFocus(...args) {
		emit('focus', [...args]);
		$$invalidate(73, inputFocused = true);
	}

	function onBlur(...args) {
		emit('blur', [...args]);

		if ((validate || validate === '' || validateOnBlur || validateOnBlur === '') && inputEl) {
			validateInput();
		}

		$$invalidate(73, inputFocused = false);
	}

	function onChange(...args) {
		emit('change', [...args]);

		if (type === 'texteditor') {
			emit('textEditorChange', [args[0]]);
			$$invalidate(0, value = args[0]);
		}
	}

	onMount(() => {
		f7ready(() => {
			if (type === 'range' || type === 'toggle') return;
			if (!inputEl) return;
			inputEl.addEventListener('input:notempty', onInputNotEmpty, false);

			if (type === 'textarea' && resizable) {
				inputEl.addEventListener('textarea:resize', onTextareaResize, false);
			}

			if (clearButton) {
				inputEl.addEventListener('input:empty', onInputEmpty, false);
				inputEl.addEventListener('input:clear', onInputClear, false);
			}

			if (type === 'datepicker') {
				f7Calendar = app.f7.calendar.create({
					inputEl,
					value,
					on: {
						change(calendar, calendarValue) {
							emit('calendarChange', [calendarValue]);
							$$invalidate(0, value = calendarValue);
						}
					},
					...calendarParams || {}
				});
			}

			if (type === 'colorpicker') {
				f7ColorPicker = app.f7.colorPicker.create({
					inputEl,
					value,
					on: {
						change(colorPicker, colorPickerValue) {
							emit('colorPickerChange', [colorPickerValue]);
							$$invalidate(0, value = colorPickerValue);
						}
					},
					...colorPickerParams || {}
				});
			}

			app.f7.input.checkEmptyState(inputEl);

			if (!(validateOnBlur || validateOnBlur === '') && (validate || validate === '') && typeof value !== 'undefined' && value !== null && value !== '') {
				setTimeout(
					() => {
						validateInput();
					},
					0
				);
			}

			if (resizable) {
				app.f7.input.resizeTextarea(inputEl);
			}
		});
	});

	afterUpdate(() => {
		if (!app.f7) return;

		if (updateInputOnDidUpdate) {
			if (!inputEl) return;
			updateInputOnDidUpdate = false;
			app.f7.input.checkEmptyState(inputEl);

			if (validate && !validateOnBlur) {
				validateInput();
			}

			if (resizable) {
				app.f7.input.resizeTextarea(inputEl);
			}
		}
	});

	onDestroy(() => {
		if (type === 'range' || type === 'toggle') return;
		if (!inputEl) return;
		inputEl.removeEventListener('input:notempty', onInputNotEmpty, false);

		if (type === 'textarea' && resizable) {
			inputEl.removeEventListener('textarea:resize', onTextareaResize, false);
		}

		if (clearButton) {
			inputEl.removeEventListener('input:empty', onInputEmpty, false);
			inputEl.removeEventListener('input:clear', onInputClear, false);
		}

		if (f7Calendar && f7Calendar.destroy) {
			f7Calendar.destroy();
		}

		if (f7ColorPicker && f7ColorPicker.destroy) {
			f7ColorPicker.destroy();
		}

		f7Calendar = null;
		f7ColorPicker = null;
	});

	function select_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(42, inputEl);
		});
	}

	function textarea_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(42, inputEl);
		});
	}

	function input_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(42, inputEl);
		});
	}

	function select_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(42, inputEl);
		});
	}

	function textarea_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(42, inputEl);
		});
	}

	function input_1_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(42, inputEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(102, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(57, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(1, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(58, className = $$new_props.class);
		if ('sortable' in $$new_props) $$invalidate(59, sortable = $$new_props.sortable);
		if ('sortableOpposite' in $$new_props) $$invalidate(60, sortableOpposite = $$new_props.sortableOpposite);
		if ('media' in $$new_props) $$invalidate(2, media = $$new_props.media);
		if ('dropdown' in $$new_props) $$invalidate(61, dropdown = $$new_props.dropdown);
		if ('wrap' in $$new_props) $$invalidate(3, wrap = $$new_props.wrap);
		if ('input' in $$new_props) $$invalidate(4, input = $$new_props.input);
		if ('type' in $$new_props) $$invalidate(5, type = $$new_props.type);
		if ('name' in $$new_props) $$invalidate(6, name = $$new_props.name);
		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ('inputmode' in $$new_props) $$invalidate(7, inputmode = $$new_props.inputmode);
		if ('readonly' in $$new_props) $$invalidate(8, readonly = $$new_props.readonly);
		if ('required' in $$new_props) $$invalidate(9, required = $$new_props.required);
		if ('disabled' in $$new_props) $$invalidate(10, disabled = $$new_props.disabled);
		if ('placeholder' in $$new_props) $$invalidate(11, placeholder = $$new_props.placeholder);
		if ('inputId' in $$new_props) $$invalidate(12, inputId = $$new_props.inputId);
		if ('size' in $$new_props) $$invalidate(13, size = $$new_props.size);
		if ('accept' in $$new_props) $$invalidate(14, accept = $$new_props.accept);
		if ('autocomplete' in $$new_props) $$invalidate(15, autocomplete = $$new_props.autocomplete);
		if ('autocorrect' in $$new_props) $$invalidate(16, autocorrect = $$new_props.autocorrect);
		if ('autocapitalize' in $$new_props) $$invalidate(17, autocapitalize = $$new_props.autocapitalize);
		if ('spellcheck' in $$new_props) $$invalidate(18, spellcheck = $$new_props.spellcheck);
		if ('autofocus' in $$new_props) $$invalidate(19, autofocus = $$new_props.autofocus);
		if ('autosave' in $$new_props) $$invalidate(20, autosave = $$new_props.autosave);
		if ('max' in $$new_props) $$invalidate(21, max = $$new_props.max);
		if ('min' in $$new_props) $$invalidate(22, min = $$new_props.min);
		if ('step' in $$new_props) $$invalidate(23, step = $$new_props.step);
		if ('maxlength' in $$new_props) $$invalidate(24, maxlength = $$new_props.maxlength);
		if ('minlength' in $$new_props) $$invalidate(25, minlength = $$new_props.minlength);
		if ('multiple' in $$new_props) $$invalidate(26, multiple = $$new_props.multiple);
		if ('inputStyle' in $$new_props) $$invalidate(27, inputStyle = $$new_props.inputStyle);
		if ('pattern' in $$new_props) $$invalidate(28, pattern = $$new_props.pattern);
		if ('validate' in $$new_props) $$invalidate(29, validate = $$new_props.validate);
		if ('validateOnBlur' in $$new_props) $$invalidate(30, validateOnBlur = $$new_props.validateOnBlur);
		if ('onValidate' in $$new_props) $$invalidate(62, onValidate = $$new_props.onValidate);
		if ('tabindex' in $$new_props) $$invalidate(31, tabindex = $$new_props.tabindex);
		if ('resizable' in $$new_props) $$invalidate(32, resizable = $$new_props.resizable);
		if ('clearButton' in $$new_props) $$invalidate(33, clearButton = $$new_props.clearButton);
		if ('noFormStoreData' in $$new_props) $$invalidate(63, noFormStoreData = $$new_props.noFormStoreData);
		if ('noStoreData' in $$new_props) $$invalidate(64, noStoreData = $$new_props.noStoreData);
		if ('ignoreStoreData' in $$new_props) $$invalidate(65, ignoreStoreData = $$new_props.ignoreStoreData);
		if ('errorMessage' in $$new_props) $$invalidate(34, errorMessage = $$new_props.errorMessage);
		if ('errorMessageForce' in $$new_props) $$invalidate(35, errorMessageForce = $$new_props.errorMessageForce);
		if ('info' in $$new_props) $$invalidate(36, info = $$new_props.info);
		if ('outline' in $$new_props) $$invalidate(66, outline = $$new_props.outline);
		if ('label' in $$new_props) $$invalidate(37, label = $$new_props.label);
		if ('inlineLabel' in $$new_props) $$invalidate(67, inlineLabel = $$new_props.inlineLabel);
		if ('floatingLabel' in $$new_props) $$invalidate(68, floatingLabel = $$new_props.floatingLabel);
		if ('calendarParams' in $$new_props) $$invalidate(69, calendarParams = $$new_props.calendarParams);
		if ('colorPickerParams' in $$new_props) $$invalidate(70, colorPickerParams = $$new_props.colorPickerParams);
		if ('textEditorParams' in $$new_props) $$invalidate(38, textEditorParams = $$new_props.textEditorParams);
		if ('$$scope' in $$new_props) $$invalidate(77, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[1] & /*sortable*/ 268435456 | $$self.$$.dirty[2] & /*ListContext*/ 8192) {
			$: $$invalidate(52, isSortable = sortable === true || sortable === false
			? sortable
			: ListContext.listIsSortable);
		}

		if ($$self.$$.dirty[1] & /*sortableOpposite*/ 536870912 | $$self.$$.dirty[2] & /*ListContext*/ 8192) {
			$: $$invalidate(51, isSortableOpposite = sortableOpposite || ListContext.listIsSortableOpposite);
		}

		if ($$self.$$.dirty[0] & /*value*/ 1) {
			$: watchValue(value);
		}

		if ($$self.$$.dirty[2] & /*colorPickerParams*/ 256) {
			$: watchColorPickerParams(colorPickerParams);
		}

		if ($$self.$$.dirty[2] & /*calendarParams*/ 128) {
			$: watchCalendarParams(calendarParams);
		}

		if ($$self.$$.dirty[0] & /*type*/ 32) {
			$: $$invalidate(41, inputType = type === 'datepicker' || type === 'colorpicker'
			? 'text'
			: type);
		}

		if ($$self.$$.dirty[0] & /*type*/ 32) {
			$: needsValue = type !== 'file' && type !== 'datepicker' && type !== 'colorpicker';
		}

		if ($$self.$$.dirty[0] & /*value*/ 1) {
			$: $$invalidate(50, inputValue = (() => {
				let v;

				if (typeof value !== 'undefined') {
					v = value;
				} else {
					v = domValue();
				}

				if (typeof v === 'undefined' || v === null) return '';
				return v;
			})());
		}

		if ($$self.$$.dirty[1] & /*errorMessage*/ 8 | $$self.$$.dirty[2] & /*hasErrorSlots*/ 16384) {
			$: $$invalidate(39, hasErrorMessage = !!errorMessage || hasErrorSlots);
		}

		if ($$self.$$.dirty[1] & /*inputType, resizable, errorMessage, errorMessageForce*/ 1050 | $$self.$$.dirty[2] & /*noFormStoreData, noStoreData, ignoreStoreData, inputInvalid, inputFocused*/ 6158) {
			$: $$invalidate(47, inputClasses = classNames({
				resizable: inputType === 'textarea' && resizable,
				'no-store-data': noFormStoreData || noStoreData || ignoreStoreData,
				'input-invalid': errorMessage && errorMessageForce || inputInvalid,
				'input-with-value': inputHasValue(),
				'input-focused': inputFocused
			}));
		}

		$: $$invalidate(46, itemContentClasses = classNames('item-content item-input', !wrap && className, !wrap && { disabled }, !wrap && colorClasses($$props), {
			'inline-label': inlineLabel,
			'item-input-outline': outline,
			'item-input-focused': inputFocused,
			'item-input-with-info': !!info || hasInfoSlots,
			'item-input-with-value': inputHasValue(),
			'item-input-with-error-message': hasErrorMessage && errorMessageForce || inputInvalid,
			'item-input-invalid': hasErrorMessage && errorMessageForce || inputInvalid
		}));

		if ($$self.$$.dirty[2] & /*floatingLabel*/ 64) {
			$: $$invalidate(45, labelClasses = classNames('item-title item-label', { 'item-floating-label': floatingLabel }));
		}

		if ($$self.$$.dirty[0] & /*type*/ 32 | $$self.$$.dirty[1] & /*dropdown*/ 1073741824) {
			$: $$invalidate(44, inputWrapClasses = classNames('item-input-wrap', {
				'input-dropdown': dropdown === 'auto' ? type === 'select' : dropdown
			}));
		}

		$: $$invalidate(43, classes = classNames(className, { disabled }, colorClasses($$props)));
	};

	$: $$invalidate(40, hasInfoSlots = $$slots.info);
	$: $$invalidate(76, hasErrorSlots = $$slots['error-message']);
	$: $$invalidate(49, hasMediaSlots = $$slots.media);
	$: $$invalidate(48, hasLabelSlots = $$slots.label);
	$$props = exclude_internal_props($$props);

	return [
		value,
		lec,
		media,
		wrap,
		input,
		type,
		name,
		inputmode,
		readonly,
		required,
		disabled,
		placeholder,
		inputId,
		size,
		accept,
		autocomplete,
		autocorrect,
		autocapitalize,
		spellcheck,
		autofocus,
		autosave,
		max,
		min,
		step,
		maxlength,
		minlength,
		multiple,
		inputStyle,
		pattern,
		validate,
		validateOnBlur,
		tabindex,
		resizable,
		clearButton,
		errorMessage,
		errorMessageForce,
		info,
		label,
		textEditorParams,
		hasErrorMessage,
		hasInfoSlots,
		inputType,
		inputEl,
		classes,
		inputWrapClasses,
		labelClasses,
		itemContentClasses,
		inputClasses,
		hasLabelSlots,
		hasMediaSlots,
		inputValue,
		isSortableOpposite,
		isSortable,
		onInput,
		onFocus,
		onBlur,
		onChange,
		$$restProps,
		className,
		sortable,
		sortableOpposite,
		dropdown,
		onValidate,
		noFormStoreData,
		noStoreData,
		ignoreStoreData,
		outline,
		inlineLabel,
		floatingLabel,
		calendarParams,
		colorPickerParams,
		calendarInstance,
		colorPickerInstance,
		inputFocused,
		inputInvalid,
		ListContext,
		hasErrorSlots,
		$$scope,
		slots,
		select_binding,
		textarea_binding,
		input_1_binding,
		select_binding_1,
		textarea_binding_1,
		input_1_binding_1
	];
}

class List_input extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$I,
			create_fragment$M,
			safe_not_equal,
			{
				lec: 1,
				class: 58,
				sortable: 59,
				sortableOpposite: 60,
				media: 2,
				dropdown: 61,
				wrap: 3,
				input: 4,
				type: 5,
				name: 6,
				value: 0,
				inputmode: 7,
				readonly: 8,
				required: 9,
				disabled: 10,
				placeholder: 11,
				inputId: 12,
				size: 13,
				accept: 14,
				autocomplete: 15,
				autocorrect: 16,
				autocapitalize: 17,
				spellcheck: 18,
				autofocus: 19,
				autosave: 20,
				max: 21,
				min: 22,
				step: 23,
				maxlength: 24,
				minlength: 25,
				multiple: 26,
				inputStyle: 27,
				pattern: 28,
				validate: 29,
				validateOnBlur: 30,
				onValidate: 62,
				tabindex: 31,
				resizable: 32,
				clearButton: 33,
				noFormStoreData: 63,
				noStoreData: 64,
				ignoreStoreData: 65,
				errorMessage: 34,
				errorMessageForce: 35,
				info: 36,
				outline: 66,
				label: 37,
				inlineLabel: 67,
				floatingLabel: 68,
				calendarParams: 69,
				colorPickerParams: 70,
				textEditorParams: 38,
				calendarInstance: 71,
				colorPickerInstance: 72
			},
			null,
			[-1, -1, -1, -1]
		);
	}

	get calendarInstance() {
		return this.$$.ctx[71];
	}

	get colorPickerInstance() {
		return this.$$.ctx[72];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/list-item-cell.liquivelte generated by Svelte v3.50.0 */

function create_fragment$L(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$N = 0;

function instance$H($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'item-cell', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, $$scope, slots];
}

class List_item_cell extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$H, create_fragment$L, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/list-item-row.liquivelte generated by Svelte v3.50.0 */

function create_fragment$K(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$M = 0;

function instance$G($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'item-row', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, $$scope, slots];
}

class List_item_row extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$G, create_fragment$K, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/list-item.liquivelte generated by Svelte v3.50.0 */
const get_root_end_slot_changes$1 = dirty => ({});
const get_root_end_slot_context$1 = ctx => ({});
const get_root_slot_changes$1 = dirty => ({});
const get_root_slot_context$1 = ctx => ({});
const get_content_end_slot_changes_5 = dirty => ({});
const get_content_end_slot_context_5 = ctx => ({});
const get_content_slot_changes_5 = dirty => ({});
const get_content_slot_context_5 = ctx => ({});
const get_inner_end_slot_changes_5 = dirty => ({});
const get_inner_end_slot_context_5 = ctx => ({});
const get_inner_slot_changes_11 = dirty => ({});
const get_inner_slot_context_11 = ctx => ({});
const get_after_end_slot_changes_11 = dirty => ({});
const get_after_end_slot_context_11 = ctx => ({});
const get_after_slot_changes_11 = dirty => ({});
const get_after_slot_context_11 = ctx => ({});
const get_after_start_slot_changes_11 = dirty => ({});
const get_after_start_slot_context_11 = ctx => ({});
const get_after_title_slot_changes_11 = dirty => ({});
const get_after_title_slot_context_11 = ctx => ({});
const get_footer_slot_changes_11 = dirty => ({});
const get_footer_slot_context_11 = ctx => ({});
const get_title_slot_changes_11 = dirty => ({});
const get_title_slot_context_11 = ctx => ({});
const get_header_slot_changes_11 = dirty => ({});
const get_header_slot_context_11 = ctx => ({});
const get_before_title_slot_changes_11 = dirty => ({});
const get_before_title_slot_context_11 = ctx => ({});
const get_footer_slot_changes_10 = dirty => ({});
const get_footer_slot_context_10 = ctx => ({});
const get_inner_slot_changes_10 = dirty => ({});
const get_inner_slot_context_10 = ctx => ({});
const get_text_slot_changes_5 = dirty => ({});
const get_text_slot_context_5 = ctx => ({});
const get_subtitle_slot_changes_5 = dirty => ({});
const get_subtitle_slot_context_5 = ctx => ({});
const get_after_end_slot_changes_10 = dirty => ({});
const get_after_end_slot_context_10 = ctx => ({});
const get_after_slot_changes_10 = dirty => ({});
const get_after_slot_context_10 = ctx => ({});
const get_after_start_slot_changes_10 = dirty => ({});
const get_after_start_slot_context_10 = ctx => ({});
const get_after_title_slot_changes_10 = dirty => ({});
const get_after_title_slot_context_10 = ctx => ({});
const get_title_slot_changes_10 = dirty => ({});
const get_title_slot_context_10 = ctx => ({});
const get_before_title_slot_changes_10 = dirty => ({});
const get_before_title_slot_context_10 = ctx => ({});
const get_header_slot_changes_10 = dirty => ({});
const get_header_slot_context_10 = ctx => ({});
const get_inner_start_slot_changes_5 = dirty => ({});
const get_inner_start_slot_context_5 = ctx => ({});
const get_media_slot_changes_5 = dirty => ({});
const get_media_slot_context_5 = ctx => ({});
const get_content_start_slot_changes_5 = dirty => ({});
const get_content_start_slot_context_5 = ctx => ({});
const get_content_end_slot_changes_4 = dirty => ({});
const get_content_end_slot_context_4 = ctx => ({});
const get_content_slot_changes_4 = dirty => ({});
const get_content_slot_context_4 = ctx => ({});
const get_inner_end_slot_changes_4 = dirty => ({});
const get_inner_end_slot_context_4 = ctx => ({});
const get_inner_slot_changes_9 = dirty => ({});
const get_inner_slot_context_9 = ctx => ({});
const get_after_end_slot_changes_9 = dirty => ({});
const get_after_end_slot_context_9 = ctx => ({});
const get_after_slot_changes_9 = dirty => ({});
const get_after_slot_context_9 = ctx => ({});
const get_after_start_slot_changes_9 = dirty => ({});
const get_after_start_slot_context_9 = ctx => ({});
const get_after_title_slot_changes_9 = dirty => ({});
const get_after_title_slot_context_9 = ctx => ({});
const get_footer_slot_changes_9 = dirty => ({});
const get_footer_slot_context_9 = ctx => ({});
const get_title_slot_changes_9 = dirty => ({});
const get_title_slot_context_9 = ctx => ({});
const get_header_slot_changes_9 = dirty => ({});
const get_header_slot_context_9 = ctx => ({});
const get_before_title_slot_changes_9 = dirty => ({});
const get_before_title_slot_context_9 = ctx => ({});
const get_footer_slot_changes_8 = dirty => ({});
const get_footer_slot_context_8 = ctx => ({});
const get_inner_slot_changes_8 = dirty => ({});
const get_inner_slot_context_8 = ctx => ({});
const get_text_slot_changes_4 = dirty => ({});
const get_text_slot_context_4 = ctx => ({});
const get_subtitle_slot_changes_4 = dirty => ({});
const get_subtitle_slot_context_4 = ctx => ({});
const get_after_end_slot_changes_8 = dirty => ({});
const get_after_end_slot_context_8 = ctx => ({});
const get_after_slot_changes_8 = dirty => ({});
const get_after_slot_context_8 = ctx => ({});
const get_after_start_slot_changes_8 = dirty => ({});
const get_after_start_slot_context_8 = ctx => ({});
const get_after_title_slot_changes_8 = dirty => ({});
const get_after_title_slot_context_8 = ctx => ({});
const get_title_slot_changes_8 = dirty => ({});
const get_title_slot_context_8 = ctx => ({});
const get_before_title_slot_changes_8 = dirty => ({});
const get_before_title_slot_context_8 = ctx => ({});
const get_header_slot_changes_8 = dirty => ({});
const get_header_slot_context_8 = ctx => ({});
const get_inner_start_slot_changes_4 = dirty => ({});
const get_inner_start_slot_context_4 = ctx => ({});
const get_media_slot_changes_4 = dirty => ({});
const get_media_slot_context_4 = ctx => ({});
const get_content_start_slot_changes_4 = dirty => ({});
const get_content_start_slot_context_4 = ctx => ({});
const get_content_end_slot_changes_3 = dirty => ({});
const get_content_end_slot_context_3 = ctx => ({});
const get_content_slot_changes_3 = dirty => ({});
const get_content_slot_context_3 = ctx => ({});
const get_inner_end_slot_changes_3 = dirty => ({});
const get_inner_end_slot_context_3 = ctx => ({});
const get_inner_slot_changes_7 = dirty => ({});
const get_inner_slot_context_7 = ctx => ({});
const get_after_end_slot_changes_7 = dirty => ({});
const get_after_end_slot_context_7 = ctx => ({});
const get_after_slot_changes_7 = dirty => ({});
const get_after_slot_context_7 = ctx => ({});
const get_after_start_slot_changes_7 = dirty => ({});
const get_after_start_slot_context_7 = ctx => ({});
const get_after_title_slot_changes_7 = dirty => ({});
const get_after_title_slot_context_7 = ctx => ({});
const get_footer_slot_changes_7 = dirty => ({});
const get_footer_slot_context_7 = ctx => ({});
const get_title_slot_changes_7 = dirty => ({});
const get_title_slot_context_7 = ctx => ({});
const get_header_slot_changes_7 = dirty => ({});
const get_header_slot_context_7 = ctx => ({});
const get_before_title_slot_changes_7 = dirty => ({});
const get_before_title_slot_context_7 = ctx => ({});
const get_footer_slot_changes_6 = dirty => ({});
const get_footer_slot_context_6 = ctx => ({});
const get_inner_slot_changes_6 = dirty => ({});
const get_inner_slot_context_6 = ctx => ({});
const get_text_slot_changes_3 = dirty => ({});
const get_text_slot_context_3 = ctx => ({});
const get_subtitle_slot_changes_3 = dirty => ({});
const get_subtitle_slot_context_3 = ctx => ({});
const get_after_end_slot_changes_6 = dirty => ({});
const get_after_end_slot_context_6 = ctx => ({});
const get_after_slot_changes_6 = dirty => ({});
const get_after_slot_context_6 = ctx => ({});
const get_after_start_slot_changes_6 = dirty => ({});
const get_after_start_slot_context_6 = ctx => ({});
const get_after_title_slot_changes_6 = dirty => ({});
const get_after_title_slot_context_6 = ctx => ({});
const get_title_slot_changes_6 = dirty => ({});
const get_title_slot_context_6 = ctx => ({});
const get_before_title_slot_changes_6 = dirty => ({});
const get_before_title_slot_context_6 = ctx => ({});
const get_header_slot_changes_6 = dirty => ({});
const get_header_slot_context_6 = ctx => ({});
const get_inner_start_slot_changes_3 = dirty => ({});
const get_inner_start_slot_context_3 = ctx => ({});
const get_media_slot_changes_3 = dirty => ({});
const get_media_slot_context_3 = ctx => ({});
const get_content_start_slot_changes_3 = dirty => ({});
const get_content_start_slot_context_3 = ctx => ({});
const get_content_end_slot_changes_2 = dirty => ({});
const get_content_end_slot_context_2 = ctx => ({});
const get_content_slot_changes_2 = dirty => ({});
const get_content_slot_context_2 = ctx => ({});
const get_inner_end_slot_changes_2 = dirty => ({});
const get_inner_end_slot_context_2 = ctx => ({});
const get_inner_slot_changes_5 = dirty => ({});
const get_inner_slot_context_5 = ctx => ({});
const get_after_end_slot_changes_5 = dirty => ({});
const get_after_end_slot_context_5 = ctx => ({});
const get_after_slot_changes_5 = dirty => ({});
const get_after_slot_context_5 = ctx => ({});
const get_after_start_slot_changes_5 = dirty => ({});
const get_after_start_slot_context_5 = ctx => ({});
const get_after_title_slot_changes_5 = dirty => ({});
const get_after_title_slot_context_5 = ctx => ({});
const get_footer_slot_changes_5 = dirty => ({});
const get_footer_slot_context_5 = ctx => ({});
const get_title_slot_changes_5 = dirty => ({});
const get_title_slot_context_5 = ctx => ({});
const get_header_slot_changes_5 = dirty => ({});
const get_header_slot_context_5 = ctx => ({});
const get_before_title_slot_changes_5 = dirty => ({});
const get_before_title_slot_context_5 = ctx => ({});
const get_footer_slot_changes_4 = dirty => ({});
const get_footer_slot_context_4 = ctx => ({});
const get_inner_slot_changes_4 = dirty => ({});
const get_inner_slot_context_4 = ctx => ({});
const get_text_slot_changes_2 = dirty => ({});
const get_text_slot_context_2 = ctx => ({});
const get_subtitle_slot_changes_2 = dirty => ({});
const get_subtitle_slot_context_2 = ctx => ({});
const get_after_end_slot_changes_4 = dirty => ({});
const get_after_end_slot_context_4 = ctx => ({});
const get_after_slot_changes_4 = dirty => ({});
const get_after_slot_context_4 = ctx => ({});
const get_after_start_slot_changes_4 = dirty => ({});
const get_after_start_slot_context_4 = ctx => ({});
const get_after_title_slot_changes_4 = dirty => ({});
const get_after_title_slot_context_4 = ctx => ({});
const get_title_slot_changes_4 = dirty => ({});
const get_title_slot_context_4 = ctx => ({});
const get_before_title_slot_changes_4 = dirty => ({});
const get_before_title_slot_context_4 = ctx => ({});
const get_header_slot_changes_4 = dirty => ({});
const get_header_slot_context_4 = ctx => ({});
const get_inner_start_slot_changes_2 = dirty => ({});
const get_inner_start_slot_context_2 = ctx => ({});
const get_media_slot_changes_2 = dirty => ({});
const get_media_slot_context_2 = ctx => ({});
const get_content_start_slot_changes_2 = dirty => ({});
const get_content_start_slot_context_2 = ctx => ({});
const get_content_end_slot_changes_1$1 = dirty => ({});
const get_content_end_slot_context_1$1 = ctx => ({});
const get_content_slot_changes_1$1 = dirty => ({});
const get_content_slot_context_1$1 = ctx => ({});
const get_inner_end_slot_changes_1$1 = dirty => ({});
const get_inner_end_slot_context_1$1 = ctx => ({});
const get_inner_slot_changes_3 = dirty => ({});
const get_inner_slot_context_3 = ctx => ({});
const get_after_end_slot_changes_3 = dirty => ({});
const get_after_end_slot_context_3 = ctx => ({});
const get_after_slot_changes_3 = dirty => ({});
const get_after_slot_context_3 = ctx => ({});
const get_after_start_slot_changes_3 = dirty => ({});
const get_after_start_slot_context_3 = ctx => ({});
const get_after_title_slot_changes_3 = dirty => ({});
const get_after_title_slot_context_3 = ctx => ({});
const get_footer_slot_changes_3 = dirty => ({});
const get_footer_slot_context_3 = ctx => ({});
const get_title_slot_changes_3 = dirty => ({});
const get_title_slot_context_3 = ctx => ({});
const get_header_slot_changes_3 = dirty => ({});
const get_header_slot_context_3 = ctx => ({});
const get_before_title_slot_changes_3 = dirty => ({});
const get_before_title_slot_context_3 = ctx => ({});
const get_footer_slot_changes_2 = dirty => ({});
const get_footer_slot_context_2 = ctx => ({});
const get_inner_slot_changes_2 = dirty => ({});
const get_inner_slot_context_2 = ctx => ({});
const get_text_slot_changes_1$1 = dirty => ({});
const get_text_slot_context_1$1 = ctx => ({});
const get_subtitle_slot_changes_1 = dirty => ({});
const get_subtitle_slot_context_1 = ctx => ({});
const get_after_end_slot_changes_2 = dirty => ({});
const get_after_end_slot_context_2 = ctx => ({});
const get_after_slot_changes_2 = dirty => ({});
const get_after_slot_context_2 = ctx => ({});
const get_after_start_slot_changes_2 = dirty => ({});
const get_after_start_slot_context_2 = ctx => ({});
const get_after_title_slot_changes_2 = dirty => ({});
const get_after_title_slot_context_2 = ctx => ({});
const get_title_slot_changes_2 = dirty => ({});
const get_title_slot_context_2 = ctx => ({});
const get_before_title_slot_changes_2 = dirty => ({});
const get_before_title_slot_context_2 = ctx => ({});
const get_header_slot_changes_2 = dirty => ({});
const get_header_slot_context_2 = ctx => ({});
const get_inner_start_slot_changes_1$1 = dirty => ({});
const get_inner_start_slot_context_1$1 = ctx => ({});
const get_media_slot_changes_1$1 = dirty => ({});
const get_media_slot_context_1$1 = ctx => ({});
const get_content_start_slot_changes_1$1 = dirty => ({});
const get_content_start_slot_context_1$1 = ctx => ({});
const get_content_end_slot_changes$2 = dirty => ({});
const get_content_end_slot_context$2 = ctx => ({});
const get_content_slot_changes$1 = dirty => ({});
const get_content_slot_context$1 = ctx => ({});
const get_inner_end_slot_changes$2 = dirty => ({});
const get_inner_end_slot_context$2 = ctx => ({});
const get_inner_slot_changes_1 = dirty => ({});
const get_inner_slot_context_1 = ctx => ({});
const get_after_end_slot_changes_1 = dirty => ({});
const get_after_end_slot_context_1 = ctx => ({});
const get_after_slot_changes_1 = dirty => ({});
const get_after_slot_context_1 = ctx => ({});
const get_after_start_slot_changes_1 = dirty => ({});
const get_after_start_slot_context_1 = ctx => ({});
const get_after_title_slot_changes_1 = dirty => ({});
const get_after_title_slot_context_1 = ctx => ({});
const get_footer_slot_changes_1 = dirty => ({});
const get_footer_slot_context_1 = ctx => ({});
const get_title_slot_changes_1 = dirty => ({});
const get_title_slot_context_1 = ctx => ({});
const get_header_slot_changes_1 = dirty => ({});
const get_header_slot_context_1 = ctx => ({});
const get_before_title_slot_changes_1 = dirty => ({});
const get_before_title_slot_context_1 = ctx => ({});
const get_footer_slot_changes$1 = dirty => ({});
const get_footer_slot_context$1 = ctx => ({});
const get_inner_slot_changes = dirty => ({});
const get_inner_slot_context = ctx => ({});
const get_text_slot_changes$2 = dirty => ({});
const get_text_slot_context$2 = ctx => ({});
const get_subtitle_slot_changes = dirty => ({});
const get_subtitle_slot_context = ctx => ({});
const get_after_end_slot_changes = dirty => ({});
const get_after_end_slot_context = ctx => ({});
const get_after_slot_changes = dirty => ({});
const get_after_slot_context = ctx => ({});
const get_after_start_slot_changes = dirty => ({});
const get_after_start_slot_context = ctx => ({});
const get_after_title_slot_changes = dirty => ({});
const get_after_title_slot_context = ctx => ({});
const get_title_slot_changes$1 = dirty => ({});
const get_title_slot_context$1 = ctx => ({});
const get_before_title_slot_changes = dirty => ({});
const get_before_title_slot_context = ctx => ({});
const get_header_slot_changes$1 = dirty => ({});
const get_header_slot_context$1 = ctx => ({});
const get_inner_start_slot_changes$2 = dirty => ({});
const get_inner_start_slot_context$2 = ctx => ({});
const get_media_slot_changes$1 = dirty => ({});
const get_media_slot_context$1 = ctx => ({});
const get_content_start_slot_changes$2 = dirty => ({});
const get_content_start_slot_context$2 = ctx => ({});
const get_root_start_slot_changes$1 = dirty => ({});
const get_root_start_slot_context$1 = ctx => ({});

// (346:0) {:else}
function create_else_block$a(ctx) {
	let li;
	let t0;
	let current_block_type_index;
	let if_block0;
	let t1;
	let t2;
	let t3;
	let t4;
	let useTooltip_action;
	let current;
	let mounted;
	let dispose;
	const root_start_slot_template = /*#slots*/ ctx[70]["root-start"];
	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[84], get_root_start_slot_context$1);
	const if_block_creators = [create_if_block_4$4, create_if_block_67, create_else_block_7];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*swipeout*/ ctx[15]) return 0;
		if (/*isLink*/ ctx[39]) return 1;
		return 2;
	}

	current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1]);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*isSortable*/ ctx[46] && /*sortable*/ ctx[16] !== false && !/*isSortableOpposite*/ ctx[45] && create_if_block_3$8(ctx);
	let if_block2 = (/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17]) && create_if_block_2$9(ctx);
	const root_slot_template = /*#slots*/ ctx[70].root;
	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[84], get_root_slot_context$1);
	const root_end_slot_template = /*#slots*/ ctx[70]["root-end"];
	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[84], get_root_end_slot_context$1);

	let li_levels = [
		{ class: /*liClasses*/ ctx[43] },
		{
			"data-virtual-list-index": /*virtualListIndex*/ ctx[25]
		},
		restProps(/*$$restProps*/ ctx[49])
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	return {
		c() {
			li = element("li");
			if (root_start_slot) root_start_slot.c();
			t0 = space();
			if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			if (root_slot) root_slot.c();
			t4 = space();
			if (root_end_slot) root_end_slot.c();
			this.h();
		},
		l(nodes) {
			li = claim_element(nodes, "LI", {
				class: true,
				"data-virtual-list-index": true
			});

			var li_nodes = children(li);
			if (root_start_slot) root_start_slot.l(li_nodes);
			t0 = claim_space(li_nodes);
			if_block0.l(li_nodes);
			t1 = claim_space(li_nodes);
			if (if_block1) if_block1.l(li_nodes);
			t2 = claim_space(li_nodes);
			if (if_block2) if_block2.l(li_nodes);
			t3 = claim_space(li_nodes);
			if (root_slot) root_slot.l(li_nodes);
			t4 = claim_space(li_nodes);
			if (root_end_slot) root_end_slot.l(li_nodes);
			li_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(li, li_data);
		},
		m(target, anchor) {
			insert_hydration(target, li, anchor);

			if (root_start_slot) {
				root_start_slot.m(li, null);
			}

			append_hydration(li, t0);
			if_blocks[current_block_type_index].m(li, null);
			append_hydration(li, t1);
			if (if_block1) if_block1.m(li, null);
			append_hydration(li, t2);
			if (if_block2) if_block2.m(li, null);
			append_hydration(li, t3);

			if (root_slot) {
				root_slot.m(li, null);
			}

			append_hydration(li, t4);

			if (root_end_slot) {
				root_end_slot.m(li, null);
			}

			/*li_binding_2*/ ctx[83](li);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(useTooltip_action = useTooltip.call(null, li, {
					tooltip: /*tooltip*/ ctx[8],
					tooltipTrigger: /*tooltipTrigger*/ ctx[9]
				}));

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (root_start_slot) {
				if (root_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						root_start_slot,
						root_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(root_start_slot_template, /*$$scope*/ ctx[84], dirty, get_root_start_slot_changes$1),
						get_root_start_slot_context$1
					);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(li, t1);
			}

			if (/*isSortable*/ ctx[46] && /*sortable*/ ctx[16] !== false && !/*isSortableOpposite*/ ctx[45]) {
				if (if_block1) {
					
				} else {
					if_block1 = create_if_block_3$8(ctx);
					if_block1.c();
					if_block1.m(li, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 163840) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_2$9(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(li, t3);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (root_slot) {
				if (root_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						root_slot,
						root_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(root_slot_template, /*$$scope*/ ctx[84], dirty, get_root_slot_changes$1),
						get_root_slot_context$1
					);
				}
			}

			if (root_end_slot) {
				if (root_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						root_end_slot,
						root_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(root_end_slot_template, /*$$scope*/ ctx[84], dirty, get_root_end_slot_changes$1),
						get_root_end_slot_context$1
					);
				}
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty[1] & /*liClasses*/ 4096) && { class: /*liClasses*/ ctx[43] },
				(!current || dirty[0] & /*virtualListIndex*/ 33554432) && {
					"data-virtual-list-index": /*virtualListIndex*/ ctx[25]
				},
				dirty[1] & /*$$restProps*/ 262144 && restProps(/*$$restProps*/ ctx[49])
			]));

			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 768) useTooltip_action.update.call(null, {
				tooltip: /*tooltip*/ ctx[8],
				tooltipTrigger: /*tooltipTrigger*/ ctx[9]
			});
		},
		i(local) {
			if (current) return;
			transition_in(root_start_slot, local);
			transition_in(if_block0);
			transition_in(if_block2);
			transition_in(root_slot, local);
			transition_in(root_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(root_start_slot, local);
			transition_out(if_block0);
			transition_out(if_block2);
			transition_out(root_slot, local);
			transition_out(root_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (root_start_slot) root_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (root_slot) root_slot.d(detaching);
			if (root_end_slot) root_end_slot.d(detaching);
			/*li_binding_2*/ ctx[83](null);
			mounted = false;
			dispose();
		}
	};
}

// (334:19) 
function create_if_block_1$e(ctx) {
	let li;
	let t0_value = plainText(/*title*/ ctx[2]) + "";
	let t0;
	let t1;
	let useTooltip_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[70].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[84], null);

	let li_levels = [
		{ class: /*liClasses*/ ctx[43] },
		{
			"data-virtual-list-index": /*virtualListIndex*/ ctx[25]
		},
		restProps(/*$$restProps*/ ctx[49])
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	return {
		c() {
			li = element("li");
			t0 = text(t0_value);
			t1 = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			li = claim_element(nodes, "LI", {
				class: true,
				"data-virtual-list-index": true
			});

			var li_nodes = children(li);
			t0 = claim_text(li_nodes, t0_value);
			t1 = claim_space(li_nodes);
			if (default_slot) default_slot.l(li_nodes);
			li_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(li, li_data);
		},
		m(target, anchor) {
			insert_hydration(target, li, anchor);
			append_hydration(li, t0);
			append_hydration(li, t1);

			if (default_slot) {
				default_slot.m(li, null);
			}

			/*li_binding_1*/ ctx[72](li);
			current = true;

			if (!mounted) {
				dispose = [
					listen(li, "click", /*onClick*/ ctx[47]),
					action_destroyer(useTooltip_action = useTooltip.call(null, li, {
						tooltip: /*tooltip*/ ctx[8],
						tooltipTrigger: /*tooltipTrigger*/ ctx[9]
					}))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 4) && t0_value !== (t0_value = plainText(/*title*/ ctx[2]) + "")) set_data(t0, t0_value);

			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[84], dirty, null),
						null
					);
				}
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty[1] & /*liClasses*/ 4096) && { class: /*liClasses*/ ctx[43] },
				(!current || dirty[0] & /*virtualListIndex*/ 33554432) && {
					"data-virtual-list-index": /*virtualListIndex*/ ctx[25]
				},
				dirty[1] & /*$$restProps*/ 262144 && restProps(/*$$restProps*/ ctx[49])
			]));

			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 768) useTooltip_action.update.call(null, {
				tooltip: /*tooltip*/ ctx[8],
				tooltipTrigger: /*tooltipTrigger*/ ctx[9]
			});
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (default_slot) default_slot.d(detaching);
			/*li_binding_1*/ ctx[72](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (323:0) {#if divider || groupTitle}
function create_if_block$n(ctx) {
	let li;
	let span;
	let useTooltip_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[70].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[84], null);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);

	let li_levels = [
		{ class: /*liClasses*/ ctx[43] },
		{
			"data-virtual-list-index": /*virtualListIndex*/ ctx[25]
		},
		restProps(/*$$restProps*/ ctx[49])
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	return {
		c() {
			li = element("li");
			span = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			this.h();
		},
		l(nodes) {
			li = claim_element(nodes, "LI", {
				class: true,
				"data-virtual-list-index": true
			});

			var li_nodes = children(li);
			span = claim_element(li_nodes, "SPAN", {});
			var span_nodes = children(span);
			if (default_slot_or_fallback) default_slot_or_fallback.l(span_nodes);
			span_nodes.forEach(detach);
			li_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(li, li_data);
		},
		m(target, anchor) {
			insert_hydration(target, li, anchor);
			append_hydration(li, span);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span, null);
			}

			/*li_binding*/ ctx[71](li);
			current = true;

			if (!mounted) {
				dispose = [
					listen(li, "click", /*onClick*/ ctx[47]),
					action_destroyer(useTooltip_action = useTooltip.call(null, li, {
						tooltip: /*tooltip*/ ctx[8],
						tooltipTrigger: /*tooltipTrigger*/ ctx[9]
					}))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[84], dirty, null),
						null
					);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*title*/ 4)) {
					default_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1] : dirty);
				}
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty[1] & /*liClasses*/ 4096) && { class: /*liClasses*/ ctx[43] },
				(!current || dirty[0] & /*virtualListIndex*/ 33554432) && {
					"data-virtual-list-index": /*virtualListIndex*/ ctx[25]
				},
				dirty[1] & /*$$restProps*/ 262144 && restProps(/*$$restProps*/ ctx[49])
			]));

			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 768) useTooltip_action.update.call(null, {
				tooltip: /*tooltip*/ ctx[8],
				tooltipTrigger: /*tooltipTrigger*/ ctx[9]
			});
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			/*li_binding*/ ctx[71](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (843:4) {:else}
function create_else_block_7(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_88, create_else_block_9];
	const if_blocks = [];

	function select_block_type_8(ctx, dirty) {
		if (/*checkbox*/ ctx[18] || /*radio*/ ctx[19]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_8(ctx, [-1, -1, -1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_8(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (721:21) 
function create_if_block_67(ctx) {
	let a;
	let div1;
	let t0;
	let t1;
	let t2;
	let div0;
	let t3;
	let current_block_type_index;
	let if_block2;
	let t4;
	let t5;
	let t6;
	let useRouteProps_action;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*#slots*/ ctx[70]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[84], get_content_start_slot_context_3);
	let if_block0 = /*isSortable*/ ctx[46] && /*sortable*/ ctx[16] !== false && /*isSortableOpposite*/ ctx[45] && create_if_block_87(ctx);
	let if_block1 = /*hasMedia*/ ctx[38] && create_if_block_85(ctx);
	const inner_start_slot_template = /*#slots*/ ctx[70]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_start_slot_context_3);
	const if_block_creators = [create_if_block_68, create_else_block_6];
	const if_blocks = [];

	function select_block_type_7(ctx, dirty) {
		if (/*isMedia*/ ctx[27]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_7(ctx, [-1, -1, -1, -1]);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*#slots*/ ctx[70]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_end_slot_context_3);
	const content_slot_template = /*#slots*/ ctx[70].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[84], get_content_slot_context_3);
	const content_end_slot_template = /*#slots*/ ctx[70]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[84], get_content_end_slot_context_3);
	let a_levels = [{ class: /*linkClasses*/ ctx[41] }, /*linkAttrs*/ ctx[40]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = element("a");
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div0 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t3 = space();
			if_block2.c();
			t4 = space();
			if (inner_end_slot) inner_end_slot.c();
			t5 = space();
			if (content_slot) content_slot.c();
			t6 = space();
			if (content_end_slot) content_end_slot.c();
			this.h();
		},
		l(nodes) {
			a = claim_element(nodes, "A", { class: true });
			var a_nodes = children(a);
			div1 = claim_element(a_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (content_start_slot) content_start_slot.l(div1_nodes);
			t0 = claim_space(div1_nodes);
			if (if_block0) if_block0.l(div1_nodes);
			t1 = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			t2 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (inner_start_slot) inner_start_slot.l(div0_nodes);
			t3 = claim_space(div0_nodes);
			if_block2.l(div0_nodes);
			t4 = claim_space(div0_nodes);
			if (inner_end_slot) inner_end_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			t5 = claim_space(div1_nodes);
			if (content_slot) content_slot.l(div1_nodes);
			t6 = claim_space(div1_nodes);
			if (content_end_slot) content_end_slot.l(div1_nodes);
			div1_nodes.forEach(detach);
			a_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "item-inner");
			attr(div1, "class", /*contentClasses*/ ctx[42]);
			set_attributes(a, a_data);
		},
		m(target, anchor) {
			insert_hydration(target, a, anchor);
			append_hydration(a, div1);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_hydration(div1, t0);
			if (if_block0) if_block0.m(div1, null);
			append_hydration(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			append_hydration(div1, t2);
			append_hydration(div1, div0);

			if (inner_start_slot) {
				inner_start_slot.m(div0, null);
			}

			append_hydration(div0, t3);
			if_blocks[current_block_type_index].m(div0, null);
			append_hydration(div0, t4);

			if (inner_end_slot) {
				inner_end_slot.m(div0, null);
			}

			/*div0_binding_2*/ ctx[78](div0);
			append_hydration(div1, t5);

			if (content_slot) {
				content_slot.m(div1, null);
			}

			append_hydration(div1, t6);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			/*a_binding_1*/ ctx[79](a);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useRouteProps_action = useRouteProps.call(null, a, /*routeProps*/ ctx[26])),
					listen(a, "click", /*onClick*/ ctx[47])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_start_slot,
						content_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[84], dirty, get_content_start_slot_changes_3),
						get_content_start_slot_context_3
					);
				}
			}

			if (/*isSortable*/ ctx[46] && /*sortable*/ ctx[16] !== false && /*isSortableOpposite*/ ctx[45]) {
				if (if_block0) {
					
				} else {
					if_block0 = create_if_block_87(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*hasMedia*/ ctx[38]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_85(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_start_slot,
						inner_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_start_slot_changes_3),
						get_inner_start_slot_context_3
					);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_7(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(div0, t4);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_end_slot,
						inner_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_end_slot_changes_3),
						get_inner_end_slot_context_3
					);
				}
			}

			if (content_slot) {
				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_slot,
						content_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[84], dirty, get_content_slot_changes_3),
						get_content_slot_context_3
					);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_end_slot,
						content_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[84], dirty, get_content_end_slot_changes_3),
						get_content_end_slot_context_3
					);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2048) {
				attr(div1, "class", /*contentClasses*/ ctx[42]);
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty[1] & /*linkClasses*/ 1024) && { class: /*linkClasses*/ ctx[41] },
				dirty[1] & /*linkAttrs*/ 512 && /*linkAttrs*/ ctx[40]
			]));

			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 67108864) useRouteProps_action.update.call(null, /*routeProps*/ ctx[26]);
		},
		i(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div0_binding_2*/ ctx[78](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			/*a_binding_1*/ ctx[79](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (355:4) {#if swipeout}
function create_if_block_4$4(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_5$2, create_else_block_2$1];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*isLink*/ ctx[39]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx, [-1, -1, -1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if_block.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "swipeout-content");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
		}
	};
}

// (969:6) {:else}
function create_else_block_9(ctx) {
	let div1;
	let t0;
	let t1;
	let t2;
	let div0;
	let t3;
	let current_block_type_index;
	let if_block2;
	let t4;
	let t5;
	let t6;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*#slots*/ ctx[70]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[84], get_content_start_slot_context_5);
	let if_block0 = /*isSortable*/ ctx[46] && /*sortable*/ ctx[16] !== false && /*isSortableOpposite*/ ctx[45] && create_if_block_128(ctx);
	let if_block1 = /*hasMedia*/ ctx[38] && create_if_block_126(ctx);
	const inner_start_slot_template = /*#slots*/ ctx[70]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_start_slot_context_5);
	const if_block_creators = [create_if_block_109, create_else_block_10];
	const if_blocks = [];

	function select_block_type_10(ctx, dirty) {
		if (/*isMedia*/ ctx[27]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_10(ctx, [-1, -1, -1, -1]);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*#slots*/ ctx[70]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_end_slot_context_5);
	const content_slot_template = /*#slots*/ ctx[70].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[84], get_content_slot_context_5);
	const content_end_slot_template = /*#slots*/ ctx[70]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[84], get_content_end_slot_context_5);

	return {
		c() {
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div0 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t3 = space();
			if_block2.c();
			t4 = space();
			if (inner_end_slot) inner_end_slot.c();
			t5 = space();
			if (content_slot) content_slot.c();
			t6 = space();
			if (content_end_slot) content_end_slot.c();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (content_start_slot) content_start_slot.l(div1_nodes);
			t0 = claim_space(div1_nodes);
			if (if_block0) if_block0.l(div1_nodes);
			t1 = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			t2 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (inner_start_slot) inner_start_slot.l(div0_nodes);
			t3 = claim_space(div0_nodes);
			if_block2.l(div0_nodes);
			t4 = claim_space(div0_nodes);
			if (inner_end_slot) inner_end_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			t5 = claim_space(div1_nodes);
			if (content_slot) content_slot.l(div1_nodes);
			t6 = claim_space(div1_nodes);
			if (content_end_slot) content_end_slot.l(div1_nodes);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "item-inner");
			attr(div1, "class", /*contentClasses*/ ctx[42]);
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_hydration(div1, t0);
			if (if_block0) if_block0.m(div1, null);
			append_hydration(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			append_hydration(div1, t2);
			append_hydration(div1, div0);

			if (inner_start_slot) {
				inner_start_slot.m(div0, null);
			}

			append_hydration(div0, t3);
			if_blocks[current_block_type_index].m(div0, null);
			append_hydration(div0, t4);

			if (inner_end_slot) {
				inner_end_slot.m(div0, null);
			}

			/*div0_binding_3*/ ctx[82](div0);
			append_hydration(div1, t5);

			if (content_slot) {
				content_slot.m(div1, null);
			}

			append_hydration(div1, t6);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div1, "click", /*onClick*/ ctx[47]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_start_slot,
						content_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[84], dirty, get_content_start_slot_changes_5),
						get_content_start_slot_context_5
					);
				}
			}

			if (/*isSortable*/ ctx[46] && /*sortable*/ ctx[16] !== false && /*isSortableOpposite*/ ctx[45]) {
				if (if_block0) {
					
				} else {
					if_block0 = create_if_block_128(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*hasMedia*/ ctx[38]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_126(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_start_slot,
						inner_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_start_slot_changes_5),
						get_inner_start_slot_context_5
					);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_10(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(div0, t4);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_end_slot,
						inner_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_end_slot_changes_5),
						get_inner_end_slot_context_5
					);
				}
			}

			if (content_slot) {
				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_slot,
						content_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[84], dirty, get_content_slot_changes_5),
						get_content_slot_context_5
					);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_end_slot,
						content_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[84], dirty, get_content_end_slot_changes_5),
						get_content_end_slot_context_5
					);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2048) {
				attr(div1, "class", /*contentClasses*/ ctx[42]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div0_binding_3*/ ctx[82](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

// (845:6) {#if checkbox || radio}
function create_if_block_88(ctx) {
	let label;
	let t0;
	let t1;
	let input;
	let input_value_value;
	let input_type_value;
	let t2;
	let i;
	let i_class_value;
	let t3;
	let t4;
	let div;
	let t5;
	let current_block_type_index;
	let if_block2;
	let t6;
	let t7;
	let t8;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*#slots*/ ctx[70]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[84], get_content_start_slot_context_4);
	let if_block0 = /*isSortable*/ ctx[46] && /*sortable*/ ctx[16] !== false && /*isSortableOpposite*/ ctx[45] && create_if_block_108(ctx);
	let if_block1 = /*hasMedia*/ ctx[38] && create_if_block_106(ctx);
	const inner_start_slot_template = /*#slots*/ ctx[70]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_start_slot_context_4);
	const if_block_creators = [create_if_block_89, create_else_block_8];
	const if_blocks = [];

	function select_block_type_9(ctx, dirty) {
		if (/*isMedia*/ ctx[27]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_9(ctx, [-1, -1, -1, -1]);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*#slots*/ ctx[70]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_end_slot_context_4);
	const content_slot_template = /*#slots*/ ctx[70].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[84], get_content_slot_context_4);
	const content_end_slot_template = /*#slots*/ ctx[70]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[84], get_content_end_slot_context_4);

	return {
		c() {
			label = element("label");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			input = element("input");
			t2 = space();
			i = element("i");
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			div = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t5 = space();
			if_block2.c();
			t6 = space();
			if (inner_end_slot) inner_end_slot.c();
			t7 = space();
			if (content_slot) content_slot.c();
			t8 = space();
			if (content_end_slot) content_end_slot.c();
			this.h();
		},
		l(nodes) {
			label = claim_element(nodes, "LABEL", { class: true });
			var label_nodes = children(label);
			if (content_start_slot) content_start_slot.l(label_nodes);
			t0 = claim_space(label_nodes);
			if (if_block0) if_block0.l(label_nodes);
			t1 = claim_space(label_nodes);
			input = claim_element(label_nodes, "INPUT", { name: true, type: true });
			t2 = claim_space(label_nodes);
			i = claim_element(label_nodes, "I", { class: true });
			children(i).forEach(detach);
			t3 = claim_space(label_nodes);
			if (if_block1) if_block1.l(label_nodes);
			t4 = claim_space(label_nodes);
			div = claim_element(label_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (inner_start_slot) inner_start_slot.l(div_nodes);
			t5 = claim_space(div_nodes);
			if_block2.l(div_nodes);
			t6 = claim_space(div_nodes);
			if (inner_end_slot) inner_end_slot.l(div_nodes);
			div_nodes.forEach(detach);
			t7 = claim_space(label_nodes);
			if (content_slot) content_slot.l(label_nodes);
			t8 = claim_space(label_nodes);
			if (content_end_slot) content_end_slot.l(label_nodes);
			label_nodes.forEach(detach);
			this.h();
		},
		h() {
			input.value = input_value_value = typeof /*value*/ ctx[21] === 'undefined'
			? ''
			: /*value*/ ctx[21];

			attr(input, "name", /*name*/ ctx[20]);
			input.checked = /*checked*/ ctx[0];
			input.readOnly = /*readonly*/ ctx[22];
			input.disabled = /*disabled*/ ctx[24];
			input.required = /*required*/ ctx[23];
			attr(input, "type", input_type_value = /*radio*/ ctx[19] ? 'radio' : 'checkbox');
			attr(i, "class", i_class_value = `icon icon-${/*radio*/ ctx[19] ? 'radio' : 'checkbox'}`);
			attr(div, "class", "item-inner");
			attr(label, "class", /*contentClasses*/ ctx[42]);
		},
		m(target, anchor) {
			insert_hydration(target, label, anchor);

			if (content_start_slot) {
				content_start_slot.m(label, null);
			}

			append_hydration(label, t0);
			if (if_block0) if_block0.m(label, null);
			append_hydration(label, t1);
			append_hydration(label, input);
			/*input_binding_1*/ ctx[80](input);
			append_hydration(label, t2);
			append_hydration(label, i);
			append_hydration(label, t3);
			if (if_block1) if_block1.m(label, null);
			append_hydration(label, t4);
			append_hydration(label, div);

			if (inner_start_slot) {
				inner_start_slot.m(div, null);
			}

			append_hydration(div, t5);
			if_blocks[current_block_type_index].m(div, null);
			append_hydration(div, t6);

			if (inner_end_slot) {
				inner_end_slot.m(div, null);
			}

			/*div_binding_1*/ ctx[81](div);
			append_hydration(label, t7);

			if (content_slot) {
				content_slot.m(label, null);
			}

			append_hydration(label, t8);

			if (content_end_slot) {
				content_end_slot.m(label, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "change", /*onChange*/ ctx[48]),
					listen(label, "click", /*onClick*/ ctx[47])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_start_slot,
						content_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[84], dirty, get_content_start_slot_changes_4),
						get_content_start_slot_context_4
					);
				}
			}

			if (/*isSortable*/ ctx[46] && /*sortable*/ ctx[16] !== false && /*isSortableOpposite*/ ctx[45]) {
				if (if_block0) {
					
				} else {
					if_block0 = create_if_block_108(ctx);
					if_block0.c();
					if_block0.m(label, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!current || dirty[0] & /*value*/ 2097152 && input_value_value !== (input_value_value = typeof /*value*/ ctx[21] === 'undefined'
			? ''
			: /*value*/ ctx[21]) && input.value !== input_value_value) {
				input.value = input_value_value;
			}

			if (!current || dirty[0] & /*name*/ 1048576) {
				attr(input, "name", /*name*/ ctx[20]);
			}

			if (!current || dirty[0] & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (!current || dirty[0] & /*readonly*/ 4194304) {
				input.readOnly = /*readonly*/ ctx[22];
			}

			if (!current || dirty[0] & /*disabled*/ 16777216) {
				input.disabled = /*disabled*/ ctx[24];
			}

			if (!current || dirty[0] & /*required*/ 8388608) {
				input.required = /*required*/ ctx[23];
			}

			if (!current || dirty[0] & /*radio*/ 524288 && input_type_value !== (input_type_value = /*radio*/ ctx[19] ? 'radio' : 'checkbox')) {
				attr(input, "type", input_type_value);
			}

			if (!current || dirty[0] & /*radio*/ 524288 && i_class_value !== (i_class_value = `icon icon-${/*radio*/ ctx[19] ? 'radio' : 'checkbox'}`)) {
				attr(i, "class", i_class_value);
			}

			if (/*hasMedia*/ ctx[38]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_106(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(label, t4);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_start_slot,
						inner_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_start_slot_changes_4),
						get_inner_start_slot_context_4
					);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_9(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(div, t6);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_end_slot,
						inner_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_end_slot_changes_4),
						get_inner_end_slot_context_4
					);
				}
			}

			if (content_slot) {
				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_slot,
						content_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[84], dirty, get_content_slot_changes_4),
						get_content_slot_context_4
					);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_end_slot,
						content_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[84], dirty, get_content_end_slot_changes_4),
						get_content_end_slot_context_4
					);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2048) {
				attr(label, "class", /*contentClasses*/ ctx[42]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			/*input_binding_1*/ ctx[80](null);
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div_binding_1*/ ctx[81](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (972:10) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_128(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "sortable-handler");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (975:10) {#if hasMedia}
function create_if_block_126(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[4] !== 'undefined' && create_if_block_127(ctx);
	const media_slot_template = /*#slots*/ ctx[70].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[84], get_media_slot_context_5);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			if (media_slot) media_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-media");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (typeof /*media*/ ctx[4] !== 'undefined') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_127(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						media_slot,
						media_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[84], dirty, get_media_slot_changes_5),
						get_media_slot_context_5
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};
}

// (977:14) {#if typeof media !== 'undefined'}
function create_if_block_127(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			this.h();
		},
		l(nodes) {
			img = claim_element(nodes, "IMG", { src: true });
			this.h();
		},
		h() {
			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[4])) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert_hydration(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*media*/ 16 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[4])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (1037:12) {:else}
function create_else_block_10(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*#slots*/ ctx[70]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[84], get_before_title_slot_context_11);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[36] || /*hasFooter*/ ctx[35]) && create_if_block_123(ctx);
	const after_title_slot_template = /*#slots*/ ctx[70]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[84], get_after_title_slot_context_11);
	let if_block1 = /*hasAfter*/ ctx[32] && create_if_block_120(ctx);
	const inner_slot_template = /*#slots*/ ctx[70].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_slot_context_11);
	let if_block2 = !(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17]) && create_if_block_119(ctx);

	return {
		c() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		l(nodes) {
			if (before_title_slot) before_title_slot.l(nodes);
			t0 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t1 = claim_space(nodes);
			if (after_title_slot) after_title_slot.l(nodes);
			t2 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t3 = claim_space(nodes);
			if (inner_slot) inner_slot.l(nodes);
			t4 = claim_space(nodes);
			if (if_block2) if_block2.l(nodes);
			if_block2_anchor = empty();
		},
		m(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_hydration(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_hydration(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_hydration(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_hydration(target, if_block2_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						before_title_slot,
						before_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[84], dirty, get_before_title_slot_changes_11),
						get_before_title_slot_context_11
					);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[36] || /*hasFooter*/ ctx[35]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 112) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_123(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_title_slot,
						after_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[84], dirty, get_after_title_slot_changes_11),
						get_after_title_slot_context_11
					);
				}
			}

			if (/*hasAfter*/ ctx[32]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_120(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_slot,
						inner_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_slot_changes_11),
						get_inner_slot_context_11
					);
				}
			}

			if (!(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 163840) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_119(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(if_block2_anchor);
		}
	};
}

// (985:12) {#if isMedia}
function create_if_block_109(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[36] && create_if_block_118(ctx);
	const before_title_slot_template = /*#slots*/ ctx[70]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[84], get_before_title_slot_context_10);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_117(ctx);
	const after_title_slot_template = /*#slots*/ ctx[70]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[84], get_after_title_slot_context_10);
	let if_block2 = /*hasAfter*/ ctx[32] && create_if_block_114(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[34] && create_if_block_113(ctx);
	let if_block4 = /*hasText*/ ctx[33] && create_if_block_112(ctx);
	const inner_slot_template = /*#slots*/ ctx[70].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_slot_context_10);
	let if_block5 = !(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17]) && create_if_block_111(ctx);
	let if_block6 = /*hasFooter*/ ctx[35] && create_if_block_110(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty();
			this.h();
		},
		l(nodes) {
			if (if_block0) if_block0.l(nodes);
			t0 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (before_title_slot) before_title_slot.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_title_slot) after_title_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block2) if_block2.l(div_nodes);
			div_nodes.forEach(detach);
			t4 = claim_space(nodes);
			if (if_block3) if_block3.l(nodes);
			t5 = claim_space(nodes);
			if (if_block4) if_block4.l(nodes);
			t6 = claim_space(nodes);
			if (inner_slot) inner_slot.l(nodes);
			t7 = claim_space(nodes);
			if (if_block5) if_block5.l(nodes);
			t8 = claim_space(nodes);
			if (if_block6) if_block6.l(nodes);
			if_block6_anchor = empty();
			this.h();
		},
		h() {
			attr(div, "class", "item-title-row");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration(target, t0, anchor);
			insert_hydration(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_hydration(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_hydration(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_hydration(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_hydration(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_hydration(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_hydration(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_hydration(target, if_block6_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*hasHeader*/ ctx[36]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_118(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						before_title_slot,
						before_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[84], dirty, get_before_title_slot_changes_10),
						get_before_title_slot_context_10
					);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_117(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_title_slot,
						after_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[84], dirty, get_after_title_slot_changes_10),
						get_after_title_slot_context_10
					);
				}
			}

			if (/*hasAfter*/ ctx[32]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_114(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[34]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 8) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_113(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[33]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 4) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_112(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_slot,
						inner_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_slot_changes_10),
						get_inner_slot_context_10
					);
				}
			}

			if (!(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 163840) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_111(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[35]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 16) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_110(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach(if_block6_anchor);
		}
	};
}

// (1039:14) {#if hasTitle || hasHeader || hasFooter}
function create_if_block_123(ctx) {
	let div;
	let t0;
	let t1_value = plainText(/*title*/ ctx[2]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[36] && create_if_block_125(ctx);
	const title_slot_template = /*#slots*/ ctx[70].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[84], get_title_slot_context_11);
	let if_block1 = /*hasFooter*/ ctx[35] && create_if_block_124(ctx);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			t1 = claim_text(div_nodes, t1_value);
			t2 = claim_space(div_nodes);
			if (title_slot) title_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-title");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t0);
			append_hydration(div, t1);
			append_hydration(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_hydration(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*hasHeader*/ ctx[36]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_125(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 4) && t1_value !== (t1_value = plainText(/*title*/ ctx[2]) + "")) set_data(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[84], dirty, get_title_slot_changes_11),
						get_title_slot_context_11
					);
				}
			}

			if (/*hasFooter*/ ctx[35]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 16) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_124(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};
}

// (1041:18) {#if hasHeader}
function create_if_block_125(ctx) {
	let div;
	let t0_value = plainText(/*header*/ ctx[6]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[70].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[84], get_header_slot_context_11);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (header_slot) header_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-header");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = plainText(/*header*/ ctx[6]) + "")) set_data(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[84], dirty, get_header_slot_changes_11),
						get_header_slot_context_11
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (1049:18) {#if hasFooter}
function create_if_block_124(ctx) {
	let div;
	let t0_value = plainText(/*footer*/ ctx[7]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[70].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[84], get_footer_slot_context_11);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (footer_slot) footer_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-footer");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = plainText(/*footer*/ ctx[7]) + "")) set_data(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[84], dirty, get_footer_slot_changes_11),
						get_footer_slot_context_11
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};
}

// (1058:14) {#if hasAfter}
function create_if_block_120(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[70]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[84], get_after_start_slot_context_11);
	let if_block0 = typeof /*after*/ ctx[10] !== 'undefined' && create_if_block_122(ctx);
	let if_block1 = typeof /*badge*/ ctx[11] !== 'undefined' && create_if_block_121(ctx);
	const after_slot_template = /*#slots*/ ctx[70].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[84], get_after_slot_context_11);
	const after_end_slot_template = /*#slots*/ ctx[70]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[84], get_after_end_slot_context_11);

	return {
		c() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (after_start_slot) after_start_slot.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_slot) after_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (after_end_slot) after_end_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-after");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_hydration(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_hydration(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_start_slot,
						after_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[84], dirty, get_after_start_slot_changes_11),
						get_after_start_slot_context_11
					);
				}
			}

			if (typeof /*after*/ ctx[10] !== 'undefined') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_122(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[11] !== 'undefined') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_121(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_slot,
						after_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[84], dirty, get_after_slot_changes_11),
						get_after_slot_context_11
					);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_end_slot,
						after_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[84], dirty, get_after_end_slot_changes_11),
						get_after_end_slot_context_11
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};
}

// (1061:18) {#if typeof after !== 'undefined'}
function create_if_block_122(ctx) {
	let span;
	let t_value = plainText(/*after*/ ctx[10]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*after*/ 1024 && t_value !== (t_value = plainText(/*after*/ ctx[10]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (1064:18) {#if typeof badge !== 'undefined'}
function create_if_block_121(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[12],
				lec: /*lec*/ ctx[1],
				$$slots: { default: [create_default_slot_11] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(badge_1.$$.fragment);
		},
		l(nodes) {
			claim_component(badge_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 4096) badge_1_changes.color = /*badgeColor*/ ctx[12];
			if (dirty[0] & /*lec*/ 2) badge_1_changes.lec = /*lec*/ ctx[1];

			if (dirty[0] & /*badge*/ 2048 | dirty[2] & /*$$scope*/ 4194304) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(badge_1, detaching);
		}
	};
}

// (1065:20) <Badge  color={badgeColor}     lec={lec} >
function create_default_slot_11(ctx) {
	let t_value = plainText(/*badge*/ ctx[11]) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*badge*/ 2048 && t_value !== (t_value = plainText(/*badge*/ ctx[11]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (1072:14) {#if !(swipeout || accordionItem)}
function create_if_block_119(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[70].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[84], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[84], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (986:14) {#if hasHeader}
function create_if_block_118(ctx) {
	let div;
	let t0_value = plainText(/*header*/ ctx[6]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[70].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[84], get_header_slot_context_10);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (header_slot) header_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-header");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = plainText(/*header*/ ctx[6]) + "")) set_data(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[84], dirty, get_header_slot_changes_10),
						get_header_slot_context_10
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (994:16) {#if hasTitle}
function create_if_block_117(ctx) {
	let div;
	let t0_value = plainText(/*title*/ ctx[2]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*#slots*/ ctx[70].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[84], get_title_slot_context_10);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (title_slot) title_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-title");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 4) && t0_value !== (t0_value = plainText(/*title*/ ctx[2]) + "")) set_data(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[84], dirty, get_title_slot_changes_10),
						get_title_slot_context_10
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (title_slot) title_slot.d(detaching);
		}
	};
}

// (1001:16) {#if hasAfter}
function create_if_block_114(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[70]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[84], get_after_start_slot_context_10);
	let if_block0 = typeof /*after*/ ctx[10] !== 'undefined' && create_if_block_116(ctx);
	let if_block1 = typeof /*badge*/ ctx[11] !== 'undefined' && create_if_block_115(ctx);
	const after_slot_template = /*#slots*/ ctx[70].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[84], get_after_slot_context_10);
	const after_end_slot_template = /*#slots*/ ctx[70]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[84], get_after_end_slot_context_10);

	return {
		c() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (after_start_slot) after_start_slot.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_slot) after_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (after_end_slot) after_end_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-after");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_hydration(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_hydration(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_start_slot,
						after_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[84], dirty, get_after_start_slot_changes_10),
						get_after_start_slot_context_10
					);
				}
			}

			if (typeof /*after*/ ctx[10] !== 'undefined') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_116(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[11] !== 'undefined') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_115(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_slot,
						after_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[84], dirty, get_after_slot_changes_10),
						get_after_slot_context_10
					);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_end_slot,
						after_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[84], dirty, get_after_end_slot_changes_10),
						get_after_end_slot_context_10
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};
}

// (1004:20) {#if typeof after !== 'undefined'}
function create_if_block_116(ctx) {
	let span;
	let t_value = plainText(/*after*/ ctx[10]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*after*/ 1024 && t_value !== (t_value = plainText(/*after*/ ctx[10]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (1007:20) {#if typeof badge !== 'undefined'}
function create_if_block_115(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[12],
				lec: /*lec*/ ctx[1],
				$$slots: { default: [create_default_slot_10$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(badge_1.$$.fragment);
		},
		l(nodes) {
			claim_component(badge_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 4096) badge_1_changes.color = /*badgeColor*/ ctx[12];
			if (dirty[0] & /*lec*/ 2) badge_1_changes.lec = /*lec*/ ctx[1];

			if (dirty[0] & /*badge*/ 2048 | dirty[2] & /*$$scope*/ 4194304) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(badge_1, detaching);
		}
	};
}

// (1008:22) <Badge  color={badgeColor}     lec={lec} >
function create_default_slot_10$1(ctx) {
	let t_value = plainText(/*badge*/ ctx[11]) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*badge*/ 2048 && t_value !== (t_value = plainText(/*badge*/ ctx[11]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (1015:14) {#if hasSubtitle}
function create_if_block_113(ctx) {
	let div;
	let t0_value = plainText(/*subtitle*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*#slots*/ ctx[70].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[84], get_subtitle_slot_context_5);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (subtitle_slot) subtitle_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-subtitle");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 32) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[5]) + "")) set_data(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						subtitle_slot,
						subtitle_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[84], dirty, get_subtitle_slot_changes_5),
						get_subtitle_slot_context_5
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};
}

// (1021:14) {#if hasText}
function create_if_block_112(ctx) {
	let div;
	let t0_value = plainText(/*text*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*#slots*/ ctx[70].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[84], get_text_slot_context_5);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (text_slot) text_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-text");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 8) && t0_value !== (t0_value = plainText(/*text*/ ctx[3]) + "")) set_data(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						text_slot,
						text_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[84], dirty, get_text_slot_changes_5),
						get_text_slot_context_5
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (text_slot) text_slot.d(detaching);
		}
	};
}

// (1028:14) {#if !(swipeout || accordionItem)}
function create_if_block_111(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[70].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[84], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[84], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (1031:14) {#if hasFooter}
function create_if_block_110(ctx) {
	let div;
	let t0_value = plainText(/*footer*/ ctx[7]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[70].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[84], get_footer_slot_context_10);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (footer_slot) footer_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-footer");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = plainText(/*footer*/ ctx[7]) + "")) set_data(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[84], dirty, get_footer_slot_changes_10),
						get_footer_slot_context_10
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};
}

// (848:10) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_108(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "sortable-handler");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (863:10) {#if hasMedia}
function create_if_block_106(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[4] !== 'undefined' && create_if_block_107(ctx);
	const media_slot_template = /*#slots*/ ctx[70].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[84], get_media_slot_context_4);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			if (media_slot) media_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-media");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (typeof /*media*/ ctx[4] !== 'undefined') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_107(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						media_slot,
						media_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[84], dirty, get_media_slot_changes_4),
						get_media_slot_context_4
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};
}

// (865:14) {#if typeof media !== 'undefined'}
function create_if_block_107(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			this.h();
		},
		l(nodes) {
			img = claim_element(nodes, "IMG", { src: true });
			this.h();
		},
		h() {
			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[4])) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert_hydration(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*media*/ 16 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[4])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (925:12) {:else}
function create_else_block_8(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*#slots*/ ctx[70]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[84], get_before_title_slot_context_9);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[36] || /*hasFooter*/ ctx[35]) && create_if_block_103(ctx);
	const after_title_slot_template = /*#slots*/ ctx[70]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[84], get_after_title_slot_context_9);
	let if_block1 = /*hasAfter*/ ctx[32] && create_if_block_100(ctx);
	const inner_slot_template = /*#slots*/ ctx[70].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_slot_context_9);
	let if_block2 = !(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17]) && create_if_block_99(ctx);

	return {
		c() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		l(nodes) {
			if (before_title_slot) before_title_slot.l(nodes);
			t0 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t1 = claim_space(nodes);
			if (after_title_slot) after_title_slot.l(nodes);
			t2 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t3 = claim_space(nodes);
			if (inner_slot) inner_slot.l(nodes);
			t4 = claim_space(nodes);
			if (if_block2) if_block2.l(nodes);
			if_block2_anchor = empty();
		},
		m(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_hydration(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_hydration(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_hydration(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_hydration(target, if_block2_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						before_title_slot,
						before_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[84], dirty, get_before_title_slot_changes_9),
						get_before_title_slot_context_9
					);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[36] || /*hasFooter*/ ctx[35]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 112) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_103(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_title_slot,
						after_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[84], dirty, get_after_title_slot_changes_9),
						get_after_title_slot_context_9
					);
				}
			}

			if (/*hasAfter*/ ctx[32]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_100(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_slot,
						inner_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_slot_changes_9),
						get_inner_slot_context_9
					);
				}
			}

			if (!(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 163840) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_99(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(if_block2_anchor);
		}
	};
}

// (873:12) {#if isMedia}
function create_if_block_89(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[36] && create_if_block_98(ctx);
	const before_title_slot_template = /*#slots*/ ctx[70]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[84], get_before_title_slot_context_8);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_97(ctx);
	const after_title_slot_template = /*#slots*/ ctx[70]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[84], get_after_title_slot_context_8);
	let if_block2 = /*hasAfter*/ ctx[32] && create_if_block_94(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[34] && create_if_block_93(ctx);
	let if_block4 = /*hasText*/ ctx[33] && create_if_block_92(ctx);
	const inner_slot_template = /*#slots*/ ctx[70].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_slot_context_8);
	let if_block5 = !(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17]) && create_if_block_91(ctx);
	let if_block6 = /*hasFooter*/ ctx[35] && create_if_block_90(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty();
			this.h();
		},
		l(nodes) {
			if (if_block0) if_block0.l(nodes);
			t0 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (before_title_slot) before_title_slot.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_title_slot) after_title_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block2) if_block2.l(div_nodes);
			div_nodes.forEach(detach);
			t4 = claim_space(nodes);
			if (if_block3) if_block3.l(nodes);
			t5 = claim_space(nodes);
			if (if_block4) if_block4.l(nodes);
			t6 = claim_space(nodes);
			if (inner_slot) inner_slot.l(nodes);
			t7 = claim_space(nodes);
			if (if_block5) if_block5.l(nodes);
			t8 = claim_space(nodes);
			if (if_block6) if_block6.l(nodes);
			if_block6_anchor = empty();
			this.h();
		},
		h() {
			attr(div, "class", "item-title-row");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration(target, t0, anchor);
			insert_hydration(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_hydration(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_hydration(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_hydration(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_hydration(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_hydration(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_hydration(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_hydration(target, if_block6_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*hasHeader*/ ctx[36]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_98(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						before_title_slot,
						before_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[84], dirty, get_before_title_slot_changes_8),
						get_before_title_slot_context_8
					);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_97(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_title_slot,
						after_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[84], dirty, get_after_title_slot_changes_8),
						get_after_title_slot_context_8
					);
				}
			}

			if (/*hasAfter*/ ctx[32]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_94(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[34]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 8) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_93(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[33]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 4) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_92(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_slot,
						inner_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_slot_changes_8),
						get_inner_slot_context_8
					);
				}
			}

			if (!(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 163840) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_91(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[35]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 16) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_90(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach(if_block6_anchor);
		}
	};
}

// (927:14) {#if hasTitle || hasHeader || hasFooter}
function create_if_block_103(ctx) {
	let div;
	let t0;
	let t1_value = plainText(/*title*/ ctx[2]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[36] && create_if_block_105(ctx);
	const title_slot_template = /*#slots*/ ctx[70].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[84], get_title_slot_context_9);
	let if_block1 = /*hasFooter*/ ctx[35] && create_if_block_104(ctx);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			t1 = claim_text(div_nodes, t1_value);
			t2 = claim_space(div_nodes);
			if (title_slot) title_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-title");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t0);
			append_hydration(div, t1);
			append_hydration(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_hydration(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*hasHeader*/ ctx[36]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_105(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 4) && t1_value !== (t1_value = plainText(/*title*/ ctx[2]) + "")) set_data(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[84], dirty, get_title_slot_changes_9),
						get_title_slot_context_9
					);
				}
			}

			if (/*hasFooter*/ ctx[35]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 16) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_104(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};
}

// (929:18) {#if hasHeader}
function create_if_block_105(ctx) {
	let div;
	let t0_value = plainText(/*header*/ ctx[6]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[70].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[84], get_header_slot_context_9);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (header_slot) header_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-header");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = plainText(/*header*/ ctx[6]) + "")) set_data(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[84], dirty, get_header_slot_changes_9),
						get_header_slot_context_9
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (937:18) {#if hasFooter}
function create_if_block_104(ctx) {
	let div;
	let t0_value = plainText(/*footer*/ ctx[7]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[70].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[84], get_footer_slot_context_9);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (footer_slot) footer_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-footer");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = plainText(/*footer*/ ctx[7]) + "")) set_data(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[84], dirty, get_footer_slot_changes_9),
						get_footer_slot_context_9
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};
}

// (946:14) {#if hasAfter}
function create_if_block_100(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[70]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[84], get_after_start_slot_context_9);
	let if_block0 = typeof /*after*/ ctx[10] !== 'undefined' && create_if_block_102(ctx);
	let if_block1 = typeof /*badge*/ ctx[11] !== 'undefined' && create_if_block_101(ctx);
	const after_slot_template = /*#slots*/ ctx[70].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[84], get_after_slot_context_9);
	const after_end_slot_template = /*#slots*/ ctx[70]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[84], get_after_end_slot_context_9);

	return {
		c() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (after_start_slot) after_start_slot.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_slot) after_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (after_end_slot) after_end_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-after");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_hydration(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_hydration(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_start_slot,
						after_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[84], dirty, get_after_start_slot_changes_9),
						get_after_start_slot_context_9
					);
				}
			}

			if (typeof /*after*/ ctx[10] !== 'undefined') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_102(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[11] !== 'undefined') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_101(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_slot,
						after_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[84], dirty, get_after_slot_changes_9),
						get_after_slot_context_9
					);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_end_slot,
						after_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[84], dirty, get_after_end_slot_changes_9),
						get_after_end_slot_context_9
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};
}

// (949:18) {#if typeof after !== 'undefined'}
function create_if_block_102(ctx) {
	let span;
	let t_value = plainText(/*after*/ ctx[10]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*after*/ 1024 && t_value !== (t_value = plainText(/*after*/ ctx[10]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (952:18) {#if typeof badge !== 'undefined'}
function create_if_block_101(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[12],
				lec: /*lec*/ ctx[1],
				$$slots: { default: [create_default_slot_9$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(badge_1.$$.fragment);
		},
		l(nodes) {
			claim_component(badge_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 4096) badge_1_changes.color = /*badgeColor*/ ctx[12];
			if (dirty[0] & /*lec*/ 2) badge_1_changes.lec = /*lec*/ ctx[1];

			if (dirty[0] & /*badge*/ 2048 | dirty[2] & /*$$scope*/ 4194304) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(badge_1, detaching);
		}
	};
}

// (953:20) <Badge  color={badgeColor}     lec={lec} >
function create_default_slot_9$1(ctx) {
	let t_value = plainText(/*badge*/ ctx[11]) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*badge*/ 2048 && t_value !== (t_value = plainText(/*badge*/ ctx[11]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (960:14) {#if !(swipeout || accordionItem)}
function create_if_block_99(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[70].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[84], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[84], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (874:14) {#if hasHeader}
function create_if_block_98(ctx) {
	let div;
	let t0_value = plainText(/*header*/ ctx[6]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[70].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[84], get_header_slot_context_8);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (header_slot) header_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-header");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = plainText(/*header*/ ctx[6]) + "")) set_data(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[84], dirty, get_header_slot_changes_8),
						get_header_slot_context_8
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (882:16) {#if hasTitle}
function create_if_block_97(ctx) {
	let div;
	let t0_value = plainText(/*title*/ ctx[2]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*#slots*/ ctx[70].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[84], get_title_slot_context_8);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (title_slot) title_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-title");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 4) && t0_value !== (t0_value = plainText(/*title*/ ctx[2]) + "")) set_data(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[84], dirty, get_title_slot_changes_8),
						get_title_slot_context_8
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (title_slot) title_slot.d(detaching);
		}
	};
}

// (889:16) {#if hasAfter}
function create_if_block_94(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[70]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[84], get_after_start_slot_context_8);
	let if_block0 = typeof /*after*/ ctx[10] !== 'undefined' && create_if_block_96(ctx);
	let if_block1 = typeof /*badge*/ ctx[11] !== 'undefined' && create_if_block_95(ctx);
	const after_slot_template = /*#slots*/ ctx[70].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[84], get_after_slot_context_8);
	const after_end_slot_template = /*#slots*/ ctx[70]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[84], get_after_end_slot_context_8);

	return {
		c() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (after_start_slot) after_start_slot.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_slot) after_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (after_end_slot) after_end_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-after");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_hydration(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_hydration(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_start_slot,
						after_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[84], dirty, get_after_start_slot_changes_8),
						get_after_start_slot_context_8
					);
				}
			}

			if (typeof /*after*/ ctx[10] !== 'undefined') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_96(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[11] !== 'undefined') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_95(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_slot,
						after_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[84], dirty, get_after_slot_changes_8),
						get_after_slot_context_8
					);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_end_slot,
						after_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[84], dirty, get_after_end_slot_changes_8),
						get_after_end_slot_context_8
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};
}

// (892:20) {#if typeof after !== 'undefined'}
function create_if_block_96(ctx) {
	let span;
	let t_value = plainText(/*after*/ ctx[10]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*after*/ 1024 && t_value !== (t_value = plainText(/*after*/ ctx[10]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (895:20) {#if typeof badge !== 'undefined'}
function create_if_block_95(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[12],
				lec: /*lec*/ ctx[1],
				$$slots: { default: [create_default_slot_8$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(badge_1.$$.fragment);
		},
		l(nodes) {
			claim_component(badge_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 4096) badge_1_changes.color = /*badgeColor*/ ctx[12];
			if (dirty[0] & /*lec*/ 2) badge_1_changes.lec = /*lec*/ ctx[1];

			if (dirty[0] & /*badge*/ 2048 | dirty[2] & /*$$scope*/ 4194304) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(badge_1, detaching);
		}
	};
}

// (896:22) <Badge  color={badgeColor}     lec={lec} >
function create_default_slot_8$1(ctx) {
	let t_value = plainText(/*badge*/ ctx[11]) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*badge*/ 2048 && t_value !== (t_value = plainText(/*badge*/ ctx[11]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (903:14) {#if hasSubtitle}
function create_if_block_93(ctx) {
	let div;
	let t0_value = plainText(/*subtitle*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*#slots*/ ctx[70].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[84], get_subtitle_slot_context_4);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (subtitle_slot) subtitle_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-subtitle");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 32) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[5]) + "")) set_data(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						subtitle_slot,
						subtitle_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[84], dirty, get_subtitle_slot_changes_4),
						get_subtitle_slot_context_4
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};
}

// (909:14) {#if hasText}
function create_if_block_92(ctx) {
	let div;
	let t0_value = plainText(/*text*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*#slots*/ ctx[70].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[84], get_text_slot_context_4);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (text_slot) text_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-text");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 8) && t0_value !== (t0_value = plainText(/*text*/ ctx[3]) + "")) set_data(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						text_slot,
						text_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[84], dirty, get_text_slot_changes_4),
						get_text_slot_context_4
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (text_slot) text_slot.d(detaching);
		}
	};
}

// (916:14) {#if !(swipeout || accordionItem)}
function create_if_block_91(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[70].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[84], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[84], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (919:14) {#if hasFooter}
function create_if_block_90(ctx) {
	let div;
	let t0_value = plainText(/*footer*/ ctx[7]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[70].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[84], get_footer_slot_context_8);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (footer_slot) footer_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-footer");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = plainText(/*footer*/ ctx[7]) + "")) set_data(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[84], dirty, get_footer_slot_changes_8),
						get_footer_slot_context_8
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};
}

// (732:10) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_87(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "sortable-handler");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (735:10) {#if hasMedia}
function create_if_block_85(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[4] !== 'undefined' && create_if_block_86(ctx);
	const media_slot_template = /*#slots*/ ctx[70].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[84], get_media_slot_context_3);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			if (media_slot) media_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-media");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (typeof /*media*/ ctx[4] !== 'undefined') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_86(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						media_slot,
						media_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[84], dirty, get_media_slot_changes_3),
						get_media_slot_context_3
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};
}

// (737:14) {#if typeof media !== 'undefined'}
function create_if_block_86(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			this.h();
		},
		l(nodes) {
			img = claim_element(nodes, "IMG", { src: true });
			this.h();
		},
		h() {
			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[4])) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert_hydration(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*media*/ 16 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[4])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (797:12) {:else}
function create_else_block_6(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*#slots*/ ctx[70]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[84], get_before_title_slot_context_7);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[36] || /*hasFooter*/ ctx[35]) && create_if_block_82(ctx);
	const after_title_slot_template = /*#slots*/ ctx[70]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[84], get_after_title_slot_context_7);
	let if_block1 = /*hasAfter*/ ctx[32] && create_if_block_79(ctx);
	const inner_slot_template = /*#slots*/ ctx[70].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_slot_context_7);
	let if_block2 = !(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17]) && create_if_block_78(ctx);

	return {
		c() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		l(nodes) {
			if (before_title_slot) before_title_slot.l(nodes);
			t0 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t1 = claim_space(nodes);
			if (after_title_slot) after_title_slot.l(nodes);
			t2 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t3 = claim_space(nodes);
			if (inner_slot) inner_slot.l(nodes);
			t4 = claim_space(nodes);
			if (if_block2) if_block2.l(nodes);
			if_block2_anchor = empty();
		},
		m(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_hydration(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_hydration(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_hydration(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_hydration(target, if_block2_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						before_title_slot,
						before_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[84], dirty, get_before_title_slot_changes_7),
						get_before_title_slot_context_7
					);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[36] || /*hasFooter*/ ctx[35]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 112) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_82(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_title_slot,
						after_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[84], dirty, get_after_title_slot_changes_7),
						get_after_title_slot_context_7
					);
				}
			}

			if (/*hasAfter*/ ctx[32]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_79(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_slot,
						inner_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_slot_changes_7),
						get_inner_slot_context_7
					);
				}
			}

			if (!(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 163840) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_78(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(if_block2_anchor);
		}
	};
}

// (745:12) {#if isMedia}
function create_if_block_68(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[36] && create_if_block_77(ctx);
	const before_title_slot_template = /*#slots*/ ctx[70]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[84], get_before_title_slot_context_6);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_76(ctx);
	const after_title_slot_template = /*#slots*/ ctx[70]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[84], get_after_title_slot_context_6);
	let if_block2 = /*hasAfter*/ ctx[32] && create_if_block_73(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[34] && create_if_block_72(ctx);
	let if_block4 = /*hasText*/ ctx[33] && create_if_block_71(ctx);
	const inner_slot_template = /*#slots*/ ctx[70].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_slot_context_6);
	let if_block5 = !(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17]) && create_if_block_70(ctx);
	let if_block6 = /*hasFooter*/ ctx[35] && create_if_block_69(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty();
			this.h();
		},
		l(nodes) {
			if (if_block0) if_block0.l(nodes);
			t0 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (before_title_slot) before_title_slot.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_title_slot) after_title_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block2) if_block2.l(div_nodes);
			div_nodes.forEach(detach);
			t4 = claim_space(nodes);
			if (if_block3) if_block3.l(nodes);
			t5 = claim_space(nodes);
			if (if_block4) if_block4.l(nodes);
			t6 = claim_space(nodes);
			if (inner_slot) inner_slot.l(nodes);
			t7 = claim_space(nodes);
			if (if_block5) if_block5.l(nodes);
			t8 = claim_space(nodes);
			if (if_block6) if_block6.l(nodes);
			if_block6_anchor = empty();
			this.h();
		},
		h() {
			attr(div, "class", "item-title-row");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration(target, t0, anchor);
			insert_hydration(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_hydration(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_hydration(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_hydration(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_hydration(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_hydration(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_hydration(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_hydration(target, if_block6_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*hasHeader*/ ctx[36]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_77(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						before_title_slot,
						before_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[84], dirty, get_before_title_slot_changes_6),
						get_before_title_slot_context_6
					);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_76(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_title_slot,
						after_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[84], dirty, get_after_title_slot_changes_6),
						get_after_title_slot_context_6
					);
				}
			}

			if (/*hasAfter*/ ctx[32]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_73(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[34]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 8) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_72(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[33]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 4) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_71(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_slot,
						inner_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_slot_changes_6),
						get_inner_slot_context_6
					);
				}
			}

			if (!(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 163840) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_70(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[35]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 16) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_69(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach(if_block6_anchor);
		}
	};
}

// (799:14) {#if hasTitle || hasHeader || hasFooter}
function create_if_block_82(ctx) {
	let div;
	let t0;
	let t1_value = plainText(/*title*/ ctx[2]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[36] && create_if_block_84(ctx);
	const title_slot_template = /*#slots*/ ctx[70].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[84], get_title_slot_context_7);
	let if_block1 = /*hasFooter*/ ctx[35] && create_if_block_83(ctx);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			t1 = claim_text(div_nodes, t1_value);
			t2 = claim_space(div_nodes);
			if (title_slot) title_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-title");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t0);
			append_hydration(div, t1);
			append_hydration(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_hydration(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*hasHeader*/ ctx[36]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_84(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 4) && t1_value !== (t1_value = plainText(/*title*/ ctx[2]) + "")) set_data(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[84], dirty, get_title_slot_changes_7),
						get_title_slot_context_7
					);
				}
			}

			if (/*hasFooter*/ ctx[35]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 16) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_83(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};
}

// (801:18) {#if hasHeader}
function create_if_block_84(ctx) {
	let div;
	let t0_value = plainText(/*header*/ ctx[6]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[70].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[84], get_header_slot_context_7);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (header_slot) header_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-header");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = plainText(/*header*/ ctx[6]) + "")) set_data(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[84], dirty, get_header_slot_changes_7),
						get_header_slot_context_7
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (809:18) {#if hasFooter}
function create_if_block_83(ctx) {
	let div;
	let t0_value = plainText(/*footer*/ ctx[7]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[70].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[84], get_footer_slot_context_7);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (footer_slot) footer_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-footer");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = plainText(/*footer*/ ctx[7]) + "")) set_data(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[84], dirty, get_footer_slot_changes_7),
						get_footer_slot_context_7
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};
}

// (818:14) {#if hasAfter}
function create_if_block_79(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[70]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[84], get_after_start_slot_context_7);
	let if_block0 = typeof /*after*/ ctx[10] !== 'undefined' && create_if_block_81(ctx);
	let if_block1 = typeof /*badge*/ ctx[11] !== 'undefined' && create_if_block_80(ctx);
	const after_slot_template = /*#slots*/ ctx[70].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[84], get_after_slot_context_7);
	const after_end_slot_template = /*#slots*/ ctx[70]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[84], get_after_end_slot_context_7);

	return {
		c() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (after_start_slot) after_start_slot.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_slot) after_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (after_end_slot) after_end_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-after");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_hydration(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_hydration(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_start_slot,
						after_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[84], dirty, get_after_start_slot_changes_7),
						get_after_start_slot_context_7
					);
				}
			}

			if (typeof /*after*/ ctx[10] !== 'undefined') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_81(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[11] !== 'undefined') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_80(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_slot,
						after_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[84], dirty, get_after_slot_changes_7),
						get_after_slot_context_7
					);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_end_slot,
						after_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[84], dirty, get_after_end_slot_changes_7),
						get_after_end_slot_context_7
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};
}

// (821:18) {#if typeof after !== 'undefined'}
function create_if_block_81(ctx) {
	let span;
	let t_value = plainText(/*after*/ ctx[10]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*after*/ 1024 && t_value !== (t_value = plainText(/*after*/ ctx[10]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (824:18) {#if typeof badge !== 'undefined'}
function create_if_block_80(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[12],
				lec: /*lec*/ ctx[1],
				$$slots: { default: [create_default_slot_7$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(badge_1.$$.fragment);
		},
		l(nodes) {
			claim_component(badge_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 4096) badge_1_changes.color = /*badgeColor*/ ctx[12];
			if (dirty[0] & /*lec*/ 2) badge_1_changes.lec = /*lec*/ ctx[1];

			if (dirty[0] & /*badge*/ 2048 | dirty[2] & /*$$scope*/ 4194304) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(badge_1, detaching);
		}
	};
}

// (825:20) <Badge  color={badgeColor}     lec={lec} >
function create_default_slot_7$1(ctx) {
	let t_value = plainText(/*badge*/ ctx[11]) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*badge*/ 2048 && t_value !== (t_value = plainText(/*badge*/ ctx[11]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (832:14) {#if !(swipeout || accordionItem)}
function create_if_block_78(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[70].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[84], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[84], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (746:14) {#if hasHeader}
function create_if_block_77(ctx) {
	let div;
	let t0_value = plainText(/*header*/ ctx[6]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[70].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[84], get_header_slot_context_6);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (header_slot) header_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-header");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = plainText(/*header*/ ctx[6]) + "")) set_data(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[84], dirty, get_header_slot_changes_6),
						get_header_slot_context_6
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (754:16) {#if hasTitle}
function create_if_block_76(ctx) {
	let div;
	let t0_value = plainText(/*title*/ ctx[2]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*#slots*/ ctx[70].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[84], get_title_slot_context_6);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (title_slot) title_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-title");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 4) && t0_value !== (t0_value = plainText(/*title*/ ctx[2]) + "")) set_data(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[84], dirty, get_title_slot_changes_6),
						get_title_slot_context_6
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (title_slot) title_slot.d(detaching);
		}
	};
}

// (761:16) {#if hasAfter}
function create_if_block_73(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[70]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[84], get_after_start_slot_context_6);
	let if_block0 = typeof /*after*/ ctx[10] !== 'undefined' && create_if_block_75(ctx);
	let if_block1 = typeof /*badge*/ ctx[11] !== 'undefined' && create_if_block_74(ctx);
	const after_slot_template = /*#slots*/ ctx[70].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[84], get_after_slot_context_6);
	const after_end_slot_template = /*#slots*/ ctx[70]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[84], get_after_end_slot_context_6);

	return {
		c() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (after_start_slot) after_start_slot.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_slot) after_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (after_end_slot) after_end_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-after");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_hydration(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_hydration(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_start_slot,
						after_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[84], dirty, get_after_start_slot_changes_6),
						get_after_start_slot_context_6
					);
				}
			}

			if (typeof /*after*/ ctx[10] !== 'undefined') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_75(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[11] !== 'undefined') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_74(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_slot,
						after_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[84], dirty, get_after_slot_changes_6),
						get_after_slot_context_6
					);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_end_slot,
						after_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[84], dirty, get_after_end_slot_changes_6),
						get_after_end_slot_context_6
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};
}

// (764:20) {#if typeof after !== 'undefined'}
function create_if_block_75(ctx) {
	let span;
	let t_value = plainText(/*after*/ ctx[10]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*after*/ 1024 && t_value !== (t_value = plainText(/*after*/ ctx[10]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (767:20) {#if typeof badge !== 'undefined'}
function create_if_block_74(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[12],
				lec: /*lec*/ ctx[1],
				$$slots: { default: [create_default_slot_6$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(badge_1.$$.fragment);
		},
		l(nodes) {
			claim_component(badge_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 4096) badge_1_changes.color = /*badgeColor*/ ctx[12];
			if (dirty[0] & /*lec*/ 2) badge_1_changes.lec = /*lec*/ ctx[1];

			if (dirty[0] & /*badge*/ 2048 | dirty[2] & /*$$scope*/ 4194304) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(badge_1, detaching);
		}
	};
}

// (768:22) <Badge  color={badgeColor}     lec={lec} >
function create_default_slot_6$1(ctx) {
	let t_value = plainText(/*badge*/ ctx[11]) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*badge*/ 2048 && t_value !== (t_value = plainText(/*badge*/ ctx[11]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (775:14) {#if hasSubtitle}
function create_if_block_72(ctx) {
	let div;
	let t0_value = plainText(/*subtitle*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*#slots*/ ctx[70].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[84], get_subtitle_slot_context_3);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (subtitle_slot) subtitle_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-subtitle");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 32) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[5]) + "")) set_data(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						subtitle_slot,
						subtitle_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[84], dirty, get_subtitle_slot_changes_3),
						get_subtitle_slot_context_3
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};
}

// (781:14) {#if hasText}
function create_if_block_71(ctx) {
	let div;
	let t0_value = plainText(/*text*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*#slots*/ ctx[70].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[84], get_text_slot_context_3);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (text_slot) text_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-text");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 8) && t0_value !== (t0_value = plainText(/*text*/ ctx[3]) + "")) set_data(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						text_slot,
						text_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[84], dirty, get_text_slot_changes_3),
						get_text_slot_context_3
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (text_slot) text_slot.d(detaching);
		}
	};
}

// (788:14) {#if !(swipeout || accordionItem)}
function create_if_block_70(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[70].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[84], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[84], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (791:14) {#if hasFooter}
function create_if_block_69(ctx) {
	let div;
	let t0_value = plainText(/*footer*/ ctx[7]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[70].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[84], get_footer_slot_context_6);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (footer_slot) footer_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-footer");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = plainText(/*footer*/ ctx[7]) + "")) set_data(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[84], dirty, get_footer_slot_changes_6),
						get_footer_slot_context_6
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};
}

// (479:8) {:else}
function create_else_block_2$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_26, create_else_block_4];
	const if_blocks = [];

	function select_block_type_4(ctx, dirty) {
		if (/*checkbox*/ ctx[18] || /*radio*/ ctx[19]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_4(ctx, [-1, -1, -1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_4(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (357:8) {#if isLink}
function create_if_block_5$2(ctx) {
	let a;
	let div1;
	let t0;
	let t1;
	let t2;
	let div0;
	let t3;
	let current_block_type_index;
	let if_block2;
	let t4;
	let t5;
	let t6;
	let useRouteProps_action;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*#slots*/ ctx[70]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[84], get_content_start_slot_context$2);
	let if_block0 = /*isSortable*/ ctx[46] && /*sortable*/ ctx[16] !== false && /*isSortableOpposite*/ ctx[45] && create_if_block_25(ctx);
	let if_block1 = /*hasMedia*/ ctx[38] && create_if_block_23(ctx);
	const inner_start_slot_template = /*#slots*/ ctx[70]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_start_slot_context$2);
	const if_block_creators = [create_if_block_6$1, create_else_block_1$1];
	const if_blocks = [];

	function select_block_type_3(ctx, dirty) {
		if (/*isMedia*/ ctx[27]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_3(ctx, [-1, -1, -1, -1]);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*#slots*/ ctx[70]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_end_slot_context$2);
	const content_slot_template = /*#slots*/ ctx[70].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[84], get_content_slot_context$1);
	const content_end_slot_template = /*#slots*/ ctx[70]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[84], get_content_end_slot_context$2);
	let a_levels = [{ class: /*linkClasses*/ ctx[41] }, /*linkAttrs*/ ctx[40]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = element("a");
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div0 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t3 = space();
			if_block2.c();
			t4 = space();
			if (inner_end_slot) inner_end_slot.c();
			t5 = space();
			if (content_slot) content_slot.c();
			t6 = space();
			if (content_end_slot) content_end_slot.c();
			this.h();
		},
		l(nodes) {
			a = claim_element(nodes, "A", { class: true });
			var a_nodes = children(a);
			div1 = claim_element(a_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (content_start_slot) content_start_slot.l(div1_nodes);
			t0 = claim_space(div1_nodes);
			if (if_block0) if_block0.l(div1_nodes);
			t1 = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			t2 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (inner_start_slot) inner_start_slot.l(div0_nodes);
			t3 = claim_space(div0_nodes);
			if_block2.l(div0_nodes);
			t4 = claim_space(div0_nodes);
			if (inner_end_slot) inner_end_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			t5 = claim_space(div1_nodes);
			if (content_slot) content_slot.l(div1_nodes);
			t6 = claim_space(div1_nodes);
			if (content_end_slot) content_end_slot.l(div1_nodes);
			div1_nodes.forEach(detach);
			a_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "item-inner");
			attr(div1, "class", /*contentClasses*/ ctx[42]);
			set_attributes(a, a_data);
		},
		m(target, anchor) {
			insert_hydration(target, a, anchor);
			append_hydration(a, div1);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_hydration(div1, t0);
			if (if_block0) if_block0.m(div1, null);
			append_hydration(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			append_hydration(div1, t2);
			append_hydration(div1, div0);

			if (inner_start_slot) {
				inner_start_slot.m(div0, null);
			}

			append_hydration(div0, t3);
			if_blocks[current_block_type_index].m(div0, null);
			append_hydration(div0, t4);

			if (inner_end_slot) {
				inner_end_slot.m(div0, null);
			}

			/*div0_binding*/ ctx[73](div0);
			append_hydration(div1, t5);

			if (content_slot) {
				content_slot.m(div1, null);
			}

			append_hydration(div1, t6);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			/*a_binding*/ ctx[74](a);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useRouteProps_action = useRouteProps.call(null, a, /*routeProps*/ ctx[26])),
					listen(a, "click", /*onClick*/ ctx[47])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_start_slot,
						content_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[84], dirty, get_content_start_slot_changes$2),
						get_content_start_slot_context$2
					);
				}
			}

			if (/*isSortable*/ ctx[46] && /*sortable*/ ctx[16] !== false && /*isSortableOpposite*/ ctx[45]) {
				if (if_block0) {
					
				} else {
					if_block0 = create_if_block_25(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*hasMedia*/ ctx[38]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_23(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_start_slot,
						inner_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_start_slot_changes$2),
						get_inner_start_slot_context$2
					);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_3(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(div0, t4);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_end_slot,
						inner_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_end_slot_changes$2),
						get_inner_end_slot_context$2
					);
				}
			}

			if (content_slot) {
				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_slot,
						content_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[84], dirty, get_content_slot_changes$1),
						get_content_slot_context$1
					);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_end_slot,
						content_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[84], dirty, get_content_end_slot_changes$2),
						get_content_end_slot_context$2
					);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2048) {
				attr(div1, "class", /*contentClasses*/ ctx[42]);
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty[1] & /*linkClasses*/ 1024) && { class: /*linkClasses*/ ctx[41] },
				dirty[1] & /*linkAttrs*/ 512 && /*linkAttrs*/ ctx[40]
			]));

			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 67108864) useRouteProps_action.update.call(null, /*routeProps*/ ctx[26]);
		},
		i(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div0_binding*/ ctx[73](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			/*a_binding*/ ctx[74](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (605:10) {:else}
function create_else_block_4(ctx) {
	let div1;
	let t0;
	let t1;
	let t2;
	let div0;
	let t3;
	let current_block_type_index;
	let if_block2;
	let t4;
	let t5;
	let t6;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*#slots*/ ctx[70]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[84], get_content_start_slot_context_2);
	let if_block0 = /*isSortable*/ ctx[46] && /*sortable*/ ctx[16] !== false && /*isSortableOpposite*/ ctx[45] && create_if_block_66(ctx);
	let if_block1 = /*hasMedia*/ ctx[38] && create_if_block_64(ctx);
	const inner_start_slot_template = /*#slots*/ ctx[70]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_start_slot_context_2);
	const if_block_creators = [create_if_block_47, create_else_block_5];
	const if_blocks = [];

	function select_block_type_6(ctx, dirty) {
		if (/*isMedia*/ ctx[27]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_6(ctx, [-1, -1, -1, -1]);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*#slots*/ ctx[70]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_end_slot_context_2);
	const content_slot_template = /*#slots*/ ctx[70].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[84], get_content_slot_context_2);
	const content_end_slot_template = /*#slots*/ ctx[70]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[84], get_content_end_slot_context_2);

	return {
		c() {
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div0 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t3 = space();
			if_block2.c();
			t4 = space();
			if (inner_end_slot) inner_end_slot.c();
			t5 = space();
			if (content_slot) content_slot.c();
			t6 = space();
			if (content_end_slot) content_end_slot.c();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (content_start_slot) content_start_slot.l(div1_nodes);
			t0 = claim_space(div1_nodes);
			if (if_block0) if_block0.l(div1_nodes);
			t1 = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			t2 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (inner_start_slot) inner_start_slot.l(div0_nodes);
			t3 = claim_space(div0_nodes);
			if_block2.l(div0_nodes);
			t4 = claim_space(div0_nodes);
			if (inner_end_slot) inner_end_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			t5 = claim_space(div1_nodes);
			if (content_slot) content_slot.l(div1_nodes);
			t6 = claim_space(div1_nodes);
			if (content_end_slot) content_end_slot.l(div1_nodes);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "item-inner");
			attr(div1, "class", /*contentClasses*/ ctx[42]);
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_hydration(div1, t0);
			if (if_block0) if_block0.m(div1, null);
			append_hydration(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			append_hydration(div1, t2);
			append_hydration(div1, div0);

			if (inner_start_slot) {
				inner_start_slot.m(div0, null);
			}

			append_hydration(div0, t3);
			if_blocks[current_block_type_index].m(div0, null);
			append_hydration(div0, t4);

			if (inner_end_slot) {
				inner_end_slot.m(div0, null);
			}

			/*div0_binding_1*/ ctx[77](div0);
			append_hydration(div1, t5);

			if (content_slot) {
				content_slot.m(div1, null);
			}

			append_hydration(div1, t6);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div1, "click", /*onClick*/ ctx[47]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_start_slot,
						content_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[84], dirty, get_content_start_slot_changes_2),
						get_content_start_slot_context_2
					);
				}
			}

			if (/*isSortable*/ ctx[46] && /*sortable*/ ctx[16] !== false && /*isSortableOpposite*/ ctx[45]) {
				if (if_block0) {
					
				} else {
					if_block0 = create_if_block_66(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*hasMedia*/ ctx[38]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_64(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_start_slot,
						inner_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_start_slot_changes_2),
						get_inner_start_slot_context_2
					);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_6(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(div0, t4);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_end_slot,
						inner_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_end_slot_changes_2),
						get_inner_end_slot_context_2
					);
				}
			}

			if (content_slot) {
				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_slot,
						content_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[84], dirty, get_content_slot_changes_2),
						get_content_slot_context_2
					);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_end_slot,
						content_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[84], dirty, get_content_end_slot_changes_2),
						get_content_end_slot_context_2
					);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2048) {
				attr(div1, "class", /*contentClasses*/ ctx[42]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div0_binding_1*/ ctx[77](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

// (481:10) {#if checkbox || radio}
function create_if_block_26(ctx) {
	let label;
	let t0;
	let t1;
	let input;
	let input_value_value;
	let input_type_value;
	let t2;
	let i;
	let i_class_value;
	let t3;
	let t4;
	let div;
	let t5;
	let current_block_type_index;
	let if_block2;
	let t6;
	let t7;
	let t8;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*#slots*/ ctx[70]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[84], get_content_start_slot_context_1$1);
	let if_block0 = /*isSortable*/ ctx[46] && /*sortable*/ ctx[16] !== false && /*isSortableOpposite*/ ctx[45] && create_if_block_46(ctx);
	let if_block1 = /*hasMedia*/ ctx[38] && create_if_block_44(ctx);
	const inner_start_slot_template = /*#slots*/ ctx[70]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_start_slot_context_1$1);
	const if_block_creators = [create_if_block_27, create_else_block_3];
	const if_blocks = [];

	function select_block_type_5(ctx, dirty) {
		if (/*isMedia*/ ctx[27]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_5(ctx, [-1, -1, -1, -1]);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*#slots*/ ctx[70]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_end_slot_context_1$1);
	const content_slot_template = /*#slots*/ ctx[70].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[84], get_content_slot_context_1$1);
	const content_end_slot_template = /*#slots*/ ctx[70]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[84], get_content_end_slot_context_1$1);

	return {
		c() {
			label = element("label");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			input = element("input");
			t2 = space();
			i = element("i");
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			div = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t5 = space();
			if_block2.c();
			t6 = space();
			if (inner_end_slot) inner_end_slot.c();
			t7 = space();
			if (content_slot) content_slot.c();
			t8 = space();
			if (content_end_slot) content_end_slot.c();
			this.h();
		},
		l(nodes) {
			label = claim_element(nodes, "LABEL", { class: true });
			var label_nodes = children(label);
			if (content_start_slot) content_start_slot.l(label_nodes);
			t0 = claim_space(label_nodes);
			if (if_block0) if_block0.l(label_nodes);
			t1 = claim_space(label_nodes);
			input = claim_element(label_nodes, "INPUT", { name: true, type: true });
			t2 = claim_space(label_nodes);
			i = claim_element(label_nodes, "I", { class: true });
			children(i).forEach(detach);
			t3 = claim_space(label_nodes);
			if (if_block1) if_block1.l(label_nodes);
			t4 = claim_space(label_nodes);
			div = claim_element(label_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (inner_start_slot) inner_start_slot.l(div_nodes);
			t5 = claim_space(div_nodes);
			if_block2.l(div_nodes);
			t6 = claim_space(div_nodes);
			if (inner_end_slot) inner_end_slot.l(div_nodes);
			div_nodes.forEach(detach);
			t7 = claim_space(label_nodes);
			if (content_slot) content_slot.l(label_nodes);
			t8 = claim_space(label_nodes);
			if (content_end_slot) content_end_slot.l(label_nodes);
			label_nodes.forEach(detach);
			this.h();
		},
		h() {
			input.value = input_value_value = typeof /*value*/ ctx[21] === 'undefined'
			? ''
			: /*value*/ ctx[21];

			attr(input, "name", /*name*/ ctx[20]);
			input.checked = /*checked*/ ctx[0];
			input.readOnly = /*readonly*/ ctx[22];
			input.disabled = /*disabled*/ ctx[24];
			input.required = /*required*/ ctx[23];
			attr(input, "type", input_type_value = /*radio*/ ctx[19] ? 'radio' : 'checkbox');
			attr(i, "class", i_class_value = `icon icon-${/*radio*/ ctx[19] ? 'radio' : 'checkbox'}`);
			attr(div, "class", "item-inner");
			attr(label, "class", /*contentClasses*/ ctx[42]);
		},
		m(target, anchor) {
			insert_hydration(target, label, anchor);

			if (content_start_slot) {
				content_start_slot.m(label, null);
			}

			append_hydration(label, t0);
			if (if_block0) if_block0.m(label, null);
			append_hydration(label, t1);
			append_hydration(label, input);
			/*input_binding*/ ctx[75](input);
			append_hydration(label, t2);
			append_hydration(label, i);
			append_hydration(label, t3);
			if (if_block1) if_block1.m(label, null);
			append_hydration(label, t4);
			append_hydration(label, div);

			if (inner_start_slot) {
				inner_start_slot.m(div, null);
			}

			append_hydration(div, t5);
			if_blocks[current_block_type_index].m(div, null);
			append_hydration(div, t6);

			if (inner_end_slot) {
				inner_end_slot.m(div, null);
			}

			/*div_binding*/ ctx[76](div);
			append_hydration(label, t7);

			if (content_slot) {
				content_slot.m(label, null);
			}

			append_hydration(label, t8);

			if (content_end_slot) {
				content_end_slot.m(label, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "change", /*onChange*/ ctx[48]),
					listen(label, "click", /*onClick*/ ctx[47])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_start_slot,
						content_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[84], dirty, get_content_start_slot_changes_1$1),
						get_content_start_slot_context_1$1
					);
				}
			}

			if (/*isSortable*/ ctx[46] && /*sortable*/ ctx[16] !== false && /*isSortableOpposite*/ ctx[45]) {
				if (if_block0) {
					
				} else {
					if_block0 = create_if_block_46(ctx);
					if_block0.c();
					if_block0.m(label, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!current || dirty[0] & /*value*/ 2097152 && input_value_value !== (input_value_value = typeof /*value*/ ctx[21] === 'undefined'
			? ''
			: /*value*/ ctx[21]) && input.value !== input_value_value) {
				input.value = input_value_value;
			}

			if (!current || dirty[0] & /*name*/ 1048576) {
				attr(input, "name", /*name*/ ctx[20]);
			}

			if (!current || dirty[0] & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (!current || dirty[0] & /*readonly*/ 4194304) {
				input.readOnly = /*readonly*/ ctx[22];
			}

			if (!current || dirty[0] & /*disabled*/ 16777216) {
				input.disabled = /*disabled*/ ctx[24];
			}

			if (!current || dirty[0] & /*required*/ 8388608) {
				input.required = /*required*/ ctx[23];
			}

			if (!current || dirty[0] & /*radio*/ 524288 && input_type_value !== (input_type_value = /*radio*/ ctx[19] ? 'radio' : 'checkbox')) {
				attr(input, "type", input_type_value);
			}

			if (!current || dirty[0] & /*radio*/ 524288 && i_class_value !== (i_class_value = `icon icon-${/*radio*/ ctx[19] ? 'radio' : 'checkbox'}`)) {
				attr(i, "class", i_class_value);
			}

			if (/*hasMedia*/ ctx[38]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_44(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(label, t4);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_start_slot,
						inner_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_start_slot_changes_1$1),
						get_inner_start_slot_context_1$1
					);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_5(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(div, t6);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_end_slot,
						inner_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_end_slot_changes_1$1),
						get_inner_end_slot_context_1$1
					);
				}
			}

			if (content_slot) {
				if (content_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_slot,
						content_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[84], dirty, get_content_slot_changes_1$1),
						get_content_slot_context_1$1
					);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						content_end_slot,
						content_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[84], dirty, get_content_end_slot_changes_1$1),
						get_content_end_slot_context_1$1
					);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2048) {
				attr(label, "class", /*contentClasses*/ ctx[42]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			/*input_binding*/ ctx[75](null);
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div_binding*/ ctx[76](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (608:14) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_66(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "sortable-handler");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (611:14) {#if hasMedia}
function create_if_block_64(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[4] !== 'undefined' && create_if_block_65(ctx);
	const media_slot_template = /*#slots*/ ctx[70].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[84], get_media_slot_context_2);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			if (media_slot) media_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-media");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (typeof /*media*/ ctx[4] !== 'undefined') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_65(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						media_slot,
						media_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[84], dirty, get_media_slot_changes_2),
						get_media_slot_context_2
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};
}

// (613:18) {#if typeof media !== 'undefined'}
function create_if_block_65(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			this.h();
		},
		l(nodes) {
			img = claim_element(nodes, "IMG", { src: true });
			this.h();
		},
		h() {
			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[4])) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert_hydration(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*media*/ 16 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[4])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (673:16) {:else}
function create_else_block_5(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*#slots*/ ctx[70]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[84], get_before_title_slot_context_5);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[36] || /*hasFooter*/ ctx[35]) && create_if_block_61(ctx);
	const after_title_slot_template = /*#slots*/ ctx[70]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[84], get_after_title_slot_context_5);
	let if_block1 = /*hasAfter*/ ctx[32] && create_if_block_58(ctx);
	const inner_slot_template = /*#slots*/ ctx[70].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_slot_context_5);
	let if_block2 = !(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17]) && create_if_block_57(ctx);

	return {
		c() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		l(nodes) {
			if (before_title_slot) before_title_slot.l(nodes);
			t0 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t1 = claim_space(nodes);
			if (after_title_slot) after_title_slot.l(nodes);
			t2 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t3 = claim_space(nodes);
			if (inner_slot) inner_slot.l(nodes);
			t4 = claim_space(nodes);
			if (if_block2) if_block2.l(nodes);
			if_block2_anchor = empty();
		},
		m(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_hydration(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_hydration(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_hydration(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_hydration(target, if_block2_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						before_title_slot,
						before_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[84], dirty, get_before_title_slot_changes_5),
						get_before_title_slot_context_5
					);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[36] || /*hasFooter*/ ctx[35]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 112) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_61(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_title_slot,
						after_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[84], dirty, get_after_title_slot_changes_5),
						get_after_title_slot_context_5
					);
				}
			}

			if (/*hasAfter*/ ctx[32]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_58(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_slot,
						inner_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_slot_changes_5),
						get_inner_slot_context_5
					);
				}
			}

			if (!(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 163840) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_57(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(if_block2_anchor);
		}
	};
}

// (621:16) {#if isMedia}
function create_if_block_47(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[36] && create_if_block_56(ctx);
	const before_title_slot_template = /*#slots*/ ctx[70]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[84], get_before_title_slot_context_4);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_55(ctx);
	const after_title_slot_template = /*#slots*/ ctx[70]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[84], get_after_title_slot_context_4);
	let if_block2 = /*hasAfter*/ ctx[32] && create_if_block_52(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[34] && create_if_block_51(ctx);
	let if_block4 = /*hasText*/ ctx[33] && create_if_block_50(ctx);
	const inner_slot_template = /*#slots*/ ctx[70].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_slot_context_4);
	let if_block5 = !(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17]) && create_if_block_49(ctx);
	let if_block6 = /*hasFooter*/ ctx[35] && create_if_block_48(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty();
			this.h();
		},
		l(nodes) {
			if (if_block0) if_block0.l(nodes);
			t0 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (before_title_slot) before_title_slot.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_title_slot) after_title_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block2) if_block2.l(div_nodes);
			div_nodes.forEach(detach);
			t4 = claim_space(nodes);
			if (if_block3) if_block3.l(nodes);
			t5 = claim_space(nodes);
			if (if_block4) if_block4.l(nodes);
			t6 = claim_space(nodes);
			if (inner_slot) inner_slot.l(nodes);
			t7 = claim_space(nodes);
			if (if_block5) if_block5.l(nodes);
			t8 = claim_space(nodes);
			if (if_block6) if_block6.l(nodes);
			if_block6_anchor = empty();
			this.h();
		},
		h() {
			attr(div, "class", "item-title-row");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration(target, t0, anchor);
			insert_hydration(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_hydration(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_hydration(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_hydration(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_hydration(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_hydration(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_hydration(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_hydration(target, if_block6_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*hasHeader*/ ctx[36]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_56(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						before_title_slot,
						before_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[84], dirty, get_before_title_slot_changes_4),
						get_before_title_slot_context_4
					);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_55(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_title_slot,
						after_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[84], dirty, get_after_title_slot_changes_4),
						get_after_title_slot_context_4
					);
				}
			}

			if (/*hasAfter*/ ctx[32]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_52(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[34]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 8) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_51(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[33]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 4) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_50(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_slot,
						inner_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_slot_changes_4),
						get_inner_slot_context_4
					);
				}
			}

			if (!(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 163840) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_49(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[35]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 16) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_48(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach(if_block6_anchor);
		}
	};
}

// (675:18) {#if hasTitle || hasHeader || hasFooter}
function create_if_block_61(ctx) {
	let div;
	let t0;
	let t1_value = plainText(/*title*/ ctx[2]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[36] && create_if_block_63(ctx);
	const title_slot_template = /*#slots*/ ctx[70].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[84], get_title_slot_context_5);
	let if_block1 = /*hasFooter*/ ctx[35] && create_if_block_62(ctx);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			t1 = claim_text(div_nodes, t1_value);
			t2 = claim_space(div_nodes);
			if (title_slot) title_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-title");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t0);
			append_hydration(div, t1);
			append_hydration(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_hydration(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*hasHeader*/ ctx[36]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_63(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 4) && t1_value !== (t1_value = plainText(/*title*/ ctx[2]) + "")) set_data(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[84], dirty, get_title_slot_changes_5),
						get_title_slot_context_5
					);
				}
			}

			if (/*hasFooter*/ ctx[35]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 16) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_62(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};
}

// (677:22) {#if hasHeader}
function create_if_block_63(ctx) {
	let div;
	let t0_value = plainText(/*header*/ ctx[6]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[70].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[84], get_header_slot_context_5);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (header_slot) header_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-header");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = plainText(/*header*/ ctx[6]) + "")) set_data(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[84], dirty, get_header_slot_changes_5),
						get_header_slot_context_5
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (685:22) {#if hasFooter}
function create_if_block_62(ctx) {
	let div;
	let t0_value = plainText(/*footer*/ ctx[7]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[70].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[84], get_footer_slot_context_5);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (footer_slot) footer_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-footer");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = plainText(/*footer*/ ctx[7]) + "")) set_data(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[84], dirty, get_footer_slot_changes_5),
						get_footer_slot_context_5
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};
}

// (694:18) {#if hasAfter}
function create_if_block_58(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[70]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[84], get_after_start_slot_context_5);
	let if_block0 = typeof /*after*/ ctx[10] !== 'undefined' && create_if_block_60(ctx);
	let if_block1 = typeof /*badge*/ ctx[11] !== 'undefined' && create_if_block_59(ctx);
	const after_slot_template = /*#slots*/ ctx[70].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[84], get_after_slot_context_5);
	const after_end_slot_template = /*#slots*/ ctx[70]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[84], get_after_end_slot_context_5);

	return {
		c() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (after_start_slot) after_start_slot.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_slot) after_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (after_end_slot) after_end_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-after");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_hydration(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_hydration(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_start_slot,
						after_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[84], dirty, get_after_start_slot_changes_5),
						get_after_start_slot_context_5
					);
				}
			}

			if (typeof /*after*/ ctx[10] !== 'undefined') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_60(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[11] !== 'undefined') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_59(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_slot,
						after_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[84], dirty, get_after_slot_changes_5),
						get_after_slot_context_5
					);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_end_slot,
						after_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[84], dirty, get_after_end_slot_changes_5),
						get_after_end_slot_context_5
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};
}

// (697:22) {#if typeof after !== 'undefined'}
function create_if_block_60(ctx) {
	let span;
	let t_value = plainText(/*after*/ ctx[10]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*after*/ 1024 && t_value !== (t_value = plainText(/*after*/ ctx[10]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (700:22) {#if typeof badge !== 'undefined'}
function create_if_block_59(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[12],
				lec: /*lec*/ ctx[1],
				$$slots: { default: [create_default_slot_5$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(badge_1.$$.fragment);
		},
		l(nodes) {
			claim_component(badge_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 4096) badge_1_changes.color = /*badgeColor*/ ctx[12];
			if (dirty[0] & /*lec*/ 2) badge_1_changes.lec = /*lec*/ ctx[1];

			if (dirty[0] & /*badge*/ 2048 | dirty[2] & /*$$scope*/ 4194304) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(badge_1, detaching);
		}
	};
}

// (701:24) <Badge  color={badgeColor}     lec={lec} >
function create_default_slot_5$1(ctx) {
	let t_value = plainText(/*badge*/ ctx[11]) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*badge*/ 2048 && t_value !== (t_value = plainText(/*badge*/ ctx[11]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (708:18) {#if !(swipeout || accordionItem)}
function create_if_block_57(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[70].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[84], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[84], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (622:18) {#if hasHeader}
function create_if_block_56(ctx) {
	let div;
	let t0_value = plainText(/*header*/ ctx[6]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[70].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[84], get_header_slot_context_4);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (header_slot) header_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-header");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = plainText(/*header*/ ctx[6]) + "")) set_data(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[84], dirty, get_header_slot_changes_4),
						get_header_slot_context_4
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (630:20) {#if hasTitle}
function create_if_block_55(ctx) {
	let div;
	let t0_value = plainText(/*title*/ ctx[2]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*#slots*/ ctx[70].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[84], get_title_slot_context_4);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (title_slot) title_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-title");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 4) && t0_value !== (t0_value = plainText(/*title*/ ctx[2]) + "")) set_data(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[84], dirty, get_title_slot_changes_4),
						get_title_slot_context_4
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (title_slot) title_slot.d(detaching);
		}
	};
}

// (637:20) {#if hasAfter}
function create_if_block_52(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[70]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[84], get_after_start_slot_context_4);
	let if_block0 = typeof /*after*/ ctx[10] !== 'undefined' && create_if_block_54(ctx);
	let if_block1 = typeof /*badge*/ ctx[11] !== 'undefined' && create_if_block_53(ctx);
	const after_slot_template = /*#slots*/ ctx[70].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[84], get_after_slot_context_4);
	const after_end_slot_template = /*#slots*/ ctx[70]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[84], get_after_end_slot_context_4);

	return {
		c() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (after_start_slot) after_start_slot.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_slot) after_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (after_end_slot) after_end_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-after");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_hydration(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_hydration(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_start_slot,
						after_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[84], dirty, get_after_start_slot_changes_4),
						get_after_start_slot_context_4
					);
				}
			}

			if (typeof /*after*/ ctx[10] !== 'undefined') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_54(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[11] !== 'undefined') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_53(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_slot,
						after_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[84], dirty, get_after_slot_changes_4),
						get_after_slot_context_4
					);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_end_slot,
						after_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[84], dirty, get_after_end_slot_changes_4),
						get_after_end_slot_context_4
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};
}

// (640:24) {#if typeof after !== 'undefined'}
function create_if_block_54(ctx) {
	let span;
	let t_value = plainText(/*after*/ ctx[10]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*after*/ 1024 && t_value !== (t_value = plainText(/*after*/ ctx[10]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (643:24) {#if typeof badge !== 'undefined'}
function create_if_block_53(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[12],
				lec: /*lec*/ ctx[1],
				$$slots: { default: [create_default_slot_4$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(badge_1.$$.fragment);
		},
		l(nodes) {
			claim_component(badge_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 4096) badge_1_changes.color = /*badgeColor*/ ctx[12];
			if (dirty[0] & /*lec*/ 2) badge_1_changes.lec = /*lec*/ ctx[1];

			if (dirty[0] & /*badge*/ 2048 | dirty[2] & /*$$scope*/ 4194304) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(badge_1, detaching);
		}
	};
}

// (644:26) <Badge  color={badgeColor}     lec={lec} >
function create_default_slot_4$1(ctx) {
	let t_value = plainText(/*badge*/ ctx[11]) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*badge*/ 2048 && t_value !== (t_value = plainText(/*badge*/ ctx[11]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (651:18) {#if hasSubtitle}
function create_if_block_51(ctx) {
	let div;
	let t0_value = plainText(/*subtitle*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*#slots*/ ctx[70].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[84], get_subtitle_slot_context_2);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (subtitle_slot) subtitle_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-subtitle");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 32) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[5]) + "")) set_data(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						subtitle_slot,
						subtitle_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[84], dirty, get_subtitle_slot_changes_2),
						get_subtitle_slot_context_2
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};
}

// (657:18) {#if hasText}
function create_if_block_50(ctx) {
	let div;
	let t0_value = plainText(/*text*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*#slots*/ ctx[70].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[84], get_text_slot_context_2);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (text_slot) text_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-text");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 8) && t0_value !== (t0_value = plainText(/*text*/ ctx[3]) + "")) set_data(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						text_slot,
						text_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[84], dirty, get_text_slot_changes_2),
						get_text_slot_context_2
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (text_slot) text_slot.d(detaching);
		}
	};
}

// (664:18) {#if !(swipeout || accordionItem)}
function create_if_block_49(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[70].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[84], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[84], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (667:18) {#if hasFooter}
function create_if_block_48(ctx) {
	let div;
	let t0_value = plainText(/*footer*/ ctx[7]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[70].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[84], get_footer_slot_context_4);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (footer_slot) footer_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-footer");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = plainText(/*footer*/ ctx[7]) + "")) set_data(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[84], dirty, get_footer_slot_changes_4),
						get_footer_slot_context_4
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};
}

// (484:14) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_46(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "sortable-handler");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (499:14) {#if hasMedia}
function create_if_block_44(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[4] !== 'undefined' && create_if_block_45(ctx);
	const media_slot_template = /*#slots*/ ctx[70].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[84], get_media_slot_context_1$1);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			if (media_slot) media_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-media");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (typeof /*media*/ ctx[4] !== 'undefined') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_45(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						media_slot,
						media_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[84], dirty, get_media_slot_changes_1$1),
						get_media_slot_context_1$1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};
}

// (501:18) {#if typeof media !== 'undefined'}
function create_if_block_45(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			this.h();
		},
		l(nodes) {
			img = claim_element(nodes, "IMG", { src: true });
			this.h();
		},
		h() {
			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[4])) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert_hydration(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*media*/ 16 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[4])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (561:16) {:else}
function create_else_block_3(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*#slots*/ ctx[70]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[84], get_before_title_slot_context_3);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[36] || /*hasFooter*/ ctx[35]) && create_if_block_41(ctx);
	const after_title_slot_template = /*#slots*/ ctx[70]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[84], get_after_title_slot_context_3);
	let if_block1 = /*hasAfter*/ ctx[32] && create_if_block_38(ctx);
	const inner_slot_template = /*#slots*/ ctx[70].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_slot_context_3);
	let if_block2 = !(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17]) && create_if_block_37(ctx);

	return {
		c() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		l(nodes) {
			if (before_title_slot) before_title_slot.l(nodes);
			t0 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t1 = claim_space(nodes);
			if (after_title_slot) after_title_slot.l(nodes);
			t2 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t3 = claim_space(nodes);
			if (inner_slot) inner_slot.l(nodes);
			t4 = claim_space(nodes);
			if (if_block2) if_block2.l(nodes);
			if_block2_anchor = empty();
		},
		m(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_hydration(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_hydration(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_hydration(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_hydration(target, if_block2_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						before_title_slot,
						before_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[84], dirty, get_before_title_slot_changes_3),
						get_before_title_slot_context_3
					);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[36] || /*hasFooter*/ ctx[35]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 112) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_41(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_title_slot,
						after_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[84], dirty, get_after_title_slot_changes_3),
						get_after_title_slot_context_3
					);
				}
			}

			if (/*hasAfter*/ ctx[32]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_38(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_slot,
						inner_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_slot_changes_3),
						get_inner_slot_context_3
					);
				}
			}

			if (!(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 163840) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_37(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(if_block2_anchor);
		}
	};
}

// (509:16) {#if isMedia}
function create_if_block_27(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[36] && create_if_block_36(ctx);
	const before_title_slot_template = /*#slots*/ ctx[70]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[84], get_before_title_slot_context_2);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_35(ctx);
	const after_title_slot_template = /*#slots*/ ctx[70]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[84], get_after_title_slot_context_2);
	let if_block2 = /*hasAfter*/ ctx[32] && create_if_block_32(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[34] && create_if_block_31(ctx);
	let if_block4 = /*hasText*/ ctx[33] && create_if_block_30(ctx);
	const inner_slot_template = /*#slots*/ ctx[70].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_slot_context_2);
	let if_block5 = !(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17]) && create_if_block_29(ctx);
	let if_block6 = /*hasFooter*/ ctx[35] && create_if_block_28(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty();
			this.h();
		},
		l(nodes) {
			if (if_block0) if_block0.l(nodes);
			t0 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (before_title_slot) before_title_slot.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_title_slot) after_title_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block2) if_block2.l(div_nodes);
			div_nodes.forEach(detach);
			t4 = claim_space(nodes);
			if (if_block3) if_block3.l(nodes);
			t5 = claim_space(nodes);
			if (if_block4) if_block4.l(nodes);
			t6 = claim_space(nodes);
			if (inner_slot) inner_slot.l(nodes);
			t7 = claim_space(nodes);
			if (if_block5) if_block5.l(nodes);
			t8 = claim_space(nodes);
			if (if_block6) if_block6.l(nodes);
			if_block6_anchor = empty();
			this.h();
		},
		h() {
			attr(div, "class", "item-title-row");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration(target, t0, anchor);
			insert_hydration(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_hydration(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_hydration(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_hydration(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_hydration(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_hydration(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_hydration(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_hydration(target, if_block6_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*hasHeader*/ ctx[36]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_36(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						before_title_slot,
						before_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[84], dirty, get_before_title_slot_changes_2),
						get_before_title_slot_context_2
					);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_35(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_title_slot,
						after_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[84], dirty, get_after_title_slot_changes_2),
						get_after_title_slot_context_2
					);
				}
			}

			if (/*hasAfter*/ ctx[32]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_32(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[34]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 8) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_31(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[33]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 4) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_30(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_slot,
						inner_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_slot_changes_2),
						get_inner_slot_context_2
					);
				}
			}

			if (!(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 163840) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_29(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[35]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 16) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_28(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach(if_block6_anchor);
		}
	};
}

// (563:18) {#if hasTitle || hasHeader || hasFooter}
function create_if_block_41(ctx) {
	let div;
	let t0;
	let t1_value = plainText(/*title*/ ctx[2]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[36] && create_if_block_43(ctx);
	const title_slot_template = /*#slots*/ ctx[70].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[84], get_title_slot_context_3);
	let if_block1 = /*hasFooter*/ ctx[35] && create_if_block_42(ctx);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			t1 = claim_text(div_nodes, t1_value);
			t2 = claim_space(div_nodes);
			if (title_slot) title_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-title");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t0);
			append_hydration(div, t1);
			append_hydration(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_hydration(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*hasHeader*/ ctx[36]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_43(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 4) && t1_value !== (t1_value = plainText(/*title*/ ctx[2]) + "")) set_data(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[84], dirty, get_title_slot_changes_3),
						get_title_slot_context_3
					);
				}
			}

			if (/*hasFooter*/ ctx[35]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 16) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_42(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};
}

// (565:22) {#if hasHeader}
function create_if_block_43(ctx) {
	let div;
	let t0_value = plainText(/*header*/ ctx[6]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[70].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[84], get_header_slot_context_3);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (header_slot) header_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-header");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = plainText(/*header*/ ctx[6]) + "")) set_data(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[84], dirty, get_header_slot_changes_3),
						get_header_slot_context_3
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (573:22) {#if hasFooter}
function create_if_block_42(ctx) {
	let div;
	let t0_value = plainText(/*footer*/ ctx[7]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[70].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[84], get_footer_slot_context_3);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (footer_slot) footer_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-footer");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = plainText(/*footer*/ ctx[7]) + "")) set_data(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[84], dirty, get_footer_slot_changes_3),
						get_footer_slot_context_3
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};
}

// (582:18) {#if hasAfter}
function create_if_block_38(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[70]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[84], get_after_start_slot_context_3);
	let if_block0 = typeof /*after*/ ctx[10] !== 'undefined' && create_if_block_40(ctx);
	let if_block1 = typeof /*badge*/ ctx[11] !== 'undefined' && create_if_block_39(ctx);
	const after_slot_template = /*#slots*/ ctx[70].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[84], get_after_slot_context_3);
	const after_end_slot_template = /*#slots*/ ctx[70]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[84], get_after_end_slot_context_3);

	return {
		c() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (after_start_slot) after_start_slot.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_slot) after_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (after_end_slot) after_end_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-after");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_hydration(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_hydration(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_start_slot,
						after_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[84], dirty, get_after_start_slot_changes_3),
						get_after_start_slot_context_3
					);
				}
			}

			if (typeof /*after*/ ctx[10] !== 'undefined') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_40(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[11] !== 'undefined') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_39(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_slot,
						after_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[84], dirty, get_after_slot_changes_3),
						get_after_slot_context_3
					);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_end_slot,
						after_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[84], dirty, get_after_end_slot_changes_3),
						get_after_end_slot_context_3
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};
}

// (585:22) {#if typeof after !== 'undefined'}
function create_if_block_40(ctx) {
	let span;
	let t_value = plainText(/*after*/ ctx[10]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*after*/ 1024 && t_value !== (t_value = plainText(/*after*/ ctx[10]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (588:22) {#if typeof badge !== 'undefined'}
function create_if_block_39(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[12],
				lec: /*lec*/ ctx[1],
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(badge_1.$$.fragment);
		},
		l(nodes) {
			claim_component(badge_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 4096) badge_1_changes.color = /*badgeColor*/ ctx[12];
			if (dirty[0] & /*lec*/ 2) badge_1_changes.lec = /*lec*/ ctx[1];

			if (dirty[0] & /*badge*/ 2048 | dirty[2] & /*$$scope*/ 4194304) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(badge_1, detaching);
		}
	};
}

// (589:24) <Badge  color={badgeColor}     lec={lec} >
function create_default_slot_3$1(ctx) {
	let t_value = plainText(/*badge*/ ctx[11]) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*badge*/ 2048 && t_value !== (t_value = plainText(/*badge*/ ctx[11]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (596:18) {#if !(swipeout || accordionItem)}
function create_if_block_37(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[70].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[84], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[84], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (510:18) {#if hasHeader}
function create_if_block_36(ctx) {
	let div;
	let t0_value = plainText(/*header*/ ctx[6]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[70].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[84], get_header_slot_context_2);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (header_slot) header_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-header");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = plainText(/*header*/ ctx[6]) + "")) set_data(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[84], dirty, get_header_slot_changes_2),
						get_header_slot_context_2
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (518:20) {#if hasTitle}
function create_if_block_35(ctx) {
	let div;
	let t0_value = plainText(/*title*/ ctx[2]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*#slots*/ ctx[70].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[84], get_title_slot_context_2);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (title_slot) title_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-title");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 4) && t0_value !== (t0_value = plainText(/*title*/ ctx[2]) + "")) set_data(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[84], dirty, get_title_slot_changes_2),
						get_title_slot_context_2
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (title_slot) title_slot.d(detaching);
		}
	};
}

// (525:20) {#if hasAfter}
function create_if_block_32(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[70]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[84], get_after_start_slot_context_2);
	let if_block0 = typeof /*after*/ ctx[10] !== 'undefined' && create_if_block_34(ctx);
	let if_block1 = typeof /*badge*/ ctx[11] !== 'undefined' && create_if_block_33(ctx);
	const after_slot_template = /*#slots*/ ctx[70].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[84], get_after_slot_context_2);
	const after_end_slot_template = /*#slots*/ ctx[70]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[84], get_after_end_slot_context_2);

	return {
		c() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (after_start_slot) after_start_slot.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_slot) after_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (after_end_slot) after_end_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-after");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_hydration(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_hydration(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_start_slot,
						after_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[84], dirty, get_after_start_slot_changes_2),
						get_after_start_slot_context_2
					);
				}
			}

			if (typeof /*after*/ ctx[10] !== 'undefined') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_34(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[11] !== 'undefined') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_33(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_slot,
						after_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[84], dirty, get_after_slot_changes_2),
						get_after_slot_context_2
					);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_end_slot,
						after_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[84], dirty, get_after_end_slot_changes_2),
						get_after_end_slot_context_2
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};
}

// (528:24) {#if typeof after !== 'undefined'}
function create_if_block_34(ctx) {
	let span;
	let t_value = plainText(/*after*/ ctx[10]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*after*/ 1024 && t_value !== (t_value = plainText(/*after*/ ctx[10]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (531:24) {#if typeof badge !== 'undefined'}
function create_if_block_33(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[12],
				lec: /*lec*/ ctx[1],
				$$slots: { default: [create_default_slot_2$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(badge_1.$$.fragment);
		},
		l(nodes) {
			claim_component(badge_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 4096) badge_1_changes.color = /*badgeColor*/ ctx[12];
			if (dirty[0] & /*lec*/ 2) badge_1_changes.lec = /*lec*/ ctx[1];

			if (dirty[0] & /*badge*/ 2048 | dirty[2] & /*$$scope*/ 4194304) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(badge_1, detaching);
		}
	};
}

// (532:26) <Badge  color={badgeColor}     lec={lec} >
function create_default_slot_2$2(ctx) {
	let t_value = plainText(/*badge*/ ctx[11]) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*badge*/ 2048 && t_value !== (t_value = plainText(/*badge*/ ctx[11]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (539:18) {#if hasSubtitle}
function create_if_block_31(ctx) {
	let div;
	let t0_value = plainText(/*subtitle*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*#slots*/ ctx[70].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[84], get_subtitle_slot_context_1);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (subtitle_slot) subtitle_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-subtitle");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 32) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[5]) + "")) set_data(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						subtitle_slot,
						subtitle_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[84], dirty, get_subtitle_slot_changes_1),
						get_subtitle_slot_context_1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};
}

// (545:18) {#if hasText}
function create_if_block_30(ctx) {
	let div;
	let t0_value = plainText(/*text*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*#slots*/ ctx[70].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[84], get_text_slot_context_1$1);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (text_slot) text_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-text");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 8) && t0_value !== (t0_value = plainText(/*text*/ ctx[3]) + "")) set_data(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						text_slot,
						text_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[84], dirty, get_text_slot_changes_1$1),
						get_text_slot_context_1$1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (text_slot) text_slot.d(detaching);
		}
	};
}

// (552:18) {#if !(swipeout || accordionItem)}
function create_if_block_29(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[70].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[84], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[84], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (555:18) {#if hasFooter}
function create_if_block_28(ctx) {
	let div;
	let t0_value = plainText(/*footer*/ ctx[7]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[70].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[84], get_footer_slot_context_2);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (footer_slot) footer_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-footer");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = plainText(/*footer*/ ctx[7]) + "")) set_data(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[84], dirty, get_footer_slot_changes_2),
						get_footer_slot_context_2
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};
}

// (368:14) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_25(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "sortable-handler");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (371:14) {#if hasMedia}
function create_if_block_23(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[4] !== 'undefined' && create_if_block_24(ctx);
	const media_slot_template = /*#slots*/ ctx[70].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[84], get_media_slot_context$1);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			if (media_slot) media_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-media");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (typeof /*media*/ ctx[4] !== 'undefined') {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_24(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						media_slot,
						media_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[84], dirty, get_media_slot_changes$1),
						get_media_slot_context$1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};
}

// (373:18) {#if typeof media !== 'undefined'}
function create_if_block_24(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			this.h();
		},
		l(nodes) {
			img = claim_element(nodes, "IMG", { src: true });
			this.h();
		},
		h() {
			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[4])) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert_hydration(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*media*/ 16 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[4])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (433:16) {:else}
function create_else_block_1$1(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*#slots*/ ctx[70]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[84], get_before_title_slot_context_1);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[36] || /*hasFooter*/ ctx[35]) && create_if_block_20(ctx);
	const after_title_slot_template = /*#slots*/ ctx[70]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[84], get_after_title_slot_context_1);
	let if_block1 = /*hasAfter*/ ctx[32] && create_if_block_17(ctx);
	const inner_slot_template = /*#slots*/ ctx[70].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_slot_context_1);
	let if_block2 = !(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17]) && create_if_block_16(ctx);

	return {
		c() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		l(nodes) {
			if (before_title_slot) before_title_slot.l(nodes);
			t0 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t1 = claim_space(nodes);
			if (after_title_slot) after_title_slot.l(nodes);
			t2 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t3 = claim_space(nodes);
			if (inner_slot) inner_slot.l(nodes);
			t4 = claim_space(nodes);
			if (if_block2) if_block2.l(nodes);
			if_block2_anchor = empty();
		},
		m(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_hydration(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_hydration(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_hydration(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_hydration(target, if_block2_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						before_title_slot,
						before_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[84], dirty, get_before_title_slot_changes_1),
						get_before_title_slot_context_1
					);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[36] || /*hasFooter*/ ctx[35]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 112) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_20(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_title_slot,
						after_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[84], dirty, get_after_title_slot_changes_1),
						get_after_title_slot_context_1
					);
				}
			}

			if (/*hasAfter*/ ctx[32]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_17(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_slot,
						inner_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_slot_changes_1),
						get_inner_slot_context_1
					);
				}
			}

			if (!(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 163840) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_16(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(if_block2_anchor);
		}
	};
}

// (381:16) {#if isMedia}
function create_if_block_6$1(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[36] && create_if_block_15(ctx);
	const before_title_slot_template = /*#slots*/ ctx[70]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[84], get_before_title_slot_context);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_14(ctx);
	const after_title_slot_template = /*#slots*/ ctx[70]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[84], get_after_title_slot_context);
	let if_block2 = /*hasAfter*/ ctx[32] && create_if_block_11(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[34] && create_if_block_10$1(ctx);
	let if_block4 = /*hasText*/ ctx[33] && create_if_block_9$1(ctx);
	const inner_slot_template = /*#slots*/ ctx[70].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[84], get_inner_slot_context);
	let if_block5 = !(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17]) && create_if_block_8$1(ctx);
	let if_block6 = /*hasFooter*/ ctx[35] && create_if_block_7$1(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty();
			this.h();
		},
		l(nodes) {
			if (if_block0) if_block0.l(nodes);
			t0 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (before_title_slot) before_title_slot.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_title_slot) after_title_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block2) if_block2.l(div_nodes);
			div_nodes.forEach(detach);
			t4 = claim_space(nodes);
			if (if_block3) if_block3.l(nodes);
			t5 = claim_space(nodes);
			if (if_block4) if_block4.l(nodes);
			t6 = claim_space(nodes);
			if (inner_slot) inner_slot.l(nodes);
			t7 = claim_space(nodes);
			if (if_block5) if_block5.l(nodes);
			t8 = claim_space(nodes);
			if (if_block6) if_block6.l(nodes);
			if_block6_anchor = empty();
			this.h();
		},
		h() {
			attr(div, "class", "item-title-row");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration(target, t0, anchor);
			insert_hydration(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_hydration(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_hydration(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_hydration(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_hydration(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_hydration(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_hydration(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_hydration(target, if_block6_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*hasHeader*/ ctx[36]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_15(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						before_title_slot,
						before_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[84], dirty, get_before_title_slot_changes),
						get_before_title_slot_context
					);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_14(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_title_slot,
						after_title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[84], dirty, get_after_title_slot_changes),
						get_after_title_slot_context
					);
				}
			}

			if (/*hasAfter*/ ctx[32]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_11(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[34]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 8) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_10$1(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[33]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 4) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_9$1(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						inner_slot,
						inner_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(inner_slot_template, /*$$scope*/ ctx[84], dirty, get_inner_slot_changes),
						get_inner_slot_context
					);
				}
			}

			if (!(/*swipeout*/ ctx[15] || /*accordionItem*/ ctx[17])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 163840) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_8$1(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[35]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 16) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_7$1(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach(if_block6_anchor);
		}
	};
}

// (435:18) {#if hasTitle || hasHeader || hasFooter}
function create_if_block_20(ctx) {
	let div;
	let t0;
	let t1_value = plainText(/*title*/ ctx[2]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[36] && create_if_block_22(ctx);
	const title_slot_template = /*#slots*/ ctx[70].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[84], get_title_slot_context_1);
	let if_block1 = /*hasFooter*/ ctx[35] && create_if_block_21(ctx);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			t1 = claim_text(div_nodes, t1_value);
			t2 = claim_space(div_nodes);
			if (title_slot) title_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-title");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t0);
			append_hydration(div, t1);
			append_hydration(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_hydration(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*hasHeader*/ ctx[36]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_22(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 4) && t1_value !== (t1_value = plainText(/*title*/ ctx[2]) + "")) set_data(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[84], dirty, get_title_slot_changes_1),
						get_title_slot_context_1
					);
				}
			}

			if (/*hasFooter*/ ctx[35]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 16) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_21(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};
}

// (437:22) {#if hasHeader}
function create_if_block_22(ctx) {
	let div;
	let t0_value = plainText(/*header*/ ctx[6]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[70].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[84], get_header_slot_context_1);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (header_slot) header_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-header");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = plainText(/*header*/ ctx[6]) + "")) set_data(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[84], dirty, get_header_slot_changes_1),
						get_header_slot_context_1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (445:22) {#if hasFooter}
function create_if_block_21(ctx) {
	let div;
	let t0_value = plainText(/*footer*/ ctx[7]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[70].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[84], get_footer_slot_context_1);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (footer_slot) footer_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-footer");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = plainText(/*footer*/ ctx[7]) + "")) set_data(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[84], dirty, get_footer_slot_changes_1),
						get_footer_slot_context_1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};
}

// (454:18) {#if hasAfter}
function create_if_block_17(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[70]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[84], get_after_start_slot_context_1);
	let if_block0 = typeof /*after*/ ctx[10] !== 'undefined' && create_if_block_19(ctx);
	let if_block1 = typeof /*badge*/ ctx[11] !== 'undefined' && create_if_block_18(ctx);
	const after_slot_template = /*#slots*/ ctx[70].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[84], get_after_slot_context_1);
	const after_end_slot_template = /*#slots*/ ctx[70]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[84], get_after_end_slot_context_1);

	return {
		c() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (after_start_slot) after_start_slot.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_slot) after_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (after_end_slot) after_end_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-after");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_hydration(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_hydration(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_start_slot,
						after_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[84], dirty, get_after_start_slot_changes_1),
						get_after_start_slot_context_1
					);
				}
			}

			if (typeof /*after*/ ctx[10] !== 'undefined') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_19(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[11] !== 'undefined') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_18(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_slot,
						after_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[84], dirty, get_after_slot_changes_1),
						get_after_slot_context_1
					);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_end_slot,
						after_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[84], dirty, get_after_end_slot_changes_1),
						get_after_end_slot_context_1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};
}

// (457:22) {#if typeof after !== 'undefined'}
function create_if_block_19(ctx) {
	let span;
	let t_value = plainText(/*after*/ ctx[10]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*after*/ 1024 && t_value !== (t_value = plainText(/*after*/ ctx[10]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (460:22) {#if typeof badge !== 'undefined'}
function create_if_block_18(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[12],
				lec: /*lec*/ ctx[1],
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(badge_1.$$.fragment);
		},
		l(nodes) {
			claim_component(badge_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 4096) badge_1_changes.color = /*badgeColor*/ ctx[12];
			if (dirty[0] & /*lec*/ 2) badge_1_changes.lec = /*lec*/ ctx[1];

			if (dirty[0] & /*badge*/ 2048 | dirty[2] & /*$$scope*/ 4194304) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(badge_1, detaching);
		}
	};
}

// (461:24) <Badge  color={badgeColor}     lec={lec} >
function create_default_slot_1$2(ctx) {
	let t_value = plainText(/*badge*/ ctx[11]) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*badge*/ 2048 && t_value !== (t_value = plainText(/*badge*/ ctx[11]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (468:18) {#if !(swipeout || accordionItem)}
function create_if_block_16(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[70].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[84], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[84], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (382:18) {#if hasHeader}
function create_if_block_15(ctx) {
	let div;
	let t0_value = plainText(/*header*/ ctx[6]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[70].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[84], get_header_slot_context$1);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (header_slot) header_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-header");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = plainText(/*header*/ ctx[6]) + "")) set_data(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[84], dirty, get_header_slot_changes$1),
						get_header_slot_context$1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (header_slot) header_slot.d(detaching);
		}
	};
}

// (390:20) {#if hasTitle}
function create_if_block_14(ctx) {
	let div;
	let t0_value = plainText(/*title*/ ctx[2]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*#slots*/ ctx[70].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[84], get_title_slot_context$1);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (title_slot) title_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-title");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 4) && t0_value !== (t0_value = plainText(/*title*/ ctx[2]) + "")) set_data(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[84], dirty, get_title_slot_changes$1),
						get_title_slot_context$1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (title_slot) title_slot.d(detaching);
		}
	};
}

// (397:20) {#if hasAfter}
function create_if_block_11(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[70]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[84], get_after_start_slot_context);
	let if_block0 = typeof /*after*/ ctx[10] !== 'undefined' && create_if_block_13(ctx);
	let if_block1 = typeof /*badge*/ ctx[11] !== 'undefined' && create_if_block_12(ctx);
	const after_slot_template = /*#slots*/ ctx[70].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[84], get_after_slot_context);
	const after_end_slot_template = /*#slots*/ ctx[70]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[84], get_after_end_slot_context);

	return {
		c() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (after_start_slot) after_start_slot.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (after_slot) after_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (after_end_slot) after_end_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-after");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_hydration(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_hydration(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_start_slot,
						after_start_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[84], dirty, get_after_start_slot_changes),
						get_after_start_slot_context
					);
				}
			}

			if (typeof /*after*/ ctx[10] !== 'undefined') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_13(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[11] !== 'undefined') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_12(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_slot,
						after_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[84], dirty, get_after_slot_changes),
						get_after_slot_context
					);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						after_end_slot,
						after_end_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[84], dirty, get_after_end_slot_changes),
						get_after_end_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};
}

// (400:24) {#if typeof after !== 'undefined'}
function create_if_block_13(ctx) {
	let span;
	let t_value = plainText(/*after*/ ctx[10]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*after*/ 1024 && t_value !== (t_value = plainText(/*after*/ ctx[10]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (403:24) {#if typeof badge !== 'undefined'}
function create_if_block_12(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[12],
				lec: /*lec*/ ctx[1],
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(badge_1.$$.fragment);
		},
		l(nodes) {
			claim_component(badge_1.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 4096) badge_1_changes.color = /*badgeColor*/ ctx[12];
			if (dirty[0] & /*lec*/ 2) badge_1_changes.lec = /*lec*/ ctx[1];

			if (dirty[0] & /*badge*/ 2048 | dirty[2] & /*$$scope*/ 4194304) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(badge_1, detaching);
		}
	};
}

// (404:26) <Badge  color={badgeColor}     lec={lec} >
function create_default_slot$5(ctx) {
	let t_value = plainText(/*badge*/ ctx[11]) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*badge*/ 2048 && t_value !== (t_value = plainText(/*badge*/ ctx[11]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (411:18) {#if hasSubtitle}
function create_if_block_10$1(ctx) {
	let div;
	let t0_value = plainText(/*subtitle*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*#slots*/ ctx[70].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[84], get_subtitle_slot_context);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (subtitle_slot) subtitle_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-subtitle");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 32) && t0_value !== (t0_value = plainText(/*subtitle*/ ctx[5]) + "")) set_data(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						subtitle_slot,
						subtitle_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[84], dirty, get_subtitle_slot_changes),
						get_subtitle_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};
}

// (417:18) {#if hasText}
function create_if_block_9$1(ctx) {
	let div;
	let t0_value = plainText(/*text*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*#slots*/ ctx[70].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[84], get_text_slot_context$2);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (text_slot) text_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-text");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 8) && t0_value !== (t0_value = plainText(/*text*/ ctx[3]) + "")) set_data(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						text_slot,
						text_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[84], dirty, get_text_slot_changes$2),
						get_text_slot_context$2
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (text_slot) text_slot.d(detaching);
		}
	};
}

// (424:18) {#if !(swipeout || accordionItem)}
function create_if_block_8$1(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[70].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[84], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[84], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (427:18) {#if hasFooter}
function create_if_block_7$1(ctx) {
	let div;
	let t0_value = plainText(/*footer*/ ctx[7]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[70].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[84], get_footer_slot_context$1);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (footer_slot) footer_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "item-footer");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = plainText(/*footer*/ ctx[7]) + "")) set_data(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[84], dirty, get_footer_slot_changes$1),
						get_footer_slot_context$1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};
}

// (1084:4) {#if isSortable && sortable !== false && !isSortableOpposite}
function create_if_block_3$8(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "sortable-handler");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (1087:4) {#if swipeout || accordionItem}
function create_if_block_2$9(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[70].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[84], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[84],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[84])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[84], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (332:16) {plainText(title)}
function fallback_block(ctx) {
	let t_value = plainText(/*title*/ ctx[2]) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*title*/ 4 && t_value !== (t_value = plainText(/*title*/ ctx[2]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment$J(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$n, create_if_block_1$e, create_else_block$a];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*divider*/ ctx[13] || /*groupTitle*/ ctx[14]) return 0;
		if (/*isSimple*/ ctx[44]) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx, [-1, -1, -1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

let index$L = 0;

function instance$F($$self, $$props, $$invalidate) {
	let isMedia;
	let isSortable;
	let isSortableOpposite;
	let isSimple;
	let liClasses;
	let contentClasses;
	let linkClasses;
	let linkAttrs;
	let isLink;
	let hasMedia;
	let hasTitle;
	let hasHeader;
	let hasFooter;
	let hasSubtitle;
	let hasText;
	let hasAfter;

	const omit_props_names = [
		"lec","class","title","text","media","subtitle","header","footer","tooltip","tooltipTrigger","link","tabLink","tabLinkActive","selected","href","target","after","badge","badgeColor","mediaItem","mediaList","divider","groupTitle","swipeout","swipeoutOpened","sortable","sortableOpposite","accordionItem","accordionItemOpened","smartSelect","smartSelectParams","noChevron","chevronCenter","checkbox","radio","radioIcon","checked","indeterminate","name","value","readonly","required","disabled","virtualListIndex","routeProps","smartSelectInstance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { title = undefined } = $$props;
	let { text = undefined } = $$props;
	let { media = undefined } = $$props;
	let { subtitle = undefined } = $$props;
	let { header = undefined } = $$props;
	let { footer = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let { link = undefined } = $$props;
	let { tabLink = undefined } = $$props;
	let { tabLinkActive = false } = $$props;
	let { selected = false } = $$props;
	let { href = undefined } = $$props;
	let { target = undefined } = $$props;
	let { after = undefined } = $$props;
	let { badge = undefined } = $$props;
	let { badgeColor = undefined } = $$props;
	let { mediaItem = false } = $$props;
	let { mediaList = false } = $$props;
	let { divider = false } = $$props;
	let { groupTitle = false } = $$props;
	let { swipeout = false } = $$props;
	let { swipeoutOpened = false } = $$props;
	let { sortable = undefined } = $$props;
	let { sortableOpposite = undefined } = $$props;
	let { accordionItem = false } = $$props;
	let { accordionItemOpened = false } = $$props;
	let { smartSelect = false } = $$props;
	let { smartSelectParams = undefined } = $$props;
	let { noChevron = undefined } = $$props;
	let { chevronCenter = undefined } = $$props;
	let { checkbox = undefined } = $$props;
	let { radio = undefined } = $$props;
	let { radioIcon = undefined } = $$props;
	let { checked = undefined } = $$props;
	let { indeterminate = undefined } = $$props;
	let { name = undefined } = $$props;
	let { value = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let { required = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { virtualListIndex = undefined } = $$props;
	let { routeProps = undefined } = $$props;
	let el;
	let linkEl;
	let innerEl;
	let inputEl;
	let f7SmartSelect;

	function smartSelectInstance() {
		return f7SmartSelect;
	}

	let ListContext = getReactiveContext('ListContext', value => {
		$$invalidate(69, ListContext = value || {});
	}) || {};

	/* eslint-enable no-undef */
	let initialWatchedOpened = false;

	function watchSwipeoutOpened(opened) {
		if (!initialWatchedOpened) {
			initialWatchedOpened = true;
			return;
		}

		if (!swipeout) return;

		if (opened) {
			app.f7.swipeout.open(el);
		} else {
			app.f7.swipeout.close(el);
		}
	}

	function onClick(event) {
		if (event.target.tagName.toLowerCase() !== 'input') {
			emit('click', event);
		}
	}

	function onSwipeoutOverswipeEnter(eventEl) {
		if (eventEl !== el) return;
		emit('swipeoutOverswipeEnter');
	}

	function onSwipeoutOverswipeExit(eventEl) {
		if (eventEl !== el) return;
		emit('swipeoutOverswipeExit');
	}

	function onSwipeoutDeleted(eventEl) {
		if (eventEl !== el) return;
		emit('swipeoutDeleted');
	}

	function onSwipeoutDelete(eventEl) {
		if (eventEl !== el) return;
		emit('swipeoutDelete');
	}

	function onSwipeoutClose(eventEl) {
		if (eventEl !== el) return;
		emit('swipeoutClose');
	}

	function onSwipeoutClosed(eventEl) {
		if (eventEl !== el) return;
		emit('swipeoutClosed');
	}

	function onSwipeoutOpen(eventEl) {
		if (eventEl !== el) return;
		emit('swipeoutOpen');
	}

	function onSwipeoutOpened(eventEl) {
		if (eventEl !== el) return;
		emit('swipeoutOpened');
	}

	function onSwipeout(eventEl, progress) {
		if (eventEl !== el) return;
		emit('swipeout', progress);
	}

	function onAccBeforeClose(eventEl, prevent) {
		if (eventEl !== el) return;
		emit('accordionBeforeClose', [prevent]);
	}

	function onAccClose(eventEl) {
		if (eventEl !== el) return;
		emit('accordionClose');
	}

	function onAccClosed(eventEl) {
		if (eventEl !== el) return;
		emit('accordionClosed');
	}

	function onAccBeforeOpen(eventEl, prevent) {
		if (eventEl !== el) return;
		emit('accordionBeforeOpen', [prevent]);
	}

	function onAccOpen(eventEl) {
		if (eventEl !== el) return;
		emit('accordionOpen');
	}

	function onAccOpened(eventEl) {
		if (eventEl !== el) return;
		emit('accordionOpened');
	}

	function onChange(event) {
		emit('change', [event]);
		$$invalidate(0, checked = event.target.checked);
	}

	useSmartSelect(
		{ smartSelect, smartSelectParams },
		instance => {
			f7SmartSelect = instance;
		},
		() => linkEl
	);

	onMount(() => {
		if (indeterminate && inputEl) {
			$$invalidate(31, inputEl.indeterminate = true, inputEl);
		}

		f7ready(() => {
			if (swipeout) {
				app.f7.on('swipeoutOpen', onSwipeoutOpen);
				app.f7.on('swipeoutOpened', onSwipeoutOpened);
				app.f7.on('swipeoutClose', onSwipeoutClose);
				app.f7.on('swipeoutClosed', onSwipeoutClosed);
				app.f7.on('swipeoutDelete', onSwipeoutDelete);
				app.f7.on('swipeoutDeleted', onSwipeoutDeleted);
				app.f7.on('swipeoutOverswipeEnter', onSwipeoutOverswipeEnter);
				app.f7.on('swipeoutOverswipeExit', onSwipeoutOverswipeExit);
				app.f7.on('swipeout', onSwipeout);
			}

			if (accordionItem) {
				app.f7.on('accordionBeforeOpen', onAccBeforeOpen);
				app.f7.on('accordionOpen', onAccOpen);
				app.f7.on('accordionOpened', onAccOpened);
				app.f7.on('accordionBeforeClose', onAccBeforeClose);
				app.f7.on('accordionClose', onAccClose);
				app.f7.on('accordionClosed', onAccClosed);
			}

			if (swipeoutOpened) {
				app.f7.swipeout.open(el);
			}
		});
	});

	afterUpdate(() => {
		if (inputEl) {
			$$invalidate(31, inputEl.indeterminate = indeterminate, inputEl);
		}
	});

	onDestroy(() => {
		if (!app.f7) return;

		if (swipeout) {
			app.f7.off('swipeoutOpen', onSwipeoutOpen);
			app.f7.off('swipeoutOpened', onSwipeoutOpened);
			app.f7.off('swipeoutClose', onSwipeoutClose);
			app.f7.off('swipeoutClosed', onSwipeoutClosed);
			app.f7.off('swipeoutDelete', onSwipeoutDelete);
			app.f7.off('swipeoutDeleted', onSwipeoutDeleted);
			app.f7.off('swipeoutOverswipeEnter', onSwipeoutOverswipeEnter);
			app.f7.off('swipeoutOverswipeExit', onSwipeoutOverswipeExit);
			app.f7.off('swipeout', onSwipeout);
		}

		if (accordionItem) {
			app.f7.off('accordionBeforeOpen', onAccBeforeOpen);
			app.f7.off('accordionOpen', onAccOpen);
			app.f7.off('accordionOpened', onAccOpened);
			app.f7.off('accordionBeforeClose', onAccBeforeClose);
			app.f7.off('accordionClose', onAccClose);
			app.f7.off('accordionClosed', onAccClosed);
		}
	});

	function li_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(28, el);
		});
	}

	function li_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(28, el);
		});
	}

	function div0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			innerEl = $$value;
			$$invalidate(30, innerEl);
		});
	}

	function a_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			linkEl = $$value;
			$$invalidate(29, linkEl);
		});
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(31, inputEl);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			innerEl = $$value;
			$$invalidate(30, innerEl);
		});
	}

	function div0_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			innerEl = $$value;
			$$invalidate(30, innerEl);
		});
	}

	function div0_binding_2($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			innerEl = $$value;
			$$invalidate(30, innerEl);
		});
	}

	function a_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			linkEl = $$value;
			$$invalidate(29, linkEl);
		});
	}

	function input_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(31, inputEl);
		});
	}

	function div_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			innerEl = $$value;
			$$invalidate(30, innerEl);
		});
	}

	function div0_binding_3($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			innerEl = $$value;
			$$invalidate(30, innerEl);
		});
	}

	function li_binding_2($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(28, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(106, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(49, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(1, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(50, className = $$new_props.class);
		if ('title' in $$new_props) $$invalidate(2, title = $$new_props.title);
		if ('text' in $$new_props) $$invalidate(3, text = $$new_props.text);
		if ('media' in $$new_props) $$invalidate(4, media = $$new_props.media);
		if ('subtitle' in $$new_props) $$invalidate(5, subtitle = $$new_props.subtitle);
		if ('header' in $$new_props) $$invalidate(6, header = $$new_props.header);
		if ('footer' in $$new_props) $$invalidate(7, footer = $$new_props.footer);
		if ('tooltip' in $$new_props) $$invalidate(8, tooltip = $$new_props.tooltip);
		if ('tooltipTrigger' in $$new_props) $$invalidate(9, tooltipTrigger = $$new_props.tooltipTrigger);
		if ('link' in $$new_props) $$invalidate(51, link = $$new_props.link);
		if ('tabLink' in $$new_props) $$invalidate(52, tabLink = $$new_props.tabLink);
		if ('tabLinkActive' in $$new_props) $$invalidate(53, tabLinkActive = $$new_props.tabLinkActive);
		if ('selected' in $$new_props) $$invalidate(54, selected = $$new_props.selected);
		if ('href' in $$new_props) $$invalidate(55, href = $$new_props.href);
		if ('target' in $$new_props) $$invalidate(56, target = $$new_props.target);
		if ('after' in $$new_props) $$invalidate(10, after = $$new_props.after);
		if ('badge' in $$new_props) $$invalidate(11, badge = $$new_props.badge);
		if ('badgeColor' in $$new_props) $$invalidate(12, badgeColor = $$new_props.badgeColor);
		if ('mediaItem' in $$new_props) $$invalidate(57, mediaItem = $$new_props.mediaItem);
		if ('mediaList' in $$new_props) $$invalidate(58, mediaList = $$new_props.mediaList);
		if ('divider' in $$new_props) $$invalidate(13, divider = $$new_props.divider);
		if ('groupTitle' in $$new_props) $$invalidate(14, groupTitle = $$new_props.groupTitle);
		if ('swipeout' in $$new_props) $$invalidate(15, swipeout = $$new_props.swipeout);
		if ('swipeoutOpened' in $$new_props) $$invalidate(59, swipeoutOpened = $$new_props.swipeoutOpened);
		if ('sortable' in $$new_props) $$invalidate(16, sortable = $$new_props.sortable);
		if ('sortableOpposite' in $$new_props) $$invalidate(60, sortableOpposite = $$new_props.sortableOpposite);
		if ('accordionItem' in $$new_props) $$invalidate(17, accordionItem = $$new_props.accordionItem);
		if ('accordionItemOpened' in $$new_props) $$invalidate(61, accordionItemOpened = $$new_props.accordionItemOpened);
		if ('smartSelect' in $$new_props) $$invalidate(62, smartSelect = $$new_props.smartSelect);
		if ('smartSelectParams' in $$new_props) $$invalidate(63, smartSelectParams = $$new_props.smartSelectParams);
		if ('noChevron' in $$new_props) $$invalidate(64, noChevron = $$new_props.noChevron);
		if ('chevronCenter' in $$new_props) $$invalidate(65, chevronCenter = $$new_props.chevronCenter);
		if ('checkbox' in $$new_props) $$invalidate(18, checkbox = $$new_props.checkbox);
		if ('radio' in $$new_props) $$invalidate(19, radio = $$new_props.radio);
		if ('radioIcon' in $$new_props) $$invalidate(66, radioIcon = $$new_props.radioIcon);
		if ('checked' in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ('indeterminate' in $$new_props) $$invalidate(67, indeterminate = $$new_props.indeterminate);
		if ('name' in $$new_props) $$invalidate(20, name = $$new_props.name);
		if ('value' in $$new_props) $$invalidate(21, value = $$new_props.value);
		if ('readonly' in $$new_props) $$invalidate(22, readonly = $$new_props.readonly);
		if ('required' in $$new_props) $$invalidate(23, required = $$new_props.required);
		if ('disabled' in $$new_props) $$invalidate(24, disabled = $$new_props.disabled);
		if ('virtualListIndex' in $$new_props) $$invalidate(25, virtualListIndex = $$new_props.virtualListIndex);
		if ('routeProps' in $$new_props) $$invalidate(26, routeProps = $$new_props.routeProps);
		if ('$$scope' in $$new_props) $$invalidate(84, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[1] & /*mediaList, mediaItem*/ 201326592 | $$self.$$.dirty[2] & /*ListContext*/ 128) {
			$: $$invalidate(27, isMedia = mediaList || mediaItem || ListContext.listIsMedia);
		}

		if ($$self.$$.dirty[0] & /*sortable*/ 65536 | $$self.$$.dirty[2] & /*ListContext*/ 128) {
			$: $$invalidate(46, isSortable = sortable === true || sortable === false
			? sortable
			: ListContext.listIsSortable);
		}

		if ($$self.$$.dirty[1] & /*sortableOpposite*/ 536870912 | $$self.$$.dirty[2] & /*ListContext*/ 128) {
			$: $$invalidate(45, isSortableOpposite = sortableOpposite || ListContext.listIsSortableOpposite);
		}

		if ($$self.$$.dirty[2] & /*ListContext*/ 128) {
			$: $$invalidate(44, isSimple = ListContext.listIsSimple);
		}

		$: $$invalidate(43, liClasses = classNames(
			className,
			{
				'item-divider': divider,
				'list-group-title': groupTitle,
				'media-item': isMedia,
				swipeout,
				'accordion-item': accordionItem,
				'accordion-item-opened': accordionItemOpened,
				disabled: disabled && !(radio || checkbox),
				'no-chevron': noChevron,
				'chevron-center': chevronCenter,
				'disallow-sorting': sortable === false
			},
			colorClasses($$props)
		));

		$: $$invalidate(42, contentClasses = classNames(
			className,
			'item-content',
			{
				'item-checkbox': checkbox,
				'item-radio': radio,
				'item-radio-icon-start': radio && radioIcon === 'start',
				'item-radio-icon-end': radio && radioIcon === 'end'
			},
			colorClasses($$props)
		));

		$: $$invalidate(41, linkClasses = classNames(
			{
				'item-link': true,
				'smart-select': smartSelect,
				'tab-link': tabLink || tabLink === '',
				'tab-link-active': tabLinkActive,
				'item-selected': selected
			},
			routerClasses($$props),
			actionsClasses($$props)
		));

		$: $$invalidate(40, linkAttrs = {
			href: link === true ? '' : link || href,
			target,
			'data-tab': isStringProp(tabLink) && tabLink || undefined,
			...routerAttrs($$props),
			...actionsAttrs($$props)
		});

		if ($$self.$$.dirty[0] & /*accordionItem*/ 131072 | $$self.$$.dirty[1] & /*link, href*/ 17825792 | $$self.$$.dirty[2] & /*smartSelect*/ 1) {
			$: $$invalidate(39, isLink = link || href || smartSelect || accordionItem);
		}

		if ($$self.$$.dirty[0] & /*media*/ 16) {
			/* eslint-disable no-undef */
			$: $$invalidate(38, hasMedia = typeof media !== 'undefined' || $$slots.media);
		}

		if ($$self.$$.dirty[0] & /*title*/ 4) {
			$: $$invalidate(37, hasTitle = typeof title !== 'undefined' || $$slots.title);
		}

		if ($$self.$$.dirty[0] & /*header*/ 64) {
			$: $$invalidate(36, hasHeader = typeof header !== 'undefined' || $$slots.header);
		}

		if ($$self.$$.dirty[0] & /*footer*/ 128) {
			$: $$invalidate(35, hasFooter = typeof footer !== 'undefined' || $$slots.footer);
		}

		if ($$self.$$.dirty[0] & /*subtitle*/ 32) {
			$: $$invalidate(34, hasSubtitle = typeof subtitle !== 'undefined' || $$slots.subtitle);
		}

		if ($$self.$$.dirty[0] & /*text*/ 8) {
			$: $$invalidate(33, hasText = typeof text !== 'undefined' || $$slots.text);
		}

		if ($$self.$$.dirty[0] & /*after, badge*/ 3072) {
			$: $$invalidate(32, hasAfter = typeof after !== 'undefined' || typeof badge !== 'undefined' || $$slots.after);
		}

		if ($$self.$$.dirty[1] & /*swipeoutOpened*/ 268435456) {
			$: watchSwipeoutOpened(swipeoutOpened);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		checked,
		lec,
		title,
		text,
		media,
		subtitle,
		header,
		footer,
		tooltip,
		tooltipTrigger,
		after,
		badge,
		badgeColor,
		divider,
		groupTitle,
		swipeout,
		sortable,
		accordionItem,
		checkbox,
		radio,
		name,
		value,
		readonly,
		required,
		disabled,
		virtualListIndex,
		routeProps,
		isMedia,
		el,
		linkEl,
		innerEl,
		inputEl,
		hasAfter,
		hasText,
		hasSubtitle,
		hasFooter,
		hasHeader,
		hasTitle,
		hasMedia,
		isLink,
		linkAttrs,
		linkClasses,
		contentClasses,
		liClasses,
		isSimple,
		isSortableOpposite,
		isSortable,
		onClick,
		onChange,
		$$restProps,
		className,
		link,
		tabLink,
		tabLinkActive,
		selected,
		href,
		target,
		mediaItem,
		mediaList,
		swipeoutOpened,
		sortableOpposite,
		accordionItemOpened,
		smartSelect,
		smartSelectParams,
		noChevron,
		chevronCenter,
		radioIcon,
		indeterminate,
		smartSelectInstance,
		ListContext,
		slots,
		li_binding,
		li_binding_1,
		div0_binding,
		a_binding,
		input_binding,
		div_binding,
		div0_binding_1,
		div0_binding_2,
		a_binding_1,
		input_binding_1,
		div_binding_1,
		div0_binding_3,
		li_binding_2,
		$$scope
	];
}

class List_item extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$F,
			create_fragment$J,
			safe_not_equal,
			{
				lec: 1,
				class: 50,
				title: 2,
				text: 3,
				media: 4,
				subtitle: 5,
				header: 6,
				footer: 7,
				tooltip: 8,
				tooltipTrigger: 9,
				link: 51,
				tabLink: 52,
				tabLinkActive: 53,
				selected: 54,
				href: 55,
				target: 56,
				after: 10,
				badge: 11,
				badgeColor: 12,
				mediaItem: 57,
				mediaList: 58,
				divider: 13,
				groupTitle: 14,
				swipeout: 15,
				swipeoutOpened: 59,
				sortable: 16,
				sortableOpposite: 60,
				accordionItem: 17,
				accordionItemOpened: 61,
				smartSelect: 62,
				smartSelectParams: 63,
				noChevron: 64,
				chevronCenter: 65,
				checkbox: 18,
				radio: 19,
				radioIcon: 66,
				checked: 0,
				indeterminate: 67,
				name: 20,
				value: 21,
				readonly: 22,
				required: 23,
				disabled: 24,
				virtualListIndex: 25,
				routeProps: 26,
				smartSelectInstance: 68
			},
			null,
			[-1, -1, -1, -1]
		);
	}

	get smartSelectInstance() {
		return this.$$.ctx[68];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/list.liquivelte generated by Svelte v3.50.0 */
const get_after_list_slot_changes_1 = dirty => ({});
const get_after_list_slot_context_1 = ctx => ({});
const get_list_slot_changes_1 = dirty => ({});
const get_list_slot_context_1 = ctx => ({});
const get_before_list_slot_changes_1 = dirty => ({});
const get_before_list_slot_context_1 = ctx => ({});
const get_after_list_slot_changes = dirty => ({});
const get_after_list_slot_context = ctx => ({});
const get_list_slot_changes = dirty => ({});
const get_list_slot_context = ctx => ({});
const get_before_list_slot_changes = dirty => ({});
const get_before_list_slot_context = ctx => ({});

// (222:0) {:else}
function create_else_block_1(ctx) {
	let div;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let div_data_sortable_move_elements_value;
	let current;
	const before_list_slot_template = /*#slots*/ ctx[45]["before-list"];
	const before_list_slot = create_slot(before_list_slot_template, ctx, /*$$scope*/ ctx[44], get_before_list_slot_context_1);
	const if_block_creators = [create_if_block_2$8, create_else_block_2];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*hasUlSlots*/ ctx[5] && /*ul*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const after_list_slot_template = /*#slots*/ ctx[45]["after-list"];
	const after_list_slot = create_slot(after_list_slot_template, ctx, /*$$scope*/ ctx[44], get_after_list_slot_context_1);

	let div_levels = [
		{ class: /*classes*/ ctx[4] },
		{
			"data-sortable-move-elements": div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== 'undefined'
			? /*sortableMoveElements*/ ctx[1].toString()
			: undefined
		},
		restProps(/*$$restProps*/ ctx[7])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (before_list_slot) before_list_slot.c();
			t0 = space();
			if_block.c();
			t1 = space();
			if (after_list_slot) after_list_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {
				class: true,
				"data-sortable-move-elements": true
			});

			var div_nodes = children(div);
			if (before_list_slot) before_list_slot.l(div_nodes);
			t0 = claim_space(div_nodes);
			if_block.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (after_list_slot) after_list_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (before_list_slot) {
				before_list_slot.m(div, null);
			}

			append_hydration(div, t0);
			if_blocks[current_block_type_index].m(div, null);
			append_hydration(div, t1);

			if (after_list_slot) {
				after_list_slot.m(div, null);
			}

			/*div_binding*/ ctx[47](div);
			current = true;
		},
		p(ctx, dirty) {
			if (before_list_slot) {
				if (before_list_slot.p && (!current || dirty[1] & /*$$scope*/ 8192)) {
					update_slot_base(
						before_list_slot,
						before_list_slot_template,
						ctx,
						/*$$scope*/ ctx[44],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[44])
						: get_slot_changes(before_list_slot_template, /*$$scope*/ ctx[44], dirty, get_before_list_slot_changes_1),
						get_before_list_slot_context_1
					);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, t1);
			}

			if (after_list_slot) {
				if (after_list_slot.p && (!current || dirty[1] & /*$$scope*/ 8192)) {
					update_slot_base(
						after_list_slot,
						after_list_slot_template,
						ctx,
						/*$$scope*/ ctx[44],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[44])
						: get_slot_changes(after_list_slot_template, /*$$scope*/ ctx[44], dirty, get_after_list_slot_changes_1),
						get_after_list_slot_context_1
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				(!current || dirty[0] & /*sortableMoveElements*/ 2 && div_data_sortable_move_elements_value !== (div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== 'undefined'
				? /*sortableMoveElements*/ ctx[1].toString()
				: undefined)) && {
					"data-sortable-move-elements": div_data_sortable_move_elements_value
				},
				dirty[0] & /*$$restProps*/ 128 && restProps(/*$$restProps*/ ctx[7])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(before_list_slot, local);
			transition_in(if_block);
			transition_in(after_list_slot, local);
			current = true;
		},
		o(local) {
			transition_out(before_list_slot, local);
			transition_out(if_block);
			transition_out(after_list_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (before_list_slot) before_list_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (after_list_slot) after_list_slot.d(detaching);
			/*div_binding*/ ctx[47](null);
		}
	};
}

// (201:0) {#if form}
function create_if_block$m(ctx) {
	let form_1;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let form_1_data_sortable_move_elements_value;
	let current;
	let mounted;
	let dispose;
	const before_list_slot_template = /*#slots*/ ctx[45]["before-list"];
	const before_list_slot = create_slot(before_list_slot_template, ctx, /*$$scope*/ ctx[44], get_before_list_slot_context);
	const if_block_creators = [create_if_block_1$d, create_else_block$9];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*hasUlSlots*/ ctx[5] && /*ul*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const after_list_slot_template = /*#slots*/ ctx[45]["after-list"];
	const after_list_slot = create_slot(after_list_slot_template, ctx, /*$$scope*/ ctx[44], get_after_list_slot_context);

	let form_1_levels = [
		{ class: /*classes*/ ctx[4] },
		{
			"data-sortable-move-elements": form_1_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== 'undefined'
			? /*sortableMoveElements*/ ctx[1].toString()
			: undefined
		},
		restProps(/*$$restProps*/ ctx[7])
	];

	let form_1_data = {};

	for (let i = 0; i < form_1_levels.length; i += 1) {
		form_1_data = assign(form_1_data, form_1_levels[i]);
	}

	return {
		c() {
			form_1 = element("form");
			if (before_list_slot) before_list_slot.c();
			t0 = space();
			if_block.c();
			t1 = space();
			if (after_list_slot) after_list_slot.c();
			this.h();
		},
		l(nodes) {
			form_1 = claim_element(nodes, "FORM", {
				class: true,
				"data-sortable-move-elements": true
			});

			var form_1_nodes = children(form_1);
			if (before_list_slot) before_list_slot.l(form_1_nodes);
			t0 = claim_space(form_1_nodes);
			if_block.l(form_1_nodes);
			t1 = claim_space(form_1_nodes);
			if (after_list_slot) after_list_slot.l(form_1_nodes);
			form_1_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(form_1, form_1_data);
		},
		m(target, anchor) {
			insert_hydration(target, form_1, anchor);

			if (before_list_slot) {
				before_list_slot.m(form_1, null);
			}

			append_hydration(form_1, t0);
			if_blocks[current_block_type_index].m(form_1, null);
			append_hydration(form_1, t1);

			if (after_list_slot) {
				after_list_slot.m(form_1, null);
			}

			/*form_1_binding*/ ctx[46](form_1);
			current = true;

			if (!mounted) {
				dispose = listen(form_1, "submit", /*onSubmit*/ ctx[6]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (before_list_slot) {
				if (before_list_slot.p && (!current || dirty[1] & /*$$scope*/ 8192)) {
					update_slot_base(
						before_list_slot,
						before_list_slot_template,
						ctx,
						/*$$scope*/ ctx[44],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[44])
						: get_slot_changes(before_list_slot_template, /*$$scope*/ ctx[44], dirty, get_before_list_slot_changes),
						get_before_list_slot_context
					);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(form_1, t1);
			}

			if (after_list_slot) {
				if (after_list_slot.p && (!current || dirty[1] & /*$$scope*/ 8192)) {
					update_slot_base(
						after_list_slot,
						after_list_slot_template,
						ctx,
						/*$$scope*/ ctx[44],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[44])
						: get_slot_changes(after_list_slot_template, /*$$scope*/ ctx[44], dirty, get_after_list_slot_changes),
						get_after_list_slot_context
					);
				}
			}

			set_attributes(form_1, form_1_data = get_spread_update(form_1_levels, [
				(!current || dirty[0] & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				(!current || dirty[0] & /*sortableMoveElements*/ 2 && form_1_data_sortable_move_elements_value !== (form_1_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== 'undefined'
				? /*sortableMoveElements*/ ctx[1].toString()
				: undefined)) && {
					"data-sortable-move-elements": form_1_data_sortable_move_elements_value
				},
				dirty[0] & /*$$restProps*/ 128 && restProps(/*$$restProps*/ ctx[7])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(before_list_slot, local);
			transition_in(if_block);
			transition_in(after_list_slot, local);
			current = true;
		},
		o(local) {
			transition_out(before_list_slot, local);
			transition_out(if_block);
			transition_out(after_list_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(form_1);
			if (before_list_slot) before_list_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (after_list_slot) after_list_slot.d(detaching);
			/*form_1_binding*/ ctx[46](null);
			mounted = false;
			dispose();
		}
	};
}

// (237:4) {:else}
function create_else_block_2(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[45].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[44], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 8192)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[44],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[44])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[44], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (232:4) {#if hasUlSlots && ul}
function create_if_block_2$8(ctx) {
	let ul_1;
	let t;
	let current;
	const list_slot_template = /*#slots*/ ctx[45].list;
	const list_slot = create_slot(list_slot_template, ctx, /*$$scope*/ ctx[44], get_list_slot_context_1);
	const default_slot_template = /*#slots*/ ctx[45].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[44], null);

	return {
		c() {
			ul_1 = element("ul");
			if (list_slot) list_slot.c();
			t = space();
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			ul_1 = claim_element(nodes, "UL", {});
			var ul_1_nodes = children(ul_1);
			if (list_slot) list_slot.l(ul_1_nodes);
			t = claim_space(ul_1_nodes);
			if (default_slot) default_slot.l(ul_1_nodes);
			ul_1_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, ul_1, anchor);

			if (list_slot) {
				list_slot.m(ul_1, null);
			}

			append_hydration(ul_1, t);

			if (default_slot) {
				default_slot.m(ul_1, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (list_slot) {
				if (list_slot.p && (!current || dirty[1] & /*$$scope*/ 8192)) {
					update_slot_base(
						list_slot,
						list_slot_template,
						ctx,
						/*$$scope*/ ctx[44],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[44])
						: get_slot_changes(list_slot_template, /*$$scope*/ ctx[44], dirty, get_list_slot_changes_1),
						get_list_slot_context_1
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 8192)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[44],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[44])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[44], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(list_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(list_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(ul_1);
			if (list_slot) list_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (217:4) {:else}
function create_else_block$9(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[45].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[44], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 8192)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[44],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[44])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[44], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (212:4) {#if hasUlSlots && ul}
function create_if_block_1$d(ctx) {
	let ul_1;
	let t;
	let current;
	const list_slot_template = /*#slots*/ ctx[45].list;
	const list_slot = create_slot(list_slot_template, ctx, /*$$scope*/ ctx[44], get_list_slot_context);
	const default_slot_template = /*#slots*/ ctx[45].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[44], null);

	return {
		c() {
			ul_1 = element("ul");
			if (list_slot) list_slot.c();
			t = space();
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			ul_1 = claim_element(nodes, "UL", {});
			var ul_1_nodes = children(ul_1);
			if (list_slot) list_slot.l(ul_1_nodes);
			t = claim_space(ul_1_nodes);
			if (default_slot) default_slot.l(ul_1_nodes);
			ul_1_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, ul_1, anchor);

			if (list_slot) {
				list_slot.m(ul_1, null);
			}

			append_hydration(ul_1, t);

			if (default_slot) {
				default_slot.m(ul_1, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (list_slot) {
				if (list_slot.p && (!current || dirty[1] & /*$$scope*/ 8192)) {
					update_slot_base(
						list_slot,
						list_slot_template,
						ctx,
						/*$$scope*/ ctx[44],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[44])
						: get_slot_changes(list_slot_template, /*$$scope*/ ctx[44], dirty, get_list_slot_changes),
						get_list_slot_context
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 8192)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[44],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[44])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[44], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(list_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(list_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(ul_1);
			if (list_slot) list_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$I(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$m, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*form*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

let index$K = 0;

function instance$E($$self, $$props, $$invalidate) {
	let hasUlSlots;
	let classes;

	const omit_props_names = [
		"lec","class","ul","inset","xsmallInset","smallInset","mediumInset","largeInset","xlargeInset","mediaList","sortable","sortableTapHold","sortableEnabled","sortableMoveElements","sortableOpposite","accordionList","accordionOpposite","contactsList","simpleList","linksList","menuList","noHairlines","noHairlinesBetween","noHairlinesMd","noHairlinesBetweenMd","noHairlinesIos","noHairlinesBetweenIos","noHairlinesAurora","noHairlinesBetweenAurora","noChevron","chevronCenter","tab","tabActive","form","formStoreData","inlineLabels","virtualList","virtualListParams","virtualListInstance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { ul = true } = $$props;
	let { inset = false } = $$props;
	let { xsmallInset = false } = $$props;
	let { smallInset = false } = $$props;
	let { mediumInset = false } = $$props;
	let { largeInset = false } = $$props;
	let { xlargeInset = false } = $$props;
	let { mediaList = false } = $$props;
	let { sortable = false } = $$props;
	let { sortableTapHold = false } = $$props;
	let { sortableEnabled = false } = $$props;
	let { sortableMoveElements = undefined } = $$props;
	let { sortableOpposite = false } = $$props;
	let { accordionList = false } = $$props;
	let { accordionOpposite = false } = $$props;
	let { contactsList = false } = $$props;
	let { simpleList = false } = $$props;
	let { linksList = false } = $$props;
	let { menuList = false } = $$props;
	let { noHairlines = false } = $$props;
	let { noHairlinesBetween = false } = $$props;
	let { noHairlinesMd = false } = $$props;
	let { noHairlinesBetweenMd = false } = $$props;
	let { noHairlinesIos = false } = $$props;
	let { noHairlinesBetweenIos = false } = $$props;
	let { noHairlinesAurora = false } = $$props;
	let { noHairlinesBetweenAurora = false } = $$props;
	let { noChevron = false } = $$props;
	let { chevronCenter = false } = $$props;
	let { tab = false } = $$props;
	let { tabActive = false } = $$props;
	let { form = false } = $$props;
	let { formStoreData = false } = $$props;
	let { inlineLabels = false } = $$props;
	let { virtualList = false } = $$props;
	let { virtualListParams = undefined } = $$props;
	let el;
	let f7VirtualList;

	function virtualListInstance() {
		return f7VirtualList;
	}

	setReactiveContext('ListContext', () => ({
		listIsMedia: mediaList,
		listIsSimple: simpleList,
		listIsSortable: sortable,
		listIsSortableOpposite: sortableOpposite
	}));

	function onSubmit(event) {
		emit('submit', [event]);
	}

	function onSortableEnable(sortableEl) {
		if (sortableEl !== el) return;
		emit('sortableEnable');
	}

	function onSortableDisable(sortableEl) {
		if (sortableEl !== el) return;
		emit('sortableDisable');
	}

	function onSortableSort(listItemEl, sortData, listEl) {
		if (listEl !== el) return;
		emit('sortableSort', [sortData]);
	}

	function onSortableMove(listItemEl, listEl) {
		if (listEl !== el) return;
		emit('sortableMove', [listItemEl, listEl]);
	}

	useTab(() => el, emit);

	onMount(() => {
		f7ready(() => {
			app.f7.on('sortableEnable', onSortableEnable);
			app.f7.on('sortableDisable', onSortableDisable);
			app.f7.on('sortableSort', onSortableSort);
			app.f7.on('sortableMove', onSortableMove);
			if (!virtualList) return;
			const vlParams = virtualListParams || {};
			if (!vlParams.renderItem && !vlParams.renderExternal) return;

			f7VirtualList = app.f7.virtualList.create(extend(
				{
					el,
					on: {
						itemBeforeInsert(itemEl, item) {
							const vl = this;
							emit('virtualItemBeforeInsert', [vl, itemEl, item]);
						},
						beforeClear(fragment) {
							const vl = this;
							emit('virtualBeforeClear', [vl, fragment]);
						},
						itemsBeforeInsert(fragment) {
							const vl = this;
							emit('virtualItemsBeforeInsert', [vl, fragment]);
						},
						itemsAfterInsert(fragment) {
							const vl = this;
							emit('virtualItemsAfterInsert', [vl, fragment]);
						}
					}
				},
				vlParams
			));
		});
	});

	onDestroy(() => {
		if (!app.f7) return;
		app.f7.off('sortableEnable', onSortableEnable);
		app.f7.off('sortableDisable', onSortableDisable);
		app.f7.off('sortableSort', onSortableSort);
		app.f7.off('sortableMove', onSortableMove);

		if (f7VirtualList && f7VirtualList.destroy) {
			f7VirtualList.destroy();
			f7VirtualList = null;
		}
	});

	function form_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(55, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(8, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(9, className = $$new_props.class);
		if ('ul' in $$new_props) $$invalidate(0, ul = $$new_props.ul);
		if ('inset' in $$new_props) $$invalidate(10, inset = $$new_props.inset);
		if ('xsmallInset' in $$new_props) $$invalidate(11, xsmallInset = $$new_props.xsmallInset);
		if ('smallInset' in $$new_props) $$invalidate(12, smallInset = $$new_props.smallInset);
		if ('mediumInset' in $$new_props) $$invalidate(13, mediumInset = $$new_props.mediumInset);
		if ('largeInset' in $$new_props) $$invalidate(14, largeInset = $$new_props.largeInset);
		if ('xlargeInset' in $$new_props) $$invalidate(15, xlargeInset = $$new_props.xlargeInset);
		if ('mediaList' in $$new_props) $$invalidate(16, mediaList = $$new_props.mediaList);
		if ('sortable' in $$new_props) $$invalidate(17, sortable = $$new_props.sortable);
		if ('sortableTapHold' in $$new_props) $$invalidate(18, sortableTapHold = $$new_props.sortableTapHold);
		if ('sortableEnabled' in $$new_props) $$invalidate(19, sortableEnabled = $$new_props.sortableEnabled);
		if ('sortableMoveElements' in $$new_props) $$invalidate(1, sortableMoveElements = $$new_props.sortableMoveElements);
		if ('sortableOpposite' in $$new_props) $$invalidate(20, sortableOpposite = $$new_props.sortableOpposite);
		if ('accordionList' in $$new_props) $$invalidate(21, accordionList = $$new_props.accordionList);
		if ('accordionOpposite' in $$new_props) $$invalidate(22, accordionOpposite = $$new_props.accordionOpposite);
		if ('contactsList' in $$new_props) $$invalidate(23, contactsList = $$new_props.contactsList);
		if ('simpleList' in $$new_props) $$invalidate(24, simpleList = $$new_props.simpleList);
		if ('linksList' in $$new_props) $$invalidate(25, linksList = $$new_props.linksList);
		if ('menuList' in $$new_props) $$invalidate(26, menuList = $$new_props.menuList);
		if ('noHairlines' in $$new_props) $$invalidate(27, noHairlines = $$new_props.noHairlines);
		if ('noHairlinesBetween' in $$new_props) $$invalidate(28, noHairlinesBetween = $$new_props.noHairlinesBetween);
		if ('noHairlinesMd' in $$new_props) $$invalidate(29, noHairlinesMd = $$new_props.noHairlinesMd);
		if ('noHairlinesBetweenMd' in $$new_props) $$invalidate(30, noHairlinesBetweenMd = $$new_props.noHairlinesBetweenMd);
		if ('noHairlinesIos' in $$new_props) $$invalidate(31, noHairlinesIos = $$new_props.noHairlinesIos);
		if ('noHairlinesBetweenIos' in $$new_props) $$invalidate(32, noHairlinesBetweenIos = $$new_props.noHairlinesBetweenIos);
		if ('noHairlinesAurora' in $$new_props) $$invalidate(33, noHairlinesAurora = $$new_props.noHairlinesAurora);
		if ('noHairlinesBetweenAurora' in $$new_props) $$invalidate(34, noHairlinesBetweenAurora = $$new_props.noHairlinesBetweenAurora);
		if ('noChevron' in $$new_props) $$invalidate(35, noChevron = $$new_props.noChevron);
		if ('chevronCenter' in $$new_props) $$invalidate(36, chevronCenter = $$new_props.chevronCenter);
		if ('tab' in $$new_props) $$invalidate(37, tab = $$new_props.tab);
		if ('tabActive' in $$new_props) $$invalidate(38, tabActive = $$new_props.tabActive);
		if ('form' in $$new_props) $$invalidate(2, form = $$new_props.form);
		if ('formStoreData' in $$new_props) $$invalidate(39, formStoreData = $$new_props.formStoreData);
		if ('inlineLabels' in $$new_props) $$invalidate(40, inlineLabels = $$new_props.inlineLabels);
		if ('virtualList' in $$new_props) $$invalidate(41, virtualList = $$new_props.virtualList);
		if ('virtualListParams' in $$new_props) $$invalidate(42, virtualListParams = $$new_props.virtualListParams);
		if ('$$scope' in $$new_props) $$invalidate(44, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(4, classes = classNames(
			className,
			'list',
			{
				inset,
				'xsmall-inset': xsmallInset,
				'small-inset': smallInset,
				'medium-inset': mediumInset,
				'large-inset': largeInset,
				'xlarge-inset': xlargeInset,
				'media-list': mediaList,
				'simple-list': simpleList,
				'links-list': linksList,
				'menu-list': menuList,
				sortable,
				'sortable-tap-hold': sortableTapHold,
				'sortable-enabled': sortableEnabled,
				'sortable-opposite': sortableOpposite,
				'accordion-list': accordionList,
				'accordion-opposite': accordionOpposite,
				'contacts-list': contactsList,
				'virtual-list': virtualList,
				tab,
				'tab-active': tabActive,
				'no-hairlines': noHairlines,
				'no-hairlines-md': noHairlinesMd,
				'no-hairlines-ios': noHairlinesIos,
				'no-hairlines-aurora': noHairlinesAurora,
				'no-hairlines-between': noHairlinesBetween,
				'no-hairlines-between-md': noHairlinesBetweenMd,
				'no-hairlines-between-ios': noHairlinesBetweenIos,
				'no-hairlines-between-aurora': noHairlinesBetweenAurora,
				'form-store-data': formStoreData,
				'inline-labels': inlineLabels,
				'no-chevron': noChevron,
				'chevron-center': chevronCenter
			},
			colorClasses($$props)
		));
	};

	$: $$invalidate(5, hasUlSlots = $$slots.default || $$slots.list);
	$$props = exclude_internal_props($$props);

	return [
		ul,
		sortableMoveElements,
		form,
		el,
		classes,
		hasUlSlots,
		onSubmit,
		$$restProps,
		lec,
		className,
		inset,
		xsmallInset,
		smallInset,
		mediumInset,
		largeInset,
		xlargeInset,
		mediaList,
		sortable,
		sortableTapHold,
		sortableEnabled,
		sortableOpposite,
		accordionList,
		accordionOpposite,
		contactsList,
		simpleList,
		linksList,
		menuList,
		noHairlines,
		noHairlinesBetween,
		noHairlinesMd,
		noHairlinesBetweenMd,
		noHairlinesIos,
		noHairlinesBetweenIos,
		noHairlinesAurora,
		noHairlinesBetweenAurora,
		noChevron,
		chevronCenter,
		tab,
		tabActive,
		formStoreData,
		inlineLabels,
		virtualList,
		virtualListParams,
		virtualListInstance,
		$$scope,
		slots,
		form_1_binding,
		div_binding
	];
}

class List extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$E,
			create_fragment$I,
			safe_not_equal,
			{
				lec: 8,
				class: 9,
				ul: 0,
				inset: 10,
				xsmallInset: 11,
				smallInset: 12,
				mediumInset: 13,
				largeInset: 14,
				xlargeInset: 15,
				mediaList: 16,
				sortable: 17,
				sortableTapHold: 18,
				sortableEnabled: 19,
				sortableMoveElements: 1,
				sortableOpposite: 20,
				accordionList: 21,
				accordionOpposite: 22,
				contactsList: 23,
				simpleList: 24,
				linksList: 25,
				menuList: 26,
				noHairlines: 27,
				noHairlinesBetween: 28,
				noHairlinesMd: 29,
				noHairlinesBetweenMd: 30,
				noHairlinesIos: 31,
				noHairlinesBetweenIos: 32,
				noHairlinesAurora: 33,
				noHairlinesBetweenAurora: 34,
				noChevron: 35,
				chevronCenter: 36,
				tab: 37,
				tabActive: 38,
				form: 2,
				formStoreData: 39,
				inlineLabels: 40,
				virtualList: 41,
				virtualListParams: 42,
				virtualListInstance: 43
			},
			null,
			[-1, -1]
		);
	}

	get virtualListInstance() {
		return this.$$.ctx[43];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/login-screen-title.liquivelte generated by Svelte v3.50.0 */

function create_fragment$H(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$J = 0;

function instance$D($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'login-screen-title', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, $$scope, slots];
}

class Login_screen_title extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$D, create_fragment$H, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/menu-dropdown-item.liquivelte generated by Svelte v3.50.0 */

function create_else_block$8(ctx) {
	let div;
	let t0_value = plainText(/*text*/ ctx[0]) + "";
	let t0;
	let t1;
	let useRouteProps_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);
	let div_levels = [{ class: /*classes*/ ctx[4] }, /*attrs*/ ctx[5]];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[17](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "click", /*onClick*/ ctx[6]),
					action_destroyer(useRouteProps_action = useRouteProps.call(null, div, /*routeProps*/ ctx[1]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*text*/ 1) && t0_value !== (t0_value = plainText(/*text*/ ctx[0]) + "")) set_data(t0, t0_value);

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*attrs*/ 32 && /*attrs*/ ctx[5]
			]));

			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty & /*routeProps*/ 2) useRouteProps_action.update.call(null, /*routeProps*/ ctx[1]);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[17](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (68:0) {#if isLink}
function create_if_block$l(ctx) {
	let a;
	let t0_value = plainText(/*text*/ ctx[0]) + "";
	let t0;
	let t1;
	let useRouteProps_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);
	let a_levels = [{ class: /*classes*/ ctx[4] }, /*attrs*/ ctx[5]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			a = claim_element(nodes, "A", { class: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			t1 = claim_space(a_nodes);
			if (default_slot) default_slot.l(a_nodes);
			a_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(a, a_data);
		},
		m(target, anchor) {
			insert_hydration(target, a, anchor);
			append_hydration(a, t0);
			append_hydration(a, t1);

			if (default_slot) {
				default_slot.m(a, null);
			}

			/*a_binding*/ ctx[16](a);
			current = true;

			if (!mounted) {
				dispose = [
					listen(a, "click", /*onClick*/ ctx[6]),
					action_destroyer(useRouteProps_action = useRouteProps.call(null, a, /*routeProps*/ ctx[1]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if ((!current || dirty & /*text*/ 1) && t0_value !== (t0_value = plainText(/*text*/ ctx[0]) + "")) set_data(t0, t0_value);

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
						null
					);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*attrs*/ 32 && /*attrs*/ ctx[5]
			]));

			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty & /*routeProps*/ 2) useRouteProps_action.update.call(null, /*routeProps*/ ctx[1]);
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if (default_slot) default_slot.d(detaching);
			/*a_binding*/ ctx[16](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$G(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$l, create_else_block$8];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isLink*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

let index$I = 0;

function instance$C($$self, $$props, $$invalidate) {
	let hrefComputed;
	let attrs;
	let isLink;
	let classes;
	const omit_props_names = ["lec","class","text","href","link","target","divider","routeProps"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { text = undefined } = $$props;
	let { href = undefined } = $$props;
	let { link = undefined } = $$props;
	let { target = undefined } = $$props;
	let { divider = undefined } = $$props;
	let { routeProps = undefined } = $$props;
	let el;

	function onClick(e) {
		emit('click', [e]);
	}

	function a_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(20, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(21, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(7, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ('text' in $$new_props) $$invalidate(0, text = $$new_props.text);
		if ('href' in $$new_props) $$invalidate(9, href = $$new_props.href);
		if ('link' in $$new_props) $$invalidate(10, link = $$new_props.link);
		if ('target' in $$new_props) $$invalidate(11, target = $$new_props.target);
		if ('divider' in $$new_props) $$invalidate(12, divider = $$new_props.divider);
		if ('routeProps' in $$new_props) $$invalidate(1, routeProps = $$new_props.routeProps);
		if ('$$scope' in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*href, link*/ 1536) {
			$: $$invalidate(13, hrefComputed = typeof href === 'undefined' && link ? '#' : href);
		}

		$: $$invalidate(5, attrs = extend(
			{
				href: hrefComputed,
				target,
				...restProps($$restProps)
			},
			routerAttrs($$props),
			actionsAttrs($$props)
		));

		if ($$self.$$.dirty & /*link, href*/ 1536) {
			$: $$invalidate(2, isLink = link || href || href === '');
		}

		$: $$invalidate(4, classes = classNames(
			{
				'menu-dropdown-link': isLink && !divider,
				'menu-dropdown-item': !isLink && !divider,
				'menu-dropdown-divider': divider
			},
			className,
			colorClasses($$props),
			routerClasses($$props),
			actionsClasses($$props),
			{
				'menu-close': typeof menuClose === 'undefined'
			}
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		text,
		routeProps,
		isLink,
		el,
		classes,
		attrs,
		onClick,
		lec,
		className,
		href,
		link,
		target,
		divider,
		hrefComputed,
		$$scope,
		slots,
		a_binding,
		div_binding
	];
}

class Menu_dropdown_item extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$C, create_fragment$G, safe_not_equal, {
			lec: 7,
			class: 8,
			text: 0,
			href: 9,
			link: 10,
			target: 11,
			divider: 12,
			routeProps: 1
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/menu-dropdown.liquivelte generated by Svelte v3.50.0 */

function create_fragment$F(ctx) {
	let div1;
	let div0;
	let div0_style_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);
	let div1_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
			var div0_nodes = children(div0);
			if (default_slot) default_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "menu-dropdown-content");
			attr(div0, "style", div0_style_value = /*contentHeight*/ ctx[0] && `height: ${/*contentHeight*/ ctx[0]}`);
			set_attributes(div1, div1_data);
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);
			append_hydration(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[10],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*contentHeight*/ 1 && div0_style_value !== (div0_style_value = /*contentHeight*/ ctx[0] && `height: ${/*contentHeight*/ ctx[0]}`)) {
				attr(div0, "style", div0_style_value);
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$H = 0;

function instance$B($$self, $$props, $$invalidate) {
	let positionComputed;
	let classes;
	const omit_props_names = ["lec","class","contentHeight","position","left","center","right"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let { contentHeight = undefined } = $$props;
	let { position = undefined } = $$props;
	let { left = undefined } = $$props;
	let { center = undefined } = $$props;
	let { right = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(3, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('contentHeight' in $$new_props) $$invalidate(0, contentHeight = $$new_props.contentHeight);
		if ('position' in $$new_props) $$invalidate(5, position = $$new_props.position);
		if ('left' in $$new_props) $$invalidate(6, left = $$new_props.left);
		if ('center' in $$new_props) $$invalidate(7, center = $$new_props.center);
		if ('right' in $$new_props) $$invalidate(8, right = $$new_props.right);
		if ('$$scope' in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*position, left, center, right*/ 480) {
			$: $$invalidate(9, positionComputed = (() => {
				let pos = position || 'left';
				if (left) pos = 'left';
				if (center) pos = 'center';
				if (right) pos = 'right';
				return pos;
			})());
		}

		$: $$invalidate(1, classes = classNames('menu-dropdown', `menu-dropdown-${positionComputed}`, colorClasses($$props), className));
	};

	$$props = exclude_internal_props($$props);

	return [
		contentHeight,
		classes,
		$$restProps,
		lec,
		className,
		position,
		left,
		center,
		right,
		positionComputed,
		$$scope,
		slots
	];
}

class Menu_dropdown extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$B, create_fragment$F, safe_not_equal, {
			lec: 3,
			class: 4,
			contentHeight: 0,
			position: 5,
			left: 6,
			center: 7,
			right: 8
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/menu-item.liquivelte generated by Svelte v3.50.0 */
const get_text_slot_changes_1 = dirty => ({});
const get_text_slot_context_1 = ctx => ({});
const get_text_slot_changes$1 = dirty => ({});
const get_text_slot_context$1 = ctx => ({});

// (122:0) {:else}
function create_else_block$7(ctx) {
	let div;
	let t;
	let div_class_value;
	let useTooltip_action;
	let useRouteProps_action;
	let current;
	let mounted;
	let dispose;
	let if_block = (/*text*/ ctx[1] != undefined || /*hasTextSlots*/ ctx[5] || /*icon*/ ctx[8]) && create_if_block_3$7(ctx);
	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

	let div_levels = [
		{
			class: div_class_value = "menu-item " + /*classes*/ ctx[9]
		},
		/*attrs*/ ctx[10]
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[23](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "click", /*onClick*/ ctx[11]),
					action_destroyer(useTooltip_action = useTooltip.call(null, div, {
						tooltip: /*tooltip*/ ctx[2],
						tooltipTrigger: /*tooltipTrigger*/ ctx[3]
					})),
					action_destroyer(useRouteProps_action = useRouteProps.call(null, div, /*routeProps*/ ctx[4]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*text*/ ctx[1] != undefined || /*hasTextSlots*/ ctx[5] || /*icon*/ ctx[8]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*text, hasTextSlots, icon*/ 290) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_3$7(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 1048576)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 512 && div_class_value !== (div_class_value = "menu-item " + /*classes*/ ctx[9])) && { class: div_class_value },
				dirty[0] & /*attrs*/ 1024 && /*attrs*/ ctx[10]
			]));

			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 12) useTooltip_action.update.call(null, {
				tooltip: /*tooltip*/ ctx[2],
				tooltipTrigger: /*tooltipTrigger*/ ctx[3]
			});

			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 16) useRouteProps_action.update.call(null, /*routeProps*/ ctx[4]);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[23](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (102:0) {#if isLink }
function create_if_block$k(ctx) {
	let a;
	let t;
	let a_class_value;
	let useTooltip_action;
	let useRouteProps_action;
	let current;
	let mounted;
	let dispose;
	let if_block = (/*text*/ ctx[1] != undefined || /*hasTextSlots*/ ctx[5] || /*icon*/ ctx[8]) && create_if_block_1$c(ctx);
	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

	let a_levels = [
		{
			class: a_class_value = "menu-item " + /*classes*/ ctx[9]
		},
		/*attrs*/ ctx[10]
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = element("a");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			a = claim_element(nodes, "A", { class: true });
			var a_nodes = children(a);
			if (if_block) if_block.l(a_nodes);
			t = claim_space(a_nodes);
			if (default_slot) default_slot.l(a_nodes);
			a_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(a, a_data);
		},
		m(target, anchor) {
			insert_hydration(target, a, anchor);
			if (if_block) if_block.m(a, null);
			append_hydration(a, t);

			if (default_slot) {
				default_slot.m(a, null);
			}

			/*a_binding*/ ctx[22](a);
			current = true;

			if (!mounted) {
				dispose = [
					listen(a, "click", /*onClick*/ ctx[11]),
					action_destroyer(useTooltip_action = useTooltip.call(null, a, {
						tooltip: /*tooltip*/ ctx[2],
						tooltipTrigger: /*tooltipTrigger*/ ctx[3]
					})),
					action_destroyer(useRouteProps_action = useRouteProps.call(null, a, /*routeProps*/ ctx[4]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*text*/ ctx[1] != undefined || /*hasTextSlots*/ ctx[5] || /*icon*/ ctx[8]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*text, hasTextSlots, icon*/ 290) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$c(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(a, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 1048576)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
						null
					);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty[0] & /*classes*/ 512 && a_class_value !== (a_class_value = "menu-item " + /*classes*/ ctx[9])) && { class: a_class_value },
				dirty[0] & /*attrs*/ 1024 && /*attrs*/ ctx[10]
			]));

			if (useTooltip_action && is_function(useTooltip_action.update) && dirty[0] & /*tooltip, tooltipTrigger*/ 12) useTooltip_action.update.call(null, {
				tooltip: /*tooltip*/ ctx[2],
				tooltipTrigger: /*tooltipTrigger*/ ctx[3]
			});

			if (useRouteProps_action && is_function(useRouteProps_action.update) && dirty[0] & /*routeProps*/ 16) useRouteProps_action.update.call(null, /*routeProps*/ ctx[4]);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			/*a_binding*/ ctx[22](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (131:4) {#if text != undefined || hasTextSlots || icon }
function create_if_block_3$7(ctx) {
	let div;
	let t0_value = plainText(/*text*/ ctx[1]) + "";
	let t0;
	let t1;
	let t2;
	let current;
	let if_block = /*icon*/ ctx[8] && create_if_block_4$3(ctx);
	const text_slot_template = /*#slots*/ ctx[21].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[20], get_text_slot_context_1);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			if (text_slot) text_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (text_slot) text_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "menu-item-content");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t2);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 2) && t0_value !== (t0_value = plainText(/*text*/ ctx[1]) + "")) set_data(t0, t0_value);

			if (/*icon*/ ctx[8]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*icon*/ 256) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_4$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t2);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (text_slot) {
				if (text_slot.p && (!current || dirty[0] & /*$$scope*/ 1048576)) {
					update_slot_base(
						text_slot,
						text_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[20], dirty, get_text_slot_changes_1),
						get_text_slot_context_1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(text_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(text_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (text_slot) text_slot.d(detaching);
		}
	};
}

// (134:8) {#if icon }
function create_if_block_4$3(ctx) {
	let useicon;
	let current;

	useicon = new Use_icon({
			props: {
				icon: /*icon*/ ctx[8],
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(useicon.$$.fragment);
		},
		l(nodes) {
			claim_component(useicon.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(useicon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const useicon_changes = {};
			if (dirty[0] & /*icon*/ 256) useicon_changes.icon = /*icon*/ ctx[8];
			if (dirty[0] & /*lec*/ 1) useicon_changes.lec = /*lec*/ ctx[0];
			useicon.$set(useicon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(useicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(useicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(useicon, detaching);
		}
	};
}

// (111:4) {#if text != undefined || hasTextSlots || icon }
function create_if_block_1$c(ctx) {
	let div;
	let t0_value = plainText(/*text*/ ctx[1]) + "";
	let t0;
	let t1;
	let t2;
	let current;
	let if_block = /*icon*/ ctx[8] && create_if_block_2$7(ctx);
	const text_slot_template = /*#slots*/ ctx[21].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[20], get_text_slot_context$1);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			if (text_slot) text_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (text_slot) text_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "menu-item-content");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t2);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 2) && t0_value !== (t0_value = plainText(/*text*/ ctx[1]) + "")) set_data(t0, t0_value);

			if (/*icon*/ ctx[8]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*icon*/ 256) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$7(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t2);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (text_slot) {
				if (text_slot.p && (!current || dirty[0] & /*$$scope*/ 1048576)) {
					update_slot_base(
						text_slot,
						text_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[20], dirty, get_text_slot_changes$1),
						get_text_slot_context$1
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(text_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(text_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (text_slot) text_slot.d(detaching);
		}
	};
}

// (114:8) {#if icon }
function create_if_block_2$7(ctx) {
	let useicon;
	let current;

	useicon = new Use_icon({
			props: {
				icon: /*icon*/ ctx[8],
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(useicon.$$.fragment);
		},
		l(nodes) {
			claim_component(useicon.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(useicon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const useicon_changes = {};
			if (dirty[0] & /*icon*/ 256) useicon_changes.icon = /*icon*/ ctx[8];
			if (dirty[0] & /*lec*/ 1) useicon_changes.lec = /*lec*/ ctx[0];
			useicon.$set(useicon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(useicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(useicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(useicon, detaching);
		}
	};
}

function create_fragment$E(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$k, create_else_block$7];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isLink*/ ctx[7]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

let index$G = 0;

function instance$A($$self, $$props, $$invalidate) {
	let hrefComputed;
	let attrs;
	let hasDefaultSlots;
	let hasTextSlots;
	let iconOnlyComputed;
	let classes;
	let icon;
	let isLink;

	const omit_props_names = [
		"lec","class","text","iconOnly","href","link","target","dropdown","tooltip","tooltipTrigger","routeProps"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { text = undefined } = $$props;
	let { iconOnly = undefined } = $$props;
	let { href = undefined } = $$props;
	let { link = undefined } = $$props;
	let { target = undefined } = $$props;
	let { dropdown = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let { routeProps = undefined } = $$props;
	let el;

	function onClick(e) {
		emit('click', [e]);
	}

	function onOpened(itemEl) {
		if (itemEl !== el) return;
		emit('menuOpened', [el]);
	}

	function onClosed(itemEl) {
		if (itemEl !== el) return;
		emit('menuClosed', [el]);
	}

	onMount(() => {
		f7ready(() => {
			app.f7.on('menuOpened', onOpened);
			app.f7.on('menuClosed', onClosed);
		});
	});

	onDestroy(() => {
		if (!el || !app.f7) return;
		app.f7.off('menuOpened', onOpened);
		app.f7.off('menuClosed', onClosed);
	});

	function a_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(6, el);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(6, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(29, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(31, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(0, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(12, className = $$new_props.class);
		if ('text' in $$new_props) $$invalidate(1, text = $$new_props.text);
		if ('iconOnly' in $$new_props) $$invalidate(13, iconOnly = $$new_props.iconOnly);
		if ('href' in $$new_props) $$invalidate(14, href = $$new_props.href);
		if ('link' in $$new_props) $$invalidate(15, link = $$new_props.link);
		if ('target' in $$new_props) $$invalidate(16, target = $$new_props.target);
		if ('dropdown' in $$new_props) $$invalidate(17, dropdown = $$new_props.dropdown);
		if ('tooltip' in $$new_props) $$invalidate(2, tooltip = $$new_props.tooltip);
		if ('tooltipTrigger' in $$new_props) $$invalidate(3, tooltipTrigger = $$new_props.tooltipTrigger);
		if ('routeProps' in $$new_props) $$invalidate(4, routeProps = $$new_props.routeProps);
		if ('$$scope' in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*href, link*/ 49152) {
			$: $$invalidate(19, hrefComputed = typeof href === 'undefined' && link ? '#' : href);
		}

		$: $$invalidate(10, attrs = extend(
			{
				href: hrefComputed,
				target,
				...restProps($$restProps)
			},
			routerAttrs($$props),
			actionsAttrs($$props)
		));

		if ($$self.$$.dirty[0] & /*iconOnly, text, hasTextSlots*/ 8226) {
			$: $$invalidate(18, iconOnlyComputed = iconOnly || !text && !hasTextSlots);
		}

		$: $$invalidate(9, classes = classNames(
			{
				'menu-item-dropdown': dropdown || dropdown === '',
				'icon-only': iconOnlyComputed
			},
			className,
			colorClasses($$props),
			routerClasses($$props),
			actionsClasses($$props)
		));

		$: $$invalidate(8, icon = useIcon($$props));

		if ($$self.$$.dirty[0] & /*link, href*/ 49152) {
			$: $$invalidate(7, isLink = link || href || href === '');
		}
	};

	$: hasDefaultSlots = $$slots.default;
	$: $$invalidate(5, hasTextSlots = $$slots.text);
	$$props = exclude_internal_props($$props);

	return [
		lec,
		text,
		tooltip,
		tooltipTrigger,
		routeProps,
		hasTextSlots,
		el,
		isLink,
		icon,
		classes,
		attrs,
		onClick,
		className,
		iconOnly,
		href,
		link,
		target,
		dropdown,
		iconOnlyComputed,
		hrefComputed,
		$$scope,
		slots,
		a_binding,
		div_binding
	];
}

class Menu_item extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$A,
			create_fragment$E,
			safe_not_equal,
			{
				lec: 0,
				class: 12,
				text: 1,
				iconOnly: 13,
				href: 14,
				link: 15,
				target: 16,
				dropdown: 17,
				tooltip: 2,
				tooltipTrigger: 3,
				routeProps: 4
			},
			null,
			[-1, -1]
		);
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/menu.liquivelte generated by Svelte v3.50.0 */

function create_fragment$D(ctx) {
	let div1;
	let div0;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div1_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (default_slot) default_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "menu-inner");
			set_attributes(div1, div1_data);
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);
			append_hydration(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$F = 0;

function instance$z($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'menu', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, $$scope, slots];
}

class Menu extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$z, create_fragment$D, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/message.liquivelte generated by Svelte v3.50.0 */
const get_end_slot_changes = dirty => ({});
const get_end_slot_context = ctx => ({});
const get_content_end_slot_changes$1 = dirty => ({});
const get_content_end_slot_context$1 = ctx => ({});
const get_footer_slot_changes = dirty => ({});
const get_footer_slot_context = ctx => ({});
const get_bubble_end_slot_changes = dirty => ({});
const get_bubble_end_slot_context = ctx => ({});
const get_text_footer_slot_changes = dirty => ({});
const get_text_footer_slot_context = ctx => ({});
const get_text_slot_changes = dirty => ({});
const get_text_slot_context = ctx => ({});
const get_text_header_slot_changes = dirty => ({});
const get_text_header_slot_context = ctx => ({});
const get_image_slot_changes = dirty => ({});
const get_image_slot_context = ctx => ({});
const get_bubble_start_slot_changes = dirty => ({});
const get_bubble_start_slot_context = ctx => ({});
const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});
const get_name_slot_changes = dirty => ({});
const get_name_slot_context = ctx => ({});
const get_content_start_slot_changes$1 = dirty => ({});
const get_content_start_slot_context$1 = ctx => ({});
const get_avatar_slot_changes = dirty => ({});
const get_avatar_slot_context = ctx => ({});
const get_start_slot_changes = dirty => ({});
const get_start_slot_context = ctx => ({});

// (96:2) {#if avatar || hasAvatarSlots}
function create_if_block_10(ctx) {
	let div;
	let div_style_value;
	let current;
	let mounted;
	let dispose;
	const avatar_slot_template = /*#slots*/ ctx[38].avatar;
	const avatar_slot = create_slot(avatar_slot_template, ctx, /*$$scope*/ ctx[37], get_avatar_slot_context);

	return {
		c() {
			div = element("div");
			if (avatar_slot) avatar_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);
			if (avatar_slot) avatar_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "message-avatar");

			attr(div, "style", div_style_value = /*avatar*/ ctx[3]
			? `background-image: url(${/*avatar*/ ctx[3]})`
			: undefined);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (avatar_slot) {
				avatar_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div, "click", /*onAvatarClick*/ ctx[22]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (avatar_slot) {
				if (avatar_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					update_slot_base(
						avatar_slot,
						avatar_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: get_slot_changes(avatar_slot_template, /*$$scope*/ ctx[37], dirty, get_avatar_slot_changes),
						get_avatar_slot_context
					);
				}
			}

			if (!current || dirty[0] & /*avatar*/ 8 && div_style_value !== (div_style_value = /*avatar*/ ctx[3]
			? `background-image: url(${/*avatar*/ ctx[3]})`
			: undefined)) {
				attr(div, "style", div_style_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(avatar_slot, local);
			current = true;
		},
		o(local) {
			transition_out(avatar_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (avatar_slot) avatar_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

// (107:4) {#if hasNameSlots || name}
function create_if_block_9(ctx) {
	let div;
	let t0_value = plainText(/*name*/ ctx[2]) + "";
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	const name_slot_template = /*#slots*/ ctx[38].name;
	const name_slot = create_slot(name_slot_template, ctx, /*$$scope*/ ctx[37], get_name_slot_context);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (name_slot) name_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (name_slot) name_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "message-name");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (name_slot) {
				name_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div, "click", /*onNameClick*/ ctx[20]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*name*/ 4) && t0_value !== (t0_value = plainText(/*name*/ ctx[2]) + "")) set_data(t0, t0_value);

			if (name_slot) {
				if (name_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					update_slot_base(
						name_slot,
						name_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: get_slot_changes(name_slot_template, /*$$scope*/ ctx[37], dirty, get_name_slot_changes),
						get_name_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(name_slot, local);
			current = true;
		},
		o(local) {
			transition_out(name_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (name_slot) name_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

// (113:4) {#if hasHeaderSlots || header}
function create_if_block_8(ctx) {
	let div;
	let t0_value = plainText(/*header*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	const header_slot_template = /*#slots*/ ctx[38].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[37], get_header_slot_context);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (header_slot) header_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "message-header");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div, "click", /*onHeaderClick*/ ctx[23]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = plainText(/*header*/ ctx[5]) + "")) set_data(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[37], dirty, get_header_slot_changes),
						get_header_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (header_slot) header_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

// (121:6) {#if hasImageSlots || image}
function create_if_block_6(ctx) {
	let div;
	let t;
	let current;
	let if_block = /*image*/ ctx[4] && create_if_block_7(ctx);
	const image_slot_template = /*#slots*/ ctx[38].image;
	const image_slot = create_slot(image_slot_template, ctx, /*$$scope*/ ctx[37], get_image_slot_context);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (image_slot) image_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			if (image_slot) image_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "message-image");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t);

			if (image_slot) {
				image_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*image*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_7(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (image_slot) {
				if (image_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					update_slot_base(
						image_slot,
						image_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: get_slot_changes(image_slot_template, /*$$scope*/ ctx[37], dirty, get_image_slot_changes),
						get_image_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(image_slot, local);
			current = true;
		},
		o(local) {
			transition_out(image_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (image_slot) image_slot.d(detaching);
		}
	};
}

// (123:10) {#if image}
function create_if_block_7(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			this.h();
		},
		l(nodes) {
			img = claim_element(nodes, "IMG", { src: true });
			this.h();
		},
		h() {
			if (!src_url_equal(img.src, img_src_value = /*image*/ ctx[4])) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert_hydration(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*image*/ 16 && !src_url_equal(img.src, img_src_value = /*image*/ ctx[4])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (129:6) {#if hasTextHeaderSlots || textHeader}
function create_if_block_5$1(ctx) {
	let div;
	let t0_value = plainText(/*textHeader*/ ctx[7]) + "";
	let t0;
	let t1;
	let current;
	const text_header_slot_template = /*#slots*/ ctx[38]["text-header"];
	const text_header_slot = create_slot(text_header_slot_template, ctx, /*$$scope*/ ctx[37], get_text_header_slot_context);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_header_slot) text_header_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (text_header_slot) text_header_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "message-text-header");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (text_header_slot) {
				text_header_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*textHeader*/ 128) && t0_value !== (t0_value = plainText(/*textHeader*/ ctx[7]) + "")) set_data(t0, t0_value);

			if (text_header_slot) {
				if (text_header_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					update_slot_base(
						text_header_slot,
						text_header_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: get_slot_changes(text_header_slot_template, /*$$scope*/ ctx[37], dirty, get_text_header_slot_changes),
						get_text_header_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(text_header_slot, local);
			current = true;
		},
		o(local) {
			transition_out(text_header_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (text_header_slot) text_header_slot.d(detaching);
		}
	};
}

// (135:6) {#if hasTextSlots || text || htmlText || typing}
function create_if_block_2$6(ctx) {
	let div;
	let t0_value = plainText(/*text*/ ctx[0]) + "";
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*htmlText*/ ctx[1] && create_if_block_4$2(ctx);
	const text_slot_template = /*#slots*/ ctx[38].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[37], get_text_slot_context);
	let if_block1 = /*typing*/ ctx[9] && create_if_block_3$6(ctx);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (text_slot) text_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (text_slot) text_slot.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "message-text");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t2);

			if (text_slot) {
				text_slot.m(div, null);
			}

			append_hydration(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;

			if (!mounted) {
				dispose = listen(div, "click", /*onTextClick*/ ctx[21]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 1) && t0_value !== (t0_value = plainText(/*text*/ ctx[0]) + "")) set_data(t0, t0_value);

			if (/*htmlText*/ ctx[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4$2(ctx);
					if_block0.c();
					if_block0.m(div, t2);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (text_slot) {
				if (text_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					update_slot_base(
						text_slot,
						text_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: get_slot_changes(text_slot_template, /*$$scope*/ ctx[37], dirty, get_text_slot_changes),
						get_text_slot_context
					);
				}
			}

			if (/*typing*/ ctx[9]) {
				if (if_block1) {
					
				} else {
					if_block1 = create_if_block_3$6(ctx);
					if_block1.c();
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (text_slot) text_slot.d(detaching);
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

// (138:10) {#if htmlText}
function create_if_block_4$2(ctx) {
	let html_tag;
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTagHydration(false);
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_tag = claim_html_tag(nodes, false);
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(/*htmlText*/ ctx[1], target, anchor);
			insert_hydration(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*htmlText*/ 2) html_tag.p(/*htmlText*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (140:10) {#if typing}
function create_if_block_3$6(ctx) {
	let div3;
	let div0;
	let t0;
	let div1;
	let t1;
	let div2;

	return {
		c() {
			div3 = element("div");
			div0 = element("div");
			t0 = space();
			div1 = element("div");
			t1 = space();
			div2 = element("div");
			this.h();
		},
		l(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			div0 = claim_element(div3_nodes, "DIV", {});
			children(div0).forEach(detach);
			t0 = claim_space(div3_nodes);
			div1 = claim_element(div3_nodes, "DIV", {});
			children(div1).forEach(detach);
			t1 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", {});
			children(div2).forEach(detach);
			div3_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div3, "class", "message-typing-indicator");
		},
		m(target, anchor) {
			insert_hydration(target, div3, anchor);
			append_hydration(div3, div0);
			append_hydration(div3, t0);
			append_hydration(div3, div1);
			append_hydration(div3, t1);
			append_hydration(div3, div2);
		},
		d(detaching) {
			if (detaching) detach(div3);
		}
	};
}

// (149:6) {#if hasTextFooterSlots || textFooter}
function create_if_block_1$b(ctx) {
	let div;
	let t0_value = plainText(/*textFooter*/ ctx[8]) + "";
	let t0;
	let t1;
	let current;
	const text_footer_slot_template = /*#slots*/ ctx[38]["text-footer"];
	const text_footer_slot = create_slot(text_footer_slot_template, ctx, /*$$scope*/ ctx[37], get_text_footer_slot_context);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_footer_slot) text_footer_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (text_footer_slot) text_footer_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "message-text-footer");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (text_footer_slot) {
				text_footer_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*textFooter*/ 256) && t0_value !== (t0_value = plainText(/*textFooter*/ ctx[8]) + "")) set_data(t0, t0_value);

			if (text_footer_slot) {
				if (text_footer_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					update_slot_base(
						text_footer_slot,
						text_footer_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: get_slot_changes(text_footer_slot_template, /*$$scope*/ ctx[37], dirty, get_text_footer_slot_changes),
						get_text_footer_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(text_footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(text_footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (text_footer_slot) text_footer_slot.d(detaching);
		}
	};
}

// (158:4) {#if hasFooterSlots || footer}
function create_if_block$j(ctx) {
	let div;
	let t0_value = plainText(/*footer*/ ctx[6]) + "";
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	const footer_slot_template = /*#slots*/ ctx[38].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[37], get_footer_slot_context);

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			if (footer_slot) footer_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "message-footer");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t0);
			append_hydration(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div, "click", /*onFooterClick*/ ctx[24]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = plainText(/*footer*/ ctx[6]) + "")) set_data(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[37], dirty, get_footer_slot_changes),
						get_footer_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (footer_slot) footer_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$C(ctx) {
	let div2;
	let t0;
	let t1;
	let div1;
	let t2;
	let t3;
	let t4;
	let div0;
	let t5;
	let t6;
	let t7;
	let t8;
	let t9;
	let t10;
	let t11;
	let t12;
	let t13;
	let current;
	let mounted;
	let dispose;
	const start_slot_template = /*#slots*/ ctx[38].start;
	const start_slot = create_slot(start_slot_template, ctx, /*$$scope*/ ctx[37], get_start_slot_context);
	let if_block0 = (/*avatar*/ ctx[3] || /*hasAvatarSlots*/ ctx[17]) && create_if_block_10(ctx);
	const content_start_slot_template = /*#slots*/ ctx[38]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[37], get_content_start_slot_context$1);
	let if_block1 = (/*hasNameSlots*/ ctx[16] || /*name*/ ctx[2]) && create_if_block_9(ctx);
	let if_block2 = (/*hasHeaderSlots*/ ctx[15] || /*header*/ ctx[5]) && create_if_block_8(ctx);
	const bubble_start_slot_template = /*#slots*/ ctx[38]["bubble-start"];
	const bubble_start_slot = create_slot(bubble_start_slot_template, ctx, /*$$scope*/ ctx[37], get_bubble_start_slot_context);
	let if_block3 = (/*hasImageSlots*/ ctx[14] || /*image*/ ctx[4]) && create_if_block_6(ctx);
	let if_block4 = (/*hasTextHeaderSlots*/ ctx[13] || /*textHeader*/ ctx[7]) && create_if_block_5$1(ctx);
	let if_block5 = (/*hasTextSlots*/ ctx[11] || /*text*/ ctx[0] || /*htmlText*/ ctx[1] || /*typing*/ ctx[9]) && create_if_block_2$6(ctx);
	let if_block6 = (/*hasTextFooterSlots*/ ctx[12] || /*textFooter*/ ctx[8]) && create_if_block_1$b(ctx);
	const bubble_end_slot_template = /*#slots*/ ctx[38]["bubble-end"];
	const bubble_end_slot = create_slot(bubble_end_slot_template, ctx, /*$$scope*/ ctx[37], get_bubble_end_slot_context);
	const default_slot_template = /*#slots*/ ctx[38].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[37], null);
	let if_block7 = (/*hasFooterSlots*/ ctx[10] || /*footer*/ ctx[6]) && create_if_block$j(ctx);
	const content_end_slot_template = /*#slots*/ ctx[38]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[37], get_content_end_slot_context$1);
	const end_slot_template = /*#slots*/ ctx[38].end;
	const end_slot = create_slot(end_slot_template, ctx, /*$$scope*/ ctx[37], get_end_slot_context);
	let div2_levels = [{ class: /*classes*/ ctx[18] }, restProps(/*$$restProps*/ ctx[26])];
	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	return {
		c() {
			div2 = element("div");
			if (start_slot) start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			div0 = element("div");
			if (bubble_start_slot) bubble_start_slot.c();
			t5 = space();
			if (if_block3) if_block3.c();
			t6 = space();
			if (if_block4) if_block4.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			t9 = space();
			if (bubble_end_slot) bubble_end_slot.c();
			t10 = space();
			if (default_slot) default_slot.c();
			t11 = space();
			if (if_block7) if_block7.c();
			t12 = space();
			if (content_end_slot) content_end_slot.c();
			t13 = space();
			if (end_slot) end_slot.c();
			this.h();
		},
		l(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			if (start_slot) start_slot.l(div2_nodes);
			t0 = claim_space(div2_nodes);
			if (if_block0) if_block0.l(div2_nodes);
			t1 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (content_start_slot) content_start_slot.l(div1_nodes);
			t2 = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			t3 = claim_space(div1_nodes);
			if (if_block2) if_block2.l(div1_nodes);
			t4 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (bubble_start_slot) bubble_start_slot.l(div0_nodes);
			t5 = claim_space(div0_nodes);
			if (if_block3) if_block3.l(div0_nodes);
			t6 = claim_space(div0_nodes);
			if (if_block4) if_block4.l(div0_nodes);
			t7 = claim_space(div0_nodes);
			if (if_block5) if_block5.l(div0_nodes);
			t8 = claim_space(div0_nodes);
			if (if_block6) if_block6.l(div0_nodes);
			t9 = claim_space(div0_nodes);
			if (bubble_end_slot) bubble_end_slot.l(div0_nodes);
			t10 = claim_space(div0_nodes);
			if (default_slot) default_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			t11 = claim_space(div1_nodes);
			if (if_block7) if_block7.l(div1_nodes);
			t12 = claim_space(div1_nodes);
			if (content_end_slot) content_end_slot.l(div1_nodes);
			div1_nodes.forEach(detach);
			t13 = claim_space(div2_nodes);
			if (end_slot) end_slot.l(div2_nodes);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "message-bubble");
			attr(div1, "class", "message-content");
			set_attributes(div2, div2_data);
		},
		m(target, anchor) {
			insert_hydration(target, div2, anchor);

			if (start_slot) {
				start_slot.m(div2, null);
			}

			append_hydration(div2, t0);
			if (if_block0) if_block0.m(div2, null);
			append_hydration(div2, t1);
			append_hydration(div2, div1);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_hydration(div1, t2);
			if (if_block1) if_block1.m(div1, null);
			append_hydration(div1, t3);
			if (if_block2) if_block2.m(div1, null);
			append_hydration(div1, t4);
			append_hydration(div1, div0);

			if (bubble_start_slot) {
				bubble_start_slot.m(div0, null);
			}

			append_hydration(div0, t5);
			if (if_block3) if_block3.m(div0, null);
			append_hydration(div0, t6);
			if (if_block4) if_block4.m(div0, null);
			append_hydration(div0, t7);
			if (if_block5) if_block5.m(div0, null);
			append_hydration(div0, t8);
			if (if_block6) if_block6.m(div0, null);
			append_hydration(div0, t9);

			if (bubble_end_slot) {
				bubble_end_slot.m(div0, null);
			}

			append_hydration(div0, t10);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			append_hydration(div1, t11);
			if (if_block7) if_block7.m(div1, null);
			append_hydration(div1, t12);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			append_hydration(div2, t13);

			if (end_slot) {
				end_slot.m(div2, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "click", /*onBubbleClick*/ ctx[25]),
					listen(div2, "click", /*onClick*/ ctx[19])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (start_slot) {
				if (start_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					update_slot_base(
						start_slot,
						start_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: get_slot_changes(start_slot_template, /*$$scope*/ ctx[37], dirty, get_start_slot_changes),
						get_start_slot_context
					);
				}
			}

			if (/*avatar*/ ctx[3] || /*hasAvatarSlots*/ ctx[17]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*avatar, hasAvatarSlots*/ 131080) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_10(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div2, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (content_start_slot) {
				if (content_start_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					update_slot_base(
						content_start_slot,
						content_start_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[37], dirty, get_content_start_slot_changes$1),
						get_content_start_slot_context$1
					);
				}
			}

			if (/*hasNameSlots*/ ctx[16] || /*name*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*hasNameSlots, name*/ 65540) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_9(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*hasHeaderSlots*/ ctx[15] || /*header*/ ctx[5]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*hasHeaderSlots, header*/ 32800) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_8(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, t4);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (bubble_start_slot) {
				if (bubble_start_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					update_slot_base(
						bubble_start_slot,
						bubble_start_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: get_slot_changes(bubble_start_slot_template, /*$$scope*/ ctx[37], dirty, get_bubble_start_slot_changes),
						get_bubble_start_slot_context
					);
				}
			}

			if (/*hasImageSlots*/ ctx[14] || /*image*/ ctx[4]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*hasImageSlots, image*/ 16400) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_6(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div0, t6);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasTextHeaderSlots*/ ctx[13] || /*textHeader*/ ctx[7]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[0] & /*hasTextHeaderSlots, textHeader*/ 8320) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_5$1(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(div0, t7);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (/*hasTextSlots*/ ctx[11] || /*text*/ ctx[0] || /*htmlText*/ ctx[1] || /*typing*/ ctx[9]) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*hasTextSlots, text, htmlText, typing*/ 2563) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_2$6(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(div0, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasTextFooterSlots*/ ctx[12] || /*textFooter*/ ctx[8]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[0] & /*hasTextFooterSlots, textFooter*/ 4352) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_1$b(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(div0, t9);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}

			if (bubble_end_slot) {
				if (bubble_end_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					update_slot_base(
						bubble_end_slot,
						bubble_end_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: get_slot_changes(bubble_end_slot_template, /*$$scope*/ ctx[37], dirty, get_bubble_end_slot_changes),
						get_bubble_end_slot_context
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[37], dirty, null),
						null
					);
				}
			}

			if (/*hasFooterSlots*/ ctx[10] || /*footer*/ ctx[6]) {
				if (if_block7) {
					if_block7.p(ctx, dirty);

					if (dirty[0] & /*hasFooterSlots, footer*/ 1088) {
						transition_in(if_block7, 1);
					}
				} else {
					if_block7 = create_if_block$j(ctx);
					if_block7.c();
					transition_in(if_block7, 1);
					if_block7.m(div1, t12);
				}
			} else if (if_block7) {
				group_outros();

				transition_out(if_block7, 1, 1, () => {
					if_block7 = null;
				});

				check_outros();
			}

			if (content_end_slot) {
				if (content_end_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					update_slot_base(
						content_end_slot,
						content_end_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[37], dirty, get_content_end_slot_changes$1),
						get_content_end_slot_context$1
					);
				}
			}

			if (end_slot) {
				if (end_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
					update_slot_base(
						end_slot,
						end_slot_template,
						ctx,
						/*$$scope*/ ctx[37],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[37])
						: get_slot_changes(end_slot_template, /*$$scope*/ ctx[37], dirty, get_end_slot_changes),
						get_end_slot_context
					);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty[0] & /*classes*/ 262144) && { class: /*classes*/ ctx[18] },
				dirty[0] & /*$$restProps*/ 67108864 && restProps(/*$$restProps*/ ctx[26])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(start_slot, local);
			transition_in(if_block0);
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(bubble_start_slot, local);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(if_block5);
			transition_in(if_block6);
			transition_in(bubble_end_slot, local);
			transition_in(default_slot, local);
			transition_in(if_block7);
			transition_in(content_end_slot, local);
			transition_in(end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(start_slot, local);
			transition_out(if_block0);
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(bubble_start_slot, local);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(if_block5);
			transition_out(if_block6);
			transition_out(bubble_end_slot, local);
			transition_out(default_slot, local);
			transition_out(if_block7);
			transition_out(content_end_slot, local);
			transition_out(end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			if (start_slot) start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (bubble_start_slot) bubble_start_slot.d(detaching);
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			if (bubble_end_slot) bubble_end_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (if_block7) if_block7.d();
			if (content_end_slot) content_end_slot.d(detaching);
			if (end_slot) end_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

let index$E = 0;

function instance$y($$self, $$props, $$invalidate) {
	let classes;
	let hasAvatarSlots;
	let hasNameSlots;
	let hasHeaderSlots;
	let hasImageSlots;
	let hasTextHeaderSlots;
	let hasTextFooterSlots;
	let hasTextSlots;
	let hasFooterSlots;

	const omit_props_names = [
		"lec","class","text","htmlText","name","avatar","type","image","header","footer","textHeader","textFooter","first","last","tail","sameName","sameHeader","sameFooter","sameAvatar","typing"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { text = undefined } = $$props;
	let { htmlText = undefined } = $$props;
	let { name = undefined } = $$props;
	let { avatar = undefined } = $$props;
	let { type = 'sent' } = $$props;
	let { image = undefined } = $$props;
	let { header = undefined } = $$props;
	let { footer = undefined } = $$props;
	let { textHeader = undefined } = $$props;
	let { textFooter = undefined } = $$props;
	let { first = undefined } = $$props;
	let { last = undefined } = $$props;
	let { tail = undefined } = $$props;
	let { sameName = undefined } = $$props;
	let { sameHeader = undefined } = $$props;
	let { sameFooter = undefined } = $$props;
	let { sameAvatar = undefined } = $$props;
	let { typing = undefined } = $$props;

	function onClick() {
		emit('click');
	}

	function onNameClick() {
		emit('clickName');
	}

	function onTextClick() {
		emit('clickText');
	}

	function onAvatarClick() {
		emit('clickAvatar');
	}

	function onHeaderClick() {
		emit('clickHeader');
	}

	function onFooterClick() {
		emit('clickFooter');
	}

	function onBubbleClick() {
		emit('clickBubble');
	}

	$$self.$$set = $$new_props => {
		$$invalidate(42, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(27, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(28, className = $$new_props.class);
		if ('text' in $$new_props) $$invalidate(0, text = $$new_props.text);
		if ('htmlText' in $$new_props) $$invalidate(1, htmlText = $$new_props.htmlText);
		if ('name' in $$new_props) $$invalidate(2, name = $$new_props.name);
		if ('avatar' in $$new_props) $$invalidate(3, avatar = $$new_props.avatar);
		if ('type' in $$new_props) $$invalidate(29, type = $$new_props.type);
		if ('image' in $$new_props) $$invalidate(4, image = $$new_props.image);
		if ('header' in $$new_props) $$invalidate(5, header = $$new_props.header);
		if ('footer' in $$new_props) $$invalidate(6, footer = $$new_props.footer);
		if ('textHeader' in $$new_props) $$invalidate(7, textHeader = $$new_props.textHeader);
		if ('textFooter' in $$new_props) $$invalidate(8, textFooter = $$new_props.textFooter);
		if ('first' in $$new_props) $$invalidate(30, first = $$new_props.first);
		if ('last' in $$new_props) $$invalidate(31, last = $$new_props.last);
		if ('tail' in $$new_props) $$invalidate(32, tail = $$new_props.tail);
		if ('sameName' in $$new_props) $$invalidate(33, sameName = $$new_props.sameName);
		if ('sameHeader' in $$new_props) $$invalidate(34, sameHeader = $$new_props.sameHeader);
		if ('sameFooter' in $$new_props) $$invalidate(35, sameFooter = $$new_props.sameFooter);
		if ('sameAvatar' in $$new_props) $$invalidate(36, sameAvatar = $$new_props.sameAvatar);
		if ('typing' in $$new_props) $$invalidate(9, typing = $$new_props.typing);
		if ('$$scope' in $$new_props) $$invalidate(37, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(18, classes = classNames(
			className,
			'message',
			{
				'message-sent': type === 'sent' || !type,
				'message-received': type === 'received',
				'message-typing': typing,
				'message-first': first,
				'message-last': last,
				'message-tail': tail,
				'message-same-name': sameName,
				'message-same-header': sameHeader,
				'message-same-footer': sameFooter,
				'message-same-avatar': sameAvatar
			},
			colorClasses($$props)
		));
	};

	$: $$invalidate(17, hasAvatarSlots = $$slots.avatar);
	$: $$invalidate(16, hasNameSlots = $$slots.name);
	$: $$invalidate(15, hasHeaderSlots = $$slots.header);
	$: $$invalidate(14, hasImageSlots = $$slots.image);
	$: $$invalidate(13, hasTextHeaderSlots = $$slots['text-header']);
	$: $$invalidate(12, hasTextFooterSlots = $$slots['text-footer']);
	$: $$invalidate(11, hasTextSlots = $$slots.text);
	$: $$invalidate(10, hasFooterSlots = $$slots.footer);
	$$props = exclude_internal_props($$props);

	return [
		text,
		htmlText,
		name,
		avatar,
		image,
		header,
		footer,
		textHeader,
		textFooter,
		typing,
		hasFooterSlots,
		hasTextSlots,
		hasTextFooterSlots,
		hasTextHeaderSlots,
		hasImageSlots,
		hasHeaderSlots,
		hasNameSlots,
		hasAvatarSlots,
		classes,
		onClick,
		onNameClick,
		onTextClick,
		onAvatarClick,
		onHeaderClick,
		onFooterClick,
		onBubbleClick,
		$$restProps,
		lec,
		className,
		type,
		first,
		last,
		tail,
		sameName,
		sameHeader,
		sameFooter,
		sameAvatar,
		$$scope,
		slots
	];
}

class Message extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$y,
			create_fragment$C,
			safe_not_equal,
			{
				lec: 27,
				class: 28,
				text: 0,
				htmlText: 1,
				name: 2,
				avatar: 3,
				type: 29,
				image: 4,
				header: 5,
				footer: 6,
				textHeader: 7,
				textFooter: 8,
				first: 30,
				last: 31,
				tail: 32,
				sameName: 33,
				sameHeader: 34,
				sameFooter: 35,
				sameAvatar: 36,
				typing: 9
			},
			null,
			[-1, -1]
		);
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/messagebar-attachment.liquivelte generated by Svelte v3.50.0 */

function create_if_block_1$a(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			this.h();
		},
		l(nodes) {
			img = claim_element(nodes, "IMG", { src: true });
			this.h();
		},
		h() {
			if (!src_url_equal(img.src, img_src_value = /*image*/ ctx[0])) attr(img, "src", img_src_value);
		},
		m(target, anchor) {
			insert_hydration(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*image*/ 1 && !src_url_equal(img.src, img_src_value = /*image*/ ctx[0])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (36:2) {#if deletable}
function create_if_block$i(ctx) {
	let span;
	let mounted;
	let dispose;

	return {
		c() {
			span = element("span");
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "messagebar-attachment-delete");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);

			if (!mounted) {
				dispose = listen(span, "click", /*onDeleteClick*/ ctx[4]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$B(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*image*/ ctx[0] && create_if_block_1$a(ctx);
	let if_block1 = /*deletable*/ ctx[1] && create_if_block$i(ctx);
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	let div_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[5])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t1);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div, "click", /*onClick*/ ctx[3]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*image*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$a(ctx);
					if_block0.c();
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*deletable*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$i(ctx);
					if_block1.c();
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty & /*$$restProps*/ 32 && restProps(/*$$restProps*/ ctx[5])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

let index$D = 0;

function instance$x($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class","image","deletable"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { image = undefined } = $$props;
	let { deletable = true } = $$props;

	function onClick(event) {
		emit('attachmentClick', [event]);
	}

	function onDeleteClick(event) {
		emit('attachmentDelete', [event]);
	}

	$$self.$$set = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(6, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(7, className = $$new_props.class);
		if ('image' in $$new_props) $$invalidate(0, image = $$new_props.image);
		if ('deletable' in $$new_props) $$invalidate(1, deletable = $$new_props.deletable);
		if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(2, classes = classNames(className, 'messagebar-attachment', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);

	return [
		image,
		deletable,
		classes,
		onClick,
		onDeleteClick,
		$$restProps,
		lec,
		className,
		$$scope,
		slots
	];
}

class Messagebar_attachment extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$x, create_fragment$B, safe_not_equal, { lec: 6, class: 7, image: 0, deletable: 1 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/messagebar-attachments.liquivelte generated by Svelte v3.50.0 */

function create_fragment$A(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$C = 0;

function instance$w($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'messagebar-attachments', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, $$scope, slots];
}

class Messagebar_attachments extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$w, create_fragment$A, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/messagebar-sheet-image.liquivelte generated by Svelte v3.50.0 */

function create_fragment$z(ctx) {
	let label;
	let input;
	let t0;
	let i;
	let t1;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	let label_levels = [
		{ class: /*classes*/ ctx[2] },
		{ style: /*styles*/ ctx[1] },
		restProps(/*$$restProps*/ ctx[4])
	];

	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	return {
		c() {
			label = element("label");
			input = element("input");
			t0 = space();
			i = element("i");
			t1 = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			label = claim_element(nodes, "LABEL", { class: true, style: true });
			var label_nodes = children(label);
			input = claim_element(label_nodes, "INPUT", { type: true });
			t0 = claim_space(label_nodes);
			i = claim_element(label_nodes, "I", { class: true });
			children(i).forEach(detach);
			t1 = claim_space(label_nodes);
			if (default_slot) default_slot.l(label_nodes);
			label_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(input, "type", "checkbox");
			input.checked = /*checked*/ ctx[0];
			attr(i, "class", "icon icon-checkbox");
			set_attributes(label, label_data);
		},
		m(target, anchor) {
			insert_hydration(target, label, anchor);
			append_hydration(label, input);
			append_hydration(label, t0);
			append_hydration(label, i);
			append_hydration(label, t1);

			if (default_slot) {
				default_slot.m(label, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(input, "change", /*onChange*/ ctx[3]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
						null
					);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				(!current || dirty & /*styles*/ 2) && { style: /*styles*/ ctx[1] },
				dirty & /*$$restProps*/ 16 && restProps(/*$$restProps*/ ctx[4])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

let index$B = 0;

function instance$v($$self, $$props, $$invalidate) {
	let classes;
	let styles;
	const omit_props_names = ["lec","style","class","image","checked"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { style = undefined } = $$props;
	let { class: className = undefined } = $$props;
	let { image = undefined } = $$props;
	let { checked = false } = $$props;

	function onChange(event) {
		if (event.target.checked) emit('checked', [event]); else emit('unchecked', [event]);
		emit('change', [event]);
		$$invalidate(0, checked = event.target.checked);
	}

	$$self.$$set = $$new_props => {
		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(5, lec = $$new_props.lec);
		if ('style' in $$new_props) $$invalidate(6, style = $$new_props.style);
		if ('class' in $$new_props) $$invalidate(7, className = $$new_props.class);
		if ('image' in $$new_props) $$invalidate(8, image = $$new_props.image);
		if ('checked' in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ('$$scope' in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(2, classes = classNames(className, 'messagebar-sheet-image', 'checkbox', colorClasses($$props)));

		if ($$self.$$.dirty & /*image, style*/ 320) {
			$: $$invalidate(1, styles = `${image ? `background-image: url(${image});` : ''}${style || ''}`);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		checked,
		styles,
		classes,
		onChange,
		$$restProps,
		lec,
		style,
		className,
		image,
		$$scope,
		slots
	];
}

class Messagebar_sheet_image extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$v, create_fragment$z, safe_not_equal, {
			lec: 5,
			style: 6,
			class: 7,
			image: 8,
			checked: 0
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/messagebar-sheet-item.liquivelte generated by Svelte v3.50.0 */

function create_fragment$y(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$A = 0;

function instance$u($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'messagebar-sheet-item', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, $$scope, slots];
}

class Messagebar_sheet_item extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$u, create_fragment$y, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/messagebar-sheet.liquivelte generated by Svelte v3.50.0 */

function create_fragment$x(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$z = 0;

function instance$t($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'messagebar-sheet', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, $$scope, slots];
}

class Messagebar_sheet extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$t, create_fragment$x, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/messagebar.liquivelte generated by Svelte v3.50.0 */

const get_after_inner_slot_changes_1$1 = dirty => ({
	messagebar: dirty[0] & /*f7Messagebar*/ 2048
});

const get_after_inner_slot_context_1$1 = ctx => ({ messagebar: /*f7Messagebar*/ ctx[11] });

const get_default_slot_changes$2 = dirty => ({
	messagebar: dirty[0] & /*f7Messagebar*/ 2048
});

const get_default_slot_context$2 = ctx => ({ messagebar: /*f7Messagebar*/ ctx[11] });

const get_inner_end_slot_changes$1 = dirty => ({
	messagebar: dirty[0] & /*f7Messagebar*/ 2048
});

const get_inner_end_slot_context$1 = ctx => ({ messagebar: /*f7Messagebar*/ ctx[11] });

const get_send_link_slot_changes = dirty => ({
	messagebar: dirty[0] & /*f7Messagebar*/ 2048
});

const get_send_link_slot_context = ctx => ({ messagebar: /*f7Messagebar*/ ctx[11] });

const get_after_inner_slot_changes$3 = dirty => ({
	messagebar: dirty[0] & /*f7Messagebar*/ 2048
});

const get_after_inner_slot_context$3 = ctx => ({ messagebar: /*f7Messagebar*/ ctx[11] });

const get_before_area_slot_changes = dirty => ({
	messagebar: dirty[0] & /*f7Messagebar*/ 2048
});

const get_before_area_slot_context = ctx => ({ messagebar: /*f7Messagebar*/ ctx[11] });

const get_inner_start_slot_changes$1 = dirty => ({
	messagebar: dirty[0] & /*f7Messagebar*/ 2048
});

const get_inner_start_slot_context$1 = ctx => ({ messagebar: /*f7Messagebar*/ ctx[11] });

const get_before_inner_slot_changes$3 = dirty => ({
	messagebar: dirty[0] & /*f7Messagebar*/ 2048
});

const get_before_inner_slot_context$3 = ctx => ({ messagebar: /*f7Messagebar*/ ctx[11] });

// (209:4) {#if (sendLink && sendLink.length > 0) || hasSendLinkSlots}
function create_if_block$h(ctx) {
	let link;
	let current;

	link = new Link({
			props: {
				onClick: /*onClick*/ ctx[18],
				lec: /*lec*/ ctx[1],
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(link.$$.fragment);
		},
		l(nodes) {
			claim_component(link.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(link, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const link_changes = {};
			if (dirty[0] & /*lec*/ 2) link_changes.lec = /*lec*/ ctx[1];

			if (dirty[0] & /*sendLink, f7Messagebar*/ 2056 | dirty[1] & /*$$scope*/ 2) {
				link_changes.$$scope = { dirty, ctx };
			}

			link.$set(link_changes);
		},
		i(local) {
			if (current) return;
			transition_in(link.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(link.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(link, detaching);
		}
	};
}

// (210:6) <Link  {onClick}     lec={lec} >
function create_default_slot$4(ctx) {
	let t0;
	let t1;
	let current;
	const send_link_slot_template = /*#slots*/ ctx[30]["send-link"];
	const send_link_slot = create_slot(send_link_slot_template, ctx, /*$$scope*/ ctx[32], get_send_link_slot_context);

	return {
		c() {
			if (send_link_slot) send_link_slot.c();
			t0 = space();
			t1 = text(/*sendLink*/ ctx[3]);
		},
		l(nodes) {
			if (send_link_slot) send_link_slot.l(nodes);
			t0 = claim_space(nodes);
			t1 = claim_text(nodes, /*sendLink*/ ctx[3]);
		},
		m(target, anchor) {
			if (send_link_slot) {
				send_link_slot.m(target, anchor);
			}

			insert_hydration(target, t0, anchor);
			insert_hydration(target, t1, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (send_link_slot) {
				if (send_link_slot.p && (!current || dirty[0] & /*f7Messagebar*/ 2048 | dirty[1] & /*$$scope*/ 2)) {
					update_slot_base(
						send_link_slot,
						send_link_slot_template,
						ctx,
						/*$$scope*/ ctx[32],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[32])
						: get_slot_changes(send_link_slot_template, /*$$scope*/ ctx[32], dirty, get_send_link_slot_changes),
						get_send_link_slot_context
					);
				}
			}

			if (!current || dirty[0] & /*sendLink*/ 8) set_data(t1, /*sendLink*/ ctx[3]);
		},
		i(local) {
			if (current) return;
			transition_in(send_link_slot, local);
			current = true;
		},
		o(local) {
			transition_out(send_link_slot, local);
			current = false;
		},
		d(detaching) {
			if (send_link_slot) send_link_slot.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(t1);
		}
	};
}

function create_fragment$w(ctx) {
	let div2;
	let t0;
	let div1;
	let t1;
	let div0;
	let t2;
	let input;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let current;
	const before_inner_slot_template = /*#slots*/ ctx[30]["before-inner"];
	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[32], get_before_inner_slot_context$3);
	const inner_start_slot_template = /*#slots*/ ctx[30]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[32], get_inner_start_slot_context$1);
	const before_area_slot_template = /*#slots*/ ctx[30]["before-area"];
	const before_area_slot = create_slot(before_area_slot_template, ctx, /*$$scope*/ ctx[32], get_before_area_slot_context);

	input = new Input({
			props: {
				id: /*textareaId*/ ctx[6],
				type: "textarea",
				wrap: false,
				placeholder: /*placeholder*/ ctx[8],
				disabled: /*disabled*/ ctx[4],
				name: /*name*/ ctx[7],
				readonly: /*readonly*/ ctx[5],
				resizable: /*resizable*/ ctx[2],
				value: typeof /*value*/ ctx[0] === 'undefined'
				? ''
				: /*value*/ ctx[0],
				lec: /*lec*/ ctx[1]
			}
		});

	input.$on("input", /*onInput*/ ctx[15]);
	input.$on("change", /*onChange*/ ctx[14]);
	input.$on("focus", /*onFocus*/ ctx[16]);
	input.$on("blur", /*onBlur*/ ctx[17]);
	const after_inner_slot_template = /*#slots*/ ctx[30]["after-inner"];
	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[32], get_after_inner_slot_context$3);
	let if_block = (/*sendLink*/ ctx[3] && /*sendLink*/ ctx[3].length > 0 || /*hasSendLinkSlots*/ ctx[12]) && create_if_block$h(ctx);
	const inner_end_slot_template = /*#slots*/ ctx[30]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[32], get_inner_end_slot_context$1);
	const default_slot_template = /*#slots*/ ctx[30].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[32], get_default_slot_context$2);
	const after_inner_slot_template_1 = /*#slots*/ ctx[30]["after-inner"];
	const after_inner_slot_1 = create_slot(after_inner_slot_template_1, ctx, /*$$scope*/ ctx[32], get_after_inner_slot_context_1$1);

	let div2_levels = [
		{ class: /*classes*/ ctx[13] },
		{ "data-f7-slot": /*f7Slot*/ ctx[9] },
		restProps(/*$$restProps*/ ctx[19])
	];

	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	return {
		c() {
			div2 = element("div");
			if (before_inner_slot) before_inner_slot.c();
			t0 = space();
			div1 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t1 = space();
			div0 = element("div");
			if (before_area_slot) before_area_slot.c();
			t2 = space();
			create_component(input.$$.fragment);
			t3 = space();
			if (after_inner_slot) after_inner_slot.c();
			t4 = space();
			if (if_block) if_block.c();
			t5 = space();
			if (inner_end_slot) inner_end_slot.c();
			t6 = space();
			if (default_slot) default_slot.c();
			t7 = space();
			if (after_inner_slot_1) after_inner_slot_1.c();
			this.h();
		},
		l(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true, "data-f7-slot": true });
			var div2_nodes = children(div2);
			if (before_inner_slot) before_inner_slot.l(div2_nodes);
			t0 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (inner_start_slot) inner_start_slot.l(div1_nodes);
			t1 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (before_area_slot) before_area_slot.l(div0_nodes);
			t2 = claim_space(div0_nodes);
			claim_component(input.$$.fragment, div0_nodes);
			t3 = claim_space(div0_nodes);
			if (after_inner_slot) after_inner_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			t4 = claim_space(div1_nodes);
			if (if_block) if_block.l(div1_nodes);
			t5 = claim_space(div1_nodes);
			if (inner_end_slot) inner_end_slot.l(div1_nodes);
			t6 = claim_space(div1_nodes);
			if (default_slot) default_slot.l(div1_nodes);
			div1_nodes.forEach(detach);
			t7 = claim_space(div2_nodes);
			if (after_inner_slot_1) after_inner_slot_1.l(div2_nodes);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "messagebar-area");
			attr(div1, "class", "toolbar-inner");
			set_attributes(div2, div2_data);
		},
		m(target, anchor) {
			insert_hydration(target, div2, anchor);

			if (before_inner_slot) {
				before_inner_slot.m(div2, null);
			}

			append_hydration(div2, t0);
			append_hydration(div2, div1);

			if (inner_start_slot) {
				inner_start_slot.m(div1, null);
			}

			append_hydration(div1, t1);
			append_hydration(div1, div0);

			if (before_area_slot) {
				before_area_slot.m(div0, null);
			}

			append_hydration(div0, t2);
			mount_component(input, div0, null);
			append_hydration(div0, t3);

			if (after_inner_slot) {
				after_inner_slot.m(div0, null);
			}

			append_hydration(div1, t4);
			if (if_block) if_block.m(div1, null);
			append_hydration(div1, t5);

			if (inner_end_slot) {
				inner_end_slot.m(div1, null);
			}

			append_hydration(div1, t6);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_hydration(div2, t7);

			if (after_inner_slot_1) {
				after_inner_slot_1.m(div2, null);
			}

			/*div2_binding*/ ctx[31](div2);
			current = true;
		},
		p(ctx, dirty) {
			if (before_inner_slot) {
				if (before_inner_slot.p && (!current || dirty[0] & /*f7Messagebar*/ 2048 | dirty[1] & /*$$scope*/ 2)) {
					update_slot_base(
						before_inner_slot,
						before_inner_slot_template,
						ctx,
						/*$$scope*/ ctx[32],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[32])
						: get_slot_changes(before_inner_slot_template, /*$$scope*/ ctx[32], dirty, get_before_inner_slot_changes$3),
						get_before_inner_slot_context$3
					);
				}
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && (!current || dirty[0] & /*f7Messagebar*/ 2048 | dirty[1] & /*$$scope*/ 2)) {
					update_slot_base(
						inner_start_slot,
						inner_start_slot_template,
						ctx,
						/*$$scope*/ ctx[32],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[32])
						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[32], dirty, get_inner_start_slot_changes$1),
						get_inner_start_slot_context$1
					);
				}
			}

			if (before_area_slot) {
				if (before_area_slot.p && (!current || dirty[0] & /*f7Messagebar*/ 2048 | dirty[1] & /*$$scope*/ 2)) {
					update_slot_base(
						before_area_slot,
						before_area_slot_template,
						ctx,
						/*$$scope*/ ctx[32],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[32])
						: get_slot_changes(before_area_slot_template, /*$$scope*/ ctx[32], dirty, get_before_area_slot_changes),
						get_before_area_slot_context
					);
				}
			}

			const input_changes = {};
			if (dirty[0] & /*textareaId*/ 64) input_changes.id = /*textareaId*/ ctx[6];
			if (dirty[0] & /*placeholder*/ 256) input_changes.placeholder = /*placeholder*/ ctx[8];
			if (dirty[0] & /*disabled*/ 16) input_changes.disabled = /*disabled*/ ctx[4];
			if (dirty[0] & /*name*/ 128) input_changes.name = /*name*/ ctx[7];
			if (dirty[0] & /*readonly*/ 32) input_changes.readonly = /*readonly*/ ctx[5];
			if (dirty[0] & /*resizable*/ 4) input_changes.resizable = /*resizable*/ ctx[2];

			if (dirty[0] & /*value*/ 1) input_changes.value = typeof /*value*/ ctx[0] === 'undefined'
			? ''
			: /*value*/ ctx[0];

			if (dirty[0] & /*lec*/ 2) input_changes.lec = /*lec*/ ctx[1];
			input.$set(input_changes);

			if (after_inner_slot) {
				if (after_inner_slot.p && (!current || dirty[0] & /*f7Messagebar*/ 2048 | dirty[1] & /*$$scope*/ 2)) {
					update_slot_base(
						after_inner_slot,
						after_inner_slot_template,
						ctx,
						/*$$scope*/ ctx[32],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[32])
						: get_slot_changes(after_inner_slot_template, /*$$scope*/ ctx[32], dirty, get_after_inner_slot_changes$3),
						get_after_inner_slot_context$3
					);
				}
			}

			if (/*sendLink*/ ctx[3] && /*sendLink*/ ctx[3].length > 0 || /*hasSendLinkSlots*/ ctx[12]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*sendLink, hasSendLinkSlots*/ 4104) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$h(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t5);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && (!current || dirty[0] & /*f7Messagebar*/ 2048 | dirty[1] & /*$$scope*/ 2)) {
					update_slot_base(
						inner_end_slot,
						inner_end_slot_template,
						ctx,
						/*$$scope*/ ctx[32],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[32])
						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[32], dirty, get_inner_end_slot_changes$1),
						get_inner_end_slot_context$1
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*f7Messagebar*/ 2048 | dirty[1] & /*$$scope*/ 2)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[32],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[32])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[32], dirty, get_default_slot_changes$2),
						get_default_slot_context$2
					);
				}
			}

			if (after_inner_slot_1) {
				if (after_inner_slot_1.p && (!current || dirty[0] & /*f7Messagebar*/ 2048 | dirty[1] & /*$$scope*/ 2)) {
					update_slot_base(
						after_inner_slot_1,
						after_inner_slot_template_1,
						ctx,
						/*$$scope*/ ctx[32],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[32])
						: get_slot_changes(after_inner_slot_template_1, /*$$scope*/ ctx[32], dirty, get_after_inner_slot_changes_1$1),
						get_after_inner_slot_context_1$1
					);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty[0] & /*classes*/ 8192) && { class: /*classes*/ ctx[13] },
				(!current || dirty[0] & /*f7Slot*/ 512) && { "data-f7-slot": /*f7Slot*/ ctx[9] },
				dirty[0] & /*$$restProps*/ 524288 && restProps(/*$$restProps*/ ctx[19])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(before_inner_slot, local);
			transition_in(inner_start_slot, local);
			transition_in(before_area_slot, local);
			transition_in(input.$$.fragment, local);
			transition_in(after_inner_slot, local);
			transition_in(if_block);
			transition_in(inner_end_slot, local);
			transition_in(default_slot, local);
			transition_in(after_inner_slot_1, local);
			current = true;
		},
		o(local) {
			transition_out(before_inner_slot, local);
			transition_out(inner_start_slot, local);
			transition_out(before_area_slot, local);
			transition_out(input.$$.fragment, local);
			transition_out(after_inner_slot, local);
			transition_out(if_block);
			transition_out(inner_end_slot, local);
			transition_out(default_slot, local);
			transition_out(after_inner_slot_1, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			if (before_inner_slot) before_inner_slot.d(detaching);
			if (inner_start_slot) inner_start_slot.d(detaching);
			if (before_area_slot) before_area_slot.d(detaching);
			destroy_component(input);
			if (after_inner_slot) after_inner_slot.d(detaching);
			if (if_block) if_block.d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (after_inner_slot_1) after_inner_slot_1.d(detaching);
			/*div2_binding*/ ctx[31](null);
		}
	};
}

let index$y = 0;

function instance_1$4($$self, $$props, $$invalidate) {
	let classes;
	let hasSendLinkSlots;

	const omit_props_names = [
		"lec","class","sheetVisible","attachmentsVisible","top","resizable","bottomOffset","topOffset","maxHeight","resizePage","sendLink","value","disabled","readonly","textareaId","name","placeholder","init","f7Slot","instance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { sheetVisible = false } = $$props;
	let { attachmentsVisible = false } = $$props;
	let { top = false } = $$props;
	let { resizable = true } = $$props;
	let { bottomOffset = 0 } = $$props;
	let { topOffset = 0 } = $$props;
	let { maxHeight = undefined } = $$props;
	let { resizePage = true } = $$props;
	let { sendLink = undefined } = $$props;
	let { value = undefined } = $$props;
	let { disabled = false } = $$props;
	let { readonly = false } = $$props;
	let { textareaId = undefined } = $$props;
	let { name = undefined } = $$props;
	let { placeholder = 'Message' } = $$props;
	let { init = true } = $$props;
	let { f7Slot = 'fixed' } = $$props;
	let el;
	let f7Messagebar;
	let updateSheetVisible;
	let updateAttachmentsVisible;

	function instance() {
		return f7Messagebar;
	}

	let initialWatchedSheet = false;

	function watchSheetVisible() {
		if (!initialWatchedSheet) {
			initialWatchedSheet = true;
			return;
		}

		if (!resizable || !f7Messagebar) return;
		updateSheetVisible = true;
	}

	let initialWatchedAttachments;

	function watchAttachmentsVisible() {
		if (!initialWatchedAttachments) {
			initialWatchedAttachments = true;
			return;
		}

		if (!resizable || !f7Messagebar) return;
		updateAttachmentsVisible = true;
	}

	function onChange(event) {
		emit('change', [...event.detail]);
	}

	function onInput(event) {
		emit('input', [...event.detail]);
		$$invalidate(0, value = event.detail[0].target.value);
	}

	function onFocus(event) {
		emit('focus', [...event.detail]);
	}

	function onBlur(event) {
		emit('blur', [...event.detail]);
	}

	function onClick(event) {
		const inputValue = el.querySelector('textarea');

		const clear = f7Messagebar
		? () => {
				f7Messagebar.clear();
			}
		: () => {
				
			};

		emit('submit', [inputValue, clear]);
		emit('send', [inputValue, clear]);
		emit('click', [event]);
	}

	function onAttachmentDelete(inst, attachmentEl, attachmentElIndex) {
		emit('messagebarAttachmentDelete', [inst, attachmentEl, attachmentElIndex]);
	}

	function onAttachmentClick(inst, attachmentEl, attachmentElIndex) {
		emit('messagebarAttachmentClick', [inst, attachmentEl, attachmentElIndex]);
	}

	function onResizePage(inst) {
		emit('messagebarResizePage', [inst]);
	}

	onMount(() => {
		if (!init || !el) return;

		f7ready(() => {
			if (el) {
				const dom7 = app.f7.$;
				const attachmentsEl = dom7(el).find('.toolbar-inner > .messagebar-attachments');
				if (attachmentsEl.length) dom7(el).find('.messagebar-area').prepend(attachmentsEl);
				const sheetEl = dom7(el).find('.toolbar-inner > .messagebar-sheet');
				if (sheetEl.length) dom7(el).append(sheetEl);
			}

			$$invalidate(11, f7Messagebar = app.f7.messagebar.create(noUndefinedProps({
				el,
				top,
				resizePage,
				bottomOffset,
				topOffset,
				maxHeight,
				on: {
					attachmentDelete: onAttachmentDelete,
					attachmentClick: onAttachmentClick,
					resizePage: onResizePage
				}
			})));
		});
	});

	afterUpdate(() => {
		if (!f7Messagebar) return;

		if (el && app.f7) {
			const dom7 = app.f7.$;
			const attachmentsEl = dom7(el).find('.toolbar-inner > .messagebar-attachments');
			if (attachmentsEl.length) dom7(el).find('.messagebar-area').prepend(attachmentsEl);
			const sheetEl = dom7(el).find('.toolbar-inner > .messagebar-sheet');
			if (sheetEl.length) dom7(el).append(sheetEl);
		}

		if (updateSheetVisible) {
			updateSheetVisible = false;
			$$invalidate(11, f7Messagebar.sheetVisible = sheetVisible, f7Messagebar);
			f7Messagebar.resizePage();
		}

		if (updateAttachmentsVisible) {
			updateAttachmentsVisible = false;
			$$invalidate(11, f7Messagebar.attachmentsVisible = attachmentsVisible, f7Messagebar);
			f7Messagebar.resizePage();
		}
	});

	onDestroy(() => {
		if (f7Messagebar && f7Messagebar.destroy) {
			f7Messagebar.destroy();
			$$invalidate(11, f7Messagebar = null);
		}
	});

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(10, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(45, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(1, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(20, className = $$new_props.class);
		if ('sheetVisible' in $$new_props) $$invalidate(21, sheetVisible = $$new_props.sheetVisible);
		if ('attachmentsVisible' in $$new_props) $$invalidate(22, attachmentsVisible = $$new_props.attachmentsVisible);
		if ('top' in $$new_props) $$invalidate(23, top = $$new_props.top);
		if ('resizable' in $$new_props) $$invalidate(2, resizable = $$new_props.resizable);
		if ('bottomOffset' in $$new_props) $$invalidate(24, bottomOffset = $$new_props.bottomOffset);
		if ('topOffset' in $$new_props) $$invalidate(25, topOffset = $$new_props.topOffset);
		if ('maxHeight' in $$new_props) $$invalidate(26, maxHeight = $$new_props.maxHeight);
		if ('resizePage' in $$new_props) $$invalidate(27, resizePage = $$new_props.resizePage);
		if ('sendLink' in $$new_props) $$invalidate(3, sendLink = $$new_props.sendLink);
		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ('disabled' in $$new_props) $$invalidate(4, disabled = $$new_props.disabled);
		if ('readonly' in $$new_props) $$invalidate(5, readonly = $$new_props.readonly);
		if ('textareaId' in $$new_props) $$invalidate(6, textareaId = $$new_props.textareaId);
		if ('name' in $$new_props) $$invalidate(7, name = $$new_props.name);
		if ('placeholder' in $$new_props) $$invalidate(8, placeholder = $$new_props.placeholder);
		if ('init' in $$new_props) $$invalidate(28, init = $$new_props.init);
		if ('f7Slot' in $$new_props) $$invalidate(9, f7Slot = $$new_props.f7Slot);
		if ('$$scope' in $$new_props) $$invalidate(32, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(13, classes = classNames(
			className,
			'toolbar',
			'messagebar',
			{
				'messagebar-attachments-visible': attachmentsVisible,
				'messagebar-sheet-visible': sheetVisible
			},
			colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*sheetVisible*/ 2097152) {
			$: watchSheetVisible(sheetVisible);
		}

		if ($$self.$$.dirty[0] & /*attachmentsVisible*/ 4194304) {
			$: watchAttachmentsVisible(attachmentsVisible);
		}
	};

	$: $$invalidate(12, hasSendLinkSlots = $$slots['send-link']);
	$$props = exclude_internal_props($$props);

	return [
		value,
		lec,
		resizable,
		sendLink,
		disabled,
		readonly,
		textareaId,
		name,
		placeholder,
		f7Slot,
		el,
		f7Messagebar,
		hasSendLinkSlots,
		classes,
		onChange,
		onInput,
		onFocus,
		onBlur,
		onClick,
		$$restProps,
		className,
		sheetVisible,
		attachmentsVisible,
		top,
		bottomOffset,
		topOffset,
		maxHeight,
		resizePage,
		init,
		instance,
		slots,
		div2_binding,
		$$scope
	];
}

class Messagebar extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance_1$4,
			create_fragment$w,
			safe_not_equal,
			{
				lec: 1,
				class: 20,
				sheetVisible: 21,
				attachmentsVisible: 22,
				top: 23,
				resizable: 2,
				bottomOffset: 24,
				topOffset: 25,
				maxHeight: 26,
				resizePage: 27,
				sendLink: 3,
				value: 0,
				disabled: 4,
				readonly: 5,
				textareaId: 6,
				name: 7,
				placeholder: 8,
				init: 28,
				f7Slot: 9,
				instance: 29
			},
			null,
			[-1, -1]
		);
	}

	get instance() {
		return this.$$.ctx[29];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/messages-title.liquivelte generated by Svelte v3.50.0 */

function create_fragment$v(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$x = 0;

function instance$s($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'messages-title', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, $$scope, slots];
}

class Messages_title extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$s, create_fragment$v, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/messages.liquivelte generated by Svelte v3.50.0 */
const get_default_slot_changes$1 = dirty => ({ messages: dirty & /*f7Messages*/ 2 });
const get_default_slot_context$1 = ctx => ({ messages: /*f7Messages*/ ctx[1] });

function create_fragment$u(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[24].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[23], get_default_slot_context$1);
	let div_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[25](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope, f7Messages*/ 8388610)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[23],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[23])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[23], dirty, get_default_slot_changes$1),
						get_default_slot_context$1
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[25](null);
		}
	};
}

let index$w = 0;

function instance_1$3($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"lec","class","autoLayout","messages","newMessagesFirst","scrollMessages","scrollMessagesOnEdge","firstMessageRule","lastMessageRule","tailMessageRule","sameNameMessageRule","sameHeaderMessageRule","sameFooterMessageRule","sameAvatarMessageRule","customClassMessageRule","renderMessage","typing","init","instance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let { autoLayout = false } = $$props;
	let { messages = [] } = $$props;
	let { newMessagesFirst = false } = $$props;
	let { scrollMessages = true } = $$props;
	let { scrollMessagesOnEdge = true } = $$props;
	let { firstMessageRule = undefined } = $$props;
	let { lastMessageRule = undefined } = $$props;
	let { tailMessageRule = undefined } = $$props;
	let { sameNameMessageRule = undefined } = $$props;
	let { sameHeaderMessageRule = undefined } = $$props;
	let { sameFooterMessageRule = undefined } = $$props;
	let { sameAvatarMessageRule = undefined } = $$props;
	let { customClassMessageRule = undefined } = $$props;
	let { renderMessage = undefined } = $$props;
	let { typing = false } = $$props;
	let { init = true } = $$props;
	let el;
	let f7Messages;
	let childrenBeforeUpdated = null;

	function instance() {
		return f7Messages;
	}

	onMount(() => {
		if (!init) return;

		f7ready(() => {
			$$invalidate(1, f7Messages = app.f7.messages.create(noUndefinedProps({
				el,
				autoLayout,
				messages,
				newMessagesFirst,
				scrollMessages,
				scrollMessagesOnEdge,
				firstMessageRule,
				lastMessageRule,
				tailMessageRule,
				sameNameMessageRule,
				sameHeaderMessageRule,
				sameFooterMessageRule,
				sameAvatarMessageRule,
				customClassMessageRule,
				renderMessage
			})));

			if (typing) f7Messages.showTyping();
		});
	});

	beforeUpdate(() => {
		if (!init || !el) return;
		const children = el.children;
		if (!children) return;
		childrenBeforeUpdated = children.length;

		for (let i = 0; i < children.length; i += 1) {
			children[i].classList.add('message-appeared');
		}
	});

	afterUpdate(() => {
		if (!init) return;
		if (!el) return;
		const children = el.children;
		if (!children) return;
		const childrenAfterUpdated = children.length;

		for (let i = 0; i < children.length; i += 1) {
			if (!children[i].classList.contains('message-appeared')) {
				children[i].classList.add('message-appear-from-bottom');
			}
		}

		if (f7Messages && f7Messages.layout && autoLayout) {
			f7Messages.layout();
		}

		if (childrenBeforeUpdated !== childrenAfterUpdated && f7Messages && f7Messages.scroll && scrollMessages) {
			f7Messages.scroll();
		}
	});

	onDestroy(() => {
		if (f7Messages && f7Messages.destroy) {
			f7Messages.destroy();
			$$invalidate(1, f7Messages = null);
		}
	});

	let initialWatched = false;

	function watchTyping(typingPassed) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7Messages) return;
		if (typingPassed) f7Messages.showTyping(); else f7Messages.hideTyping();
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(30, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(4, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ('autoLayout' in $$new_props) $$invalidate(6, autoLayout = $$new_props.autoLayout);
		if ('messages' in $$new_props) $$invalidate(7, messages = $$new_props.messages);
		if ('newMessagesFirst' in $$new_props) $$invalidate(8, newMessagesFirst = $$new_props.newMessagesFirst);
		if ('scrollMessages' in $$new_props) $$invalidate(9, scrollMessages = $$new_props.scrollMessages);
		if ('scrollMessagesOnEdge' in $$new_props) $$invalidate(10, scrollMessagesOnEdge = $$new_props.scrollMessagesOnEdge);
		if ('firstMessageRule' in $$new_props) $$invalidate(11, firstMessageRule = $$new_props.firstMessageRule);
		if ('lastMessageRule' in $$new_props) $$invalidate(12, lastMessageRule = $$new_props.lastMessageRule);
		if ('tailMessageRule' in $$new_props) $$invalidate(13, tailMessageRule = $$new_props.tailMessageRule);
		if ('sameNameMessageRule' in $$new_props) $$invalidate(14, sameNameMessageRule = $$new_props.sameNameMessageRule);
		if ('sameHeaderMessageRule' in $$new_props) $$invalidate(15, sameHeaderMessageRule = $$new_props.sameHeaderMessageRule);
		if ('sameFooterMessageRule' in $$new_props) $$invalidate(16, sameFooterMessageRule = $$new_props.sameFooterMessageRule);
		if ('sameAvatarMessageRule' in $$new_props) $$invalidate(17, sameAvatarMessageRule = $$new_props.sameAvatarMessageRule);
		if ('customClassMessageRule' in $$new_props) $$invalidate(18, customClassMessageRule = $$new_props.customClassMessageRule);
		if ('renderMessage' in $$new_props) $$invalidate(19, renderMessage = $$new_props.renderMessage);
		if ('typing' in $$new_props) $$invalidate(20, typing = $$new_props.typing);
		if ('init' in $$new_props) $$invalidate(21, init = $$new_props.init);
		if ('$$scope' in $$new_props) $$invalidate(23, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(2, classes = classNames(className, 'messages', colorClasses($$props)));

		if ($$self.$$.dirty & /*typing*/ 1048576) {
			$: watchTyping(typing);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		f7Messages,
		classes,
		$$restProps,
		lec,
		className,
		autoLayout,
		messages,
		newMessagesFirst,
		scrollMessages,
		scrollMessagesOnEdge,
		firstMessageRule,
		lastMessageRule,
		tailMessageRule,
		sameNameMessageRule,
		sameHeaderMessageRule,
		sameFooterMessageRule,
		sameAvatarMessageRule,
		customClassMessageRule,
		renderMessage,
		typing,
		init,
		instance,
		$$scope,
		slots,
		div_binding
	];
}

class Messages extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance_1$3, create_fragment$u, safe_not_equal, {
			lec: 4,
			class: 5,
			autoLayout: 6,
			messages: 7,
			newMessagesFirst: 8,
			scrollMessages: 9,
			scrollMessagesOnEdge: 10,
			firstMessageRule: 11,
			lastMessageRule: 12,
			tailMessageRule: 13,
			sameNameMessageRule: 14,
			sameHeaderMessageRule: 15,
			sameFooterMessageRule: 16,
			sameAvatarMessageRule: 17,
			customClassMessageRule: 18,
			renderMessage: 19,
			typing: 20,
			init: 21,
			instance: 22
		});
	}

	get instance() {
		return this.$$.ctx[22];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/nav-left.liquivelte generated by Svelte v3.50.0 */

function create_if_block$g(ctx) {
	let link;
	let current;

	link = new Link({
			props: {
				href: /*backLinkUrl*/ ctx[2] || '#',
				back: true,
				icon: "icon-back",
				force: /*backLinkForce*/ ctx[3] || undefined,
				class: !/*backLinkText*/ ctx[4] ? 'icon-only' : undefined,
				text: /*backLinkText*/ ctx[4],
				onClick: /*onBackClick*/ ctx[6],
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(link.$$.fragment);
		},
		l(nodes) {
			claim_component(link.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(link, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const link_changes = {};
			if (dirty & /*backLinkUrl*/ 4) link_changes.href = /*backLinkUrl*/ ctx[2] || '#';
			if (dirty & /*backLinkForce*/ 8) link_changes.force = /*backLinkForce*/ ctx[3] || undefined;
			if (dirty & /*backLinkText*/ 16) link_changes.class = !/*backLinkText*/ ctx[4] ? 'icon-only' : undefined;
			if (dirty & /*backLinkText*/ 16) link_changes.text = /*backLinkText*/ ctx[4];
			if (dirty & /*lec*/ 1) link_changes.lec = /*lec*/ ctx[0];
			link.$set(link_changes);
		},
		i(local) {
			if (current) return;
			transition_in(link.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(link.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(link, detaching);
		}
	};
}

function create_fragment$t(ctx) {
	let div;
	let t;
	let current;
	let if_block = /*backLink*/ ctx[1] && create_if_block$g(ctx);
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);
	let div_levels = [{ class: /*classes*/ ctx[5] }, restProps(/*$$restProps*/ ctx[7])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (/*backLink*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*backLink*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$g(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 32) && { class: /*classes*/ ctx[5] },
				dirty & /*$$restProps*/ 128 && restProps(/*$$restProps*/ ctx[7])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$v = 0;

function instance$r($$self, $$props, $$invalidate) {
	let classes;
	let needBackLinkText;
	let backLinkText;

	const omit_props_names = [
		"lec","class","backLink","backLinkUrl","backLinkForce","backLinkShowText","sliding"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { backLink = undefined } = $$props;
	let { backLinkUrl = undefined } = $$props;
	let { backLinkForce = undefined } = $$props;
	let { backLinkShowText = undefined } = $$props;
	let { sliding = undefined } = $$props;

	let theme = useTheme(t => {
		$$invalidate(11, theme = t);
	});

	function onBackClick() {
		emit('clickBack');
		emit('backClick');
	}

	$$self.$$set = $$new_props => {
		$$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(0, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ('backLink' in $$new_props) $$invalidate(1, backLink = $$new_props.backLink);
		if ('backLinkUrl' in $$new_props) $$invalidate(2, backLinkUrl = $$new_props.backLinkUrl);
		if ('backLinkForce' in $$new_props) $$invalidate(3, backLinkForce = $$new_props.backLinkForce);
		if ('backLinkShowText' in $$new_props) $$invalidate(9, backLinkShowText = $$new_props.backLinkShowText);
		if ('sliding' in $$new_props) $$invalidate(10, sliding = $$new_props.sliding);
		if ('$$scope' in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(5, classes = classNames(className, 'left', { sliding }, colorClasses($$props)));

		if ($$self.$$.dirty & /*backLinkShowText*/ 512) {
			$: $$invalidate(12, needBackLinkText = backLinkShowText);
		}

		if ($$self.$$.dirty & /*needBackLinkText, theme*/ 6144) {
			$: if (typeof needBackLinkText === 'undefined') $$invalidate(12, needBackLinkText = theme && !theme.md);
		}

		if ($$self.$$.dirty & /*backLink, needBackLinkText*/ 4098) {
			$: $$invalidate(4, backLinkText = backLink !== true && needBackLinkText
			? backLink
			: undefined);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		lec,
		backLink,
		backLinkUrl,
		backLinkForce,
		backLinkText,
		classes,
		onBackClick,
		$$restProps,
		className,
		backLinkShowText,
		sliding,
		theme,
		needBackLinkText,
		$$scope,
		slots
	];
}

class Nav_left extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$r, create_fragment$t, safe_not_equal, {
			lec: 0,
			class: 8,
			backLink: 1,
			backLinkUrl: 2,
			backLinkForce: 3,
			backLinkShowText: 9,
			sliding: 10
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/nav-right.liquivelte generated by Svelte v3.50.0 */

function create_fragment$s(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$u = 0;

function instance$q($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class","sliding"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let { sliding = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('sliding' in $$new_props) $$invalidate(4, sliding = $$new_props.sliding);
		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'right', { sliding }, colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, sliding, $$scope, slots];
}

class Nav_right extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$q, create_fragment$s, safe_not_equal, { lec: 2, class: 3, sliding: 4 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/nav-title-large.liquivelte generated by Svelte v3.50.0 */

function create_fragment$r(ctx) {
	let div1;
	let div0;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div1_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (default_slot) default_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "title-large-text");
			set_attributes(div1, div1_data);
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);
			append_hydration(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$t = 0;

function instance$p($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'title-large', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, $$scope, slots];
}

class Nav_title_large extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$p, create_fragment$r, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/nav-title.liquivelte generated by Svelte v3.50.0 */

function create_if_block_1$9(ctx) {
	let t_value = plainText(/*title*/ ctx[0]) + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 1 && t_value !== (t_value = plainText(/*title*/ ctx[0]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (30:2) {#if typeof subtitle !== 'undefined'}
function create_if_block$f(ctx) {
	let span;
	let t_value = plainText(/*subtitle*/ ctx[1]) + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "subtitle");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*subtitle*/ 2 && t_value !== (t_value = plainText(/*subtitle*/ ctx[1]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

function create_fragment$q(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	let if_block0 = typeof /*title*/ ctx[0] !== 'undefined' && create_if_block_1$9(ctx);
	let if_block1 = typeof /*subtitle*/ ctx[1] !== 'undefined' && create_if_block$f(ctx);
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
	let div_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t1);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (typeof /*title*/ ctx[0] !== 'undefined') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$9(ctx);
					if_block0.c();
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*subtitle*/ ctx[1] !== 'undefined') {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$f(ctx);
					if_block1.c();
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$s = 0;

function instance$o($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class","title","subtitle","sliding"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let { title = undefined } = $$props;
	let { subtitle = undefined } = $$props;
	let { sliding = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(4, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ('title' in $$new_props) $$invalidate(0, title = $$new_props.title);
		if ('subtitle' in $$new_props) $$invalidate(1, subtitle = $$new_props.subtitle);
		if ('sliding' in $$new_props) $$invalidate(6, sliding = $$new_props.sliding);
		if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(2, classes = classNames(className, 'title', { sliding }, colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [title, subtitle, classes, $$restProps, lec, className, sliding, $$scope, slots];
}

class Nav_title extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$o, create_fragment$q, safe_not_equal, {
			lec: 4,
			class: 5,
			title: 0,
			subtitle: 1,
			sliding: 6
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/navbar.liquivelte generated by Svelte v3.50.0 */
const get_after_inner_slot_changes$2 = dirty => ({});
const get_after_inner_slot_context$2 = ctx => ({});
const get_title_large_slot_changes = dirty => ({});
const get_title_large_slot_context = ctx => ({});
const get_right_slot_changes = dirty => ({});
const get_right_slot_context = ctx => ({});
const get_nav_right_slot_changes = dirty => ({});
const get_nav_right_slot_context = ctx => ({});
const get_title_slot_changes = dirty => ({});
const get_title_slot_context = ctx => ({});
const get_left_slot_changes = dirty => ({});
const get_left_slot_context = ctx => ({});
const get_nav_left_slot_changes = dirty => ({});
const get_nav_left_slot_context = ctx => ({});
const get_before_inner_slot_changes$2 = dirty => ({});
const get_before_inner_slot_context$2 = ctx => ({});

// (202:4) {#if backLink || hasLeftSlots}
function create_if_block_3$5(ctx) {
	let navleft;
	let current;

	navleft = new Nav_left({
			props: {
				backLink: /*backLink*/ ctx[1],
				backLinkUrl: /*backLinkUrl*/ ctx[2],
				backLinkForce: /*backLinkForce*/ ctx[3],
				backLinkShowText: /*backLinkShowText*/ ctx[4],
				onBackClick: /*onBackClick*/ ctx[16],
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(navleft.$$.fragment);
		},
		l(nodes) {
			claim_component(navleft.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(navleft, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const navleft_changes = {};
			if (dirty[0] & /*backLink*/ 2) navleft_changes.backLink = /*backLink*/ ctx[1];
			if (dirty[0] & /*backLinkUrl*/ 4) navleft_changes.backLinkUrl = /*backLinkUrl*/ ctx[2];
			if (dirty[0] & /*backLinkForce*/ 8) navleft_changes.backLinkForce = /*backLinkForce*/ ctx[3];
			if (dirty[0] & /*backLinkShowText*/ 16) navleft_changes.backLinkShowText = /*backLinkShowText*/ ctx[4];
			if (dirty[0] & /*lec*/ 1) navleft_changes.lec = /*lec*/ ctx[0];

			if (dirty[1] & /*$$scope*/ 32768) {
				navleft_changes.$$scope = { dirty, ctx };
			}

			navleft.$set(navleft_changes);
		},
		i(local) {
			if (current) return;
			transition_in(navleft.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(navleft.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(navleft, detaching);
		}
	};
}

// (203:6) <NavLeft  {backLink} {backLinkUrl} {backLinkForce} {backLinkShowText} {onBackClick}     lec={lec} >
function create_default_slot_2$1(ctx) {
	let t;
	let current;
	const nav_left_slot_template = /*#slots*/ ctx[44]["nav-left"];
	const nav_left_slot = create_slot(nav_left_slot_template, ctx, /*$$scope*/ ctx[46], get_nav_left_slot_context);
	const left_slot_template = /*#slots*/ ctx[44].left;
	const left_slot = create_slot(left_slot_template, ctx, /*$$scope*/ ctx[46], get_left_slot_context);

	return {
		c() {
			if (nav_left_slot) nav_left_slot.c();
			t = space();
			if (left_slot) left_slot.c();
		},
		l(nodes) {
			if (nav_left_slot) nav_left_slot.l(nodes);
			t = claim_space(nodes);
			if (left_slot) left_slot.l(nodes);
		},
		m(target, anchor) {
			if (nav_left_slot) {
				nav_left_slot.m(target, anchor);
			}

			insert_hydration(target, t, anchor);

			if (left_slot) {
				left_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (nav_left_slot) {
				if (nav_left_slot.p && (!current || dirty[1] & /*$$scope*/ 32768)) {
					update_slot_base(
						nav_left_slot,
						nav_left_slot_template,
						ctx,
						/*$$scope*/ ctx[46],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[46])
						: get_slot_changes(nav_left_slot_template, /*$$scope*/ ctx[46], dirty, get_nav_left_slot_changes),
						get_nav_left_slot_context
					);
				}
			}

			if (left_slot) {
				if (left_slot.p && (!current || dirty[1] & /*$$scope*/ 32768)) {
					update_slot_base(
						left_slot,
						left_slot_template,
						ctx,
						/*$$scope*/ ctx[46],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[46])
						: get_slot_changes(left_slot_template, /*$$scope*/ ctx[46], dirty, get_left_slot_changes),
						get_left_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(nav_left_slot, local);
			transition_in(left_slot, local);
			current = true;
		},
		o(local) {
			transition_out(nav_left_slot, local);
			transition_out(left_slot, local);
			current = false;
		},
		d(detaching) {
			if (nav_left_slot) nav_left_slot.d(detaching);
			if (detaching) detach(t);
			if (left_slot) left_slot.d(detaching);
		}
	};
}

// (208:4) {#if title || subtitle || hasTitleSlots}
function create_if_block_2$5(ctx) {
	let navtitle;
	let current;

	navtitle = new Nav_title({
			props: {
				title: /*title*/ ctx[5],
				subtitle: /*subtitle*/ ctx[6],
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(navtitle.$$.fragment);
		},
		l(nodes) {
			claim_component(navtitle.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(navtitle, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const navtitle_changes = {};
			if (dirty[0] & /*title*/ 32) navtitle_changes.title = /*title*/ ctx[5];
			if (dirty[0] & /*subtitle*/ 64) navtitle_changes.subtitle = /*subtitle*/ ctx[6];
			if (dirty[0] & /*lec*/ 1) navtitle_changes.lec = /*lec*/ ctx[0];

			if (dirty[1] & /*$$scope*/ 32768) {
				navtitle_changes.$$scope = { dirty, ctx };
			}

			navtitle.$set(navtitle_changes);
		},
		i(local) {
			if (current) return;
			transition_in(navtitle.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(navtitle.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(navtitle, detaching);
		}
	};
}

// (209:6) <NavTitle  {title} {subtitle}     lec={lec} >
function create_default_slot_1$1(ctx) {
	let current;
	const title_slot_template = /*#slots*/ ctx[44].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[46], get_title_slot_context);

	return {
		c() {
			if (title_slot) title_slot.c();
		},
		l(nodes) {
			if (title_slot) title_slot.l(nodes);
		},
		m(target, anchor) {
			if (title_slot) {
				title_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (title_slot) {
				if (title_slot.p && (!current || dirty[1] & /*$$scope*/ 32768)) {
					update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[46],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[46])
						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[46], dirty, get_title_slot_changes),
						get_title_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d(detaching) {
			if (title_slot) title_slot.d(detaching);
		}
	};
}

// (213:4) {#if hasRightSlots}
function create_if_block_1$8(ctx) {
	let navright;
	let current;

	navright = new Nav_right({
			props: {
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(navright.$$.fragment);
		},
		l(nodes) {
			claim_component(navright.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(navright, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const navright_changes = {};
			if (dirty[0] & /*lec*/ 1) navright_changes.lec = /*lec*/ ctx[0];

			if (dirty[1] & /*$$scope*/ 32768) {
				navright_changes.$$scope = { dirty, ctx };
			}

			navright.$set(navright_changes);
		},
		i(local) {
			if (current) return;
			transition_in(navright.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(navright.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(navright, detaching);
		}
	};
}

// (214:6) <NavRight      lec={lec} >
function create_default_slot$3(ctx) {
	let t;
	let current;
	const nav_right_slot_template = /*#slots*/ ctx[44]["nav-right"];
	const nav_right_slot = create_slot(nav_right_slot_template, ctx, /*$$scope*/ ctx[46], get_nav_right_slot_context);
	const right_slot_template = /*#slots*/ ctx[44].right;
	const right_slot = create_slot(right_slot_template, ctx, /*$$scope*/ ctx[46], get_right_slot_context);

	return {
		c() {
			if (nav_right_slot) nav_right_slot.c();
			t = space();
			if (right_slot) right_slot.c();
		},
		l(nodes) {
			if (nav_right_slot) nav_right_slot.l(nodes);
			t = claim_space(nodes);
			if (right_slot) right_slot.l(nodes);
		},
		m(target, anchor) {
			if (nav_right_slot) {
				nav_right_slot.m(target, anchor);
			}

			insert_hydration(target, t, anchor);

			if (right_slot) {
				right_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (nav_right_slot) {
				if (nav_right_slot.p && (!current || dirty[1] & /*$$scope*/ 32768)) {
					update_slot_base(
						nav_right_slot,
						nav_right_slot_template,
						ctx,
						/*$$scope*/ ctx[46],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[46])
						: get_slot_changes(nav_right_slot_template, /*$$scope*/ ctx[46], dirty, get_nav_right_slot_changes),
						get_nav_right_slot_context
					);
				}
			}

			if (right_slot) {
				if (right_slot.p && (!current || dirty[1] & /*$$scope*/ 32768)) {
					update_slot_base(
						right_slot,
						right_slot_template,
						ctx,
						/*$$scope*/ ctx[46],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[46])
						: get_slot_changes(right_slot_template, /*$$scope*/ ctx[46], dirty, get_right_slot_changes),
						get_right_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(nav_right_slot, local);
			transition_in(right_slot, local);
			current = true;
		},
		o(local) {
			transition_out(nav_right_slot, local);
			transition_out(right_slot, local);
			current = false;
		},
		d(detaching) {
			if (nav_right_slot) nav_right_slot.d(detaching);
			if (detaching) detach(t);
			if (right_slot) right_slot.d(detaching);
		}
	};
}

// (219:4) {#if largeTitle || hasTitleLargeSlots}
function create_if_block$e(ctx) {
	let div1;
	let div0;
	let t0_value = plainText(/*largeTitle*/ ctx[12]) + "";
	let t0;
	let t1;
	let current;
	const title_large_slot_template = /*#slots*/ ctx[44]["title-large"];
	const title_large_slot = create_slot(title_large_slot_template, ctx, /*$$scope*/ ctx[46], get_title_large_slot_context);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (title_large_slot) title_large_slot.c();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t0 = claim_text(div0_nodes, t0_value);
			t1 = claim_space(div0_nodes);
			if (title_large_slot) title_large_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "title-large-text");
			attr(div1, "class", "title-large");
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);
			append_hydration(div1, div0);
			append_hydration(div0, t0);
			append_hydration(div0, t1);

			if (title_large_slot) {
				title_large_slot.m(div0, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if ((!current || dirty[0] & /*largeTitle*/ 4096) && t0_value !== (t0_value = plainText(/*largeTitle*/ ctx[12]) + "")) set_data(t0, t0_value);

			if (title_large_slot) {
				if (title_large_slot.p && (!current || dirty[1] & /*$$scope*/ 32768)) {
					update_slot_base(
						title_large_slot,
						title_large_slot_template,
						ctx,
						/*$$scope*/ ctx[46],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[46])
						: get_slot_changes(title_large_slot_template, /*$$scope*/ ctx[46], dirty, get_title_large_slot_changes),
						get_title_large_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(title_large_slot, local);
			current = true;
		},
		o(local) {
			transition_out(title_large_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (title_large_slot) title_large_slot.d(detaching);
		}
	};
}

function create_fragment$p(ctx) {
	let div2;
	let div0;
	let t0;
	let t1;
	let div1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let current;
	const before_inner_slot_template = /*#slots*/ ctx[44]["before-inner"];
	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[46], get_before_inner_slot_context$2);
	let if_block0 = (/*backLink*/ ctx[1] || /*hasLeftSlots*/ ctx[15]) && create_if_block_3$5(ctx);
	let if_block1 = (/*title*/ ctx[5] || /*subtitle*/ ctx[6] || /*hasTitleSlots*/ ctx[13]) && create_if_block_2$5(ctx);
	let if_block2 = /*hasRightSlots*/ ctx[14] && create_if_block_1$8(ctx);
	let if_block3 = (/*largeTitle*/ ctx[12] || /*hasTitleLargeSlots*/ ctx[11]) && create_if_block$e(ctx);
	const default_slot_template = /*#slots*/ ctx[44].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[46], null);
	const after_inner_slot_template = /*#slots*/ ctx[44]["after-inner"];
	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[46], get_after_inner_slot_context$2);

	let div2_levels = [
		{ class: /*classes*/ ctx[10] },
		{ "data-f7-slot": /*f7Slot*/ ctx[7] },
		restProps(/*$$restProps*/ ctx[17])
	];

	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			t0 = space();
			if (before_inner_slot) before_inner_slot.c();
			t1 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (default_slot) default_slot.c();
			t6 = space();
			if (after_inner_slot) after_inner_slot.c();
			this.h();
		},
		l(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true, "data-f7-slot": true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			children(div0).forEach(detach);
			t0 = claim_space(div2_nodes);
			if (before_inner_slot) before_inner_slot.l(div2_nodes);
			t1 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (if_block0) if_block0.l(div1_nodes);
			t2 = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			t3 = claim_space(div1_nodes);
			if (if_block2) if_block2.l(div1_nodes);
			t4 = claim_space(div1_nodes);
			if (if_block3) if_block3.l(div1_nodes);
			t5 = claim_space(div1_nodes);
			if (default_slot) default_slot.l(div1_nodes);
			div1_nodes.forEach(detach);
			t6 = claim_space(div2_nodes);
			if (after_inner_slot) after_inner_slot.l(div2_nodes);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "navbar-bg");
			attr(div1, "class", /*innerClasses*/ ctx[9]);
			set_attributes(div2, div2_data);
		},
		m(target, anchor) {
			insert_hydration(target, div2, anchor);
			append_hydration(div2, div0);
			append_hydration(div2, t0);

			if (before_inner_slot) {
				before_inner_slot.m(div2, null);
			}

			append_hydration(div2, t1);
			append_hydration(div2, div1);
			if (if_block0) if_block0.m(div1, null);
			append_hydration(div1, t2);
			if (if_block1) if_block1.m(div1, null);
			append_hydration(div1, t3);
			if (if_block2) if_block2.m(div1, null);
			append_hydration(div1, t4);
			if (if_block3) if_block3.m(div1, null);
			append_hydration(div1, t5);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_hydration(div2, t6);

			if (after_inner_slot) {
				after_inner_slot.m(div2, null);
			}

			/*div2_binding*/ ctx[45](div2);
			current = true;
		},
		p(ctx, dirty) {
			if (before_inner_slot) {
				if (before_inner_slot.p && (!current || dirty[1] & /*$$scope*/ 32768)) {
					update_slot_base(
						before_inner_slot,
						before_inner_slot_template,
						ctx,
						/*$$scope*/ ctx[46],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[46])
						: get_slot_changes(before_inner_slot_template, /*$$scope*/ ctx[46], dirty, get_before_inner_slot_changes$2),
						get_before_inner_slot_context$2
					);
				}
			}

			if (/*backLink*/ ctx[1] || /*hasLeftSlots*/ ctx[15]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*backLink, hasLeftSlots*/ 32770) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3$5(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*title*/ ctx[5] || /*subtitle*/ ctx[6] || /*hasTitleSlots*/ ctx[13]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*title, subtitle, hasTitleSlots*/ 8288) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2$5(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*hasRightSlots*/ ctx[14]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*hasRightSlots*/ 16384) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1$8(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, t4);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*largeTitle*/ ctx[12] || /*hasTitleLargeSlots*/ ctx[11]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*largeTitle, hasTitleLargeSlots*/ 6144) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block$e(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div1, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 32768)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[46],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[46])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[46], dirty, null),
						null
					);
				}
			}

			if (!current || dirty[0] & /*innerClasses*/ 512) {
				attr(div1, "class", /*innerClasses*/ ctx[9]);
			}

			if (after_inner_slot) {
				if (after_inner_slot.p && (!current || dirty[1] & /*$$scope*/ 32768)) {
					update_slot_base(
						after_inner_slot,
						after_inner_slot_template,
						ctx,
						/*$$scope*/ ctx[46],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[46])
						: get_slot_changes(after_inner_slot_template, /*$$scope*/ ctx[46], dirty, get_after_inner_slot_changes$2),
						get_after_inner_slot_context$2
					);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty[0] & /*classes*/ 1024) && { class: /*classes*/ ctx[10] },
				(!current || dirty[0] & /*f7Slot*/ 128) && { "data-f7-slot": /*f7Slot*/ ctx[7] },
				dirty[0] & /*$$restProps*/ 131072 && restProps(/*$$restProps*/ ctx[17])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(before_inner_slot, local);
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(default_slot, local);
			transition_in(after_inner_slot, local);
			current = true;
		},
		o(local) {
			transition_out(before_inner_slot, local);
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(default_slot, local);
			transition_out(after_inner_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			if (before_inner_slot) before_inner_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (default_slot) default_slot.d(detaching);
			if (after_inner_slot) after_inner_slot.d(detaching);
			/*div2_binding*/ ctx[45](null);
		}
	};
}

let index$r = 0;

function instance$n($$self, $$props, $$invalidate) {
	let hasLeftSlots;
	let hasRightSlots;
	let hasTitleSlots;
	let largeTitle;
	let hasTitleLargeSlots;
	let addLeftTitleClass;
	let addCenterTitleClass;
	let isLarge;
	let isTransparent;
	let isTransparentVisible;
	let classes;
	let innerClasses;

	const omit_props_names = [
		"lec","class","backLink","backLinkUrl","backLinkForce","backLinkShowText","sliding","title","subtitle","hidden","noShadow","noHairline","innerClass","innerClassName","large","largeTransparent","transparent","titleLarge","f7Slot","hide","show","size"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { backLink = undefined } = $$props;
	let { backLinkUrl = undefined } = $$props;
	let { backLinkForce = false } = $$props;
	let { backLinkShowText = undefined } = $$props;
	let { sliding = true } = $$props;
	let { title = undefined } = $$props;
	let { subtitle = undefined } = $$props;
	let { hidden = false } = $$props;
	let { noShadow = false } = $$props;
	let { noHairline = false } = $$props;
	let { innerClass = undefined } = $$props;
	let { innerClassName = undefined } = $$props;
	let { large = false } = $$props;
	let { largeTransparent = false } = $$props;
	let { transparent = false } = $$props;
	let { titleLarge = undefined } = $$props;
	let { f7Slot = 'fixed' } = $$props;
	let el;

	let theme = useTheme(t => {
		$$invalidate(32, theme = t);
	});

	let routerPositionClass = '';
	let largeCollapsed = false;
	let routerNavbarRole = null;
	let routerNavbarRoleDetailRoot = false;
	let routerNavbarMasterStack = false;
	let transparentVisible = false;

	function hide(animate) {
		app.f7.navbar.hide(el, animate);
	}

	function show(animate) {
		app.f7.navbar.show(el, animate);
	}

	function size() {
		app.f7.navbar.size(el);
	}

	function onHide(navbarEl) {
		if (el !== navbarEl) return;
		emit('navbarHide');
	}

	function onShow(navbarEl) {
		if (el !== navbarEl) return;
		emit('navbarShow');
	}

	function onNavbarTransparentShow(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(38, transparentVisible = true);
		emit('navbarTransparentShow');
	}

	function onNavbarTransparentHide(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(38, transparentVisible = false);
		emit('navbarTransparentHide');
	}

	function onExpand(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(34, largeCollapsed = false);
		emit('navbarExpand');
	}

	function onCollapse(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(34, largeCollapsed = true);
		emit('navbarCollapse');
	}

	function onNavbarPosition(navbarEl, position) {
		if (el !== navbarEl) return;
		$$invalidate(33, routerPositionClass = position ? `navbar-${position}` : position);
	}

	function onNavbarRole(navbarEl, rolesData) {
		if (el !== navbarEl) return;
		$$invalidate(35, routerNavbarRole = rolesData.role);
		$$invalidate(36, routerNavbarRoleDetailRoot = rolesData.detailRoot);
	}

	function onNavbarMasterStack(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(37, routerNavbarMasterStack = true);
	}

	function onNavbarMasterUnstack(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(37, routerNavbarMasterStack = false);
	}

	function onBackClick() {
		emit('clickBack');
	}

	function mountNavbar() {
		app.f7.on('navbarShow', onShow);
		app.f7.on('navbarHide', onHide);
		app.f7.on('navbarCollapse', onCollapse);
		app.f7.on('navbarExpand', onExpand);
		app.f7.on('navbarPosition', onNavbarPosition);
		app.f7.on('navbarRole', onNavbarRole);
		app.f7.on('navbarMasterStack', onNavbarMasterStack);
		app.f7.on('navbarMasterUnstack', onNavbarMasterUnstack);
		app.f7.on('navbarTransparentShow', onNavbarTransparentShow);
		app.f7.on('navbarTransparentHide', onNavbarTransparentHide);
	}

	function destroyNavbar() {
		app.f7.off('navbarShow', onShow);
		app.f7.off('navbarHide', onHide);
		app.f7.off('navbarCollapse', onCollapse);
		app.f7.off('navbarExpand', onExpand);
		app.f7.off('navbarPosition', onNavbarPosition);
		app.f7.off('navbarRole', onNavbarRole);
		app.f7.off('navbarMasterStack', onNavbarMasterStack);
		app.f7.off('navbarMasterUnstack', onNavbarMasterUnstack);
		app.f7.off('navbarTransparentShow', onNavbarTransparentShow);
		app.f7.off('navbarTransparentHide', onNavbarTransparentHide);
	}

	onMount(() => {
		f7ready(() => {
			mountNavbar();
		});
	});

	afterUpdate(() => {
		if (!app.f7) return;
		app.f7.navbar.size(el);
	});

	onDestroy(() => {
		if (!app.f7) return;
		destroyNavbar();
	});

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(8, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(61, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(0, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(18, className = $$new_props.class);
		if ('backLink' in $$new_props) $$invalidate(1, backLink = $$new_props.backLink);
		if ('backLinkUrl' in $$new_props) $$invalidate(2, backLinkUrl = $$new_props.backLinkUrl);
		if ('backLinkForce' in $$new_props) $$invalidate(3, backLinkForce = $$new_props.backLinkForce);
		if ('backLinkShowText' in $$new_props) $$invalidate(4, backLinkShowText = $$new_props.backLinkShowText);
		if ('sliding' in $$new_props) $$invalidate(19, sliding = $$new_props.sliding);
		if ('title' in $$new_props) $$invalidate(5, title = $$new_props.title);
		if ('subtitle' in $$new_props) $$invalidate(6, subtitle = $$new_props.subtitle);
		if ('hidden' in $$new_props) $$invalidate(20, hidden = $$new_props.hidden);
		if ('noShadow' in $$new_props) $$invalidate(21, noShadow = $$new_props.noShadow);
		if ('noHairline' in $$new_props) $$invalidate(22, noHairline = $$new_props.noHairline);
		if ('innerClass' in $$new_props) $$invalidate(23, innerClass = $$new_props.innerClass);
		if ('innerClassName' in $$new_props) $$invalidate(24, innerClassName = $$new_props.innerClassName);
		if ('large' in $$new_props) $$invalidate(25, large = $$new_props.large);
		if ('largeTransparent' in $$new_props) $$invalidate(26, largeTransparent = $$new_props.largeTransparent);
		if ('transparent' in $$new_props) $$invalidate(27, transparent = $$new_props.transparent);
		if ('titleLarge' in $$new_props) $$invalidate(28, titleLarge = $$new_props.titleLarge);
		if ('f7Slot' in $$new_props) $$invalidate(7, f7Slot = $$new_props.f7Slot);
		if ('$$scope' in $$new_props) $$invalidate(46, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*titleLarge, large, title*/ 301989920) {
			$: $$invalidate(12, largeTitle = titleLarge || large && title);
		}

		if ($$self.$$.dirty[1] & /*theme*/ 2) {
			$: $$invalidate(40, addLeftTitleClass = theme && theme.ios && app.f7 && !app.f7.params.navbar.iosCenterTitle);
		}

		if ($$self.$$.dirty[1] & /*theme*/ 2) {
			$: $$invalidate(39, addCenterTitleClass = theme && theme.md && app.f7 && app.f7.params.navbar.mdCenterTitle || theme && theme.aurora && app.f7 && app.f7.params.navbar.auroraCenterTitle);
		}

		if ($$self.$$.dirty[0] & /*large, largeTransparent*/ 100663296) {
			$: $$invalidate(43, isLarge = large || largeTransparent);
		}

		if ($$self.$$.dirty[0] & /*transparent, largeTransparent*/ 201326592 | $$self.$$.dirty[1] & /*isLarge*/ 4096) {
			$: $$invalidate(42, isTransparent = transparent || isLarge && largeTransparent);
		}

		if ($$self.$$.dirty[1] & /*isTransparent, transparentVisible*/ 2176) {
			$: $$invalidate(41, isTransparentVisible = isTransparent && transparentVisible);
		}

		$: $$invalidate(10, classes = classNames(
			className,
			'navbar',
			routerPositionClass,
			{
				'navbar-hidden': hidden,
				'navbar-large': isLarge,
				'navbar-large-collapsed': isLarge && largeCollapsed,
				'navbar-transparent': isTransparent,
				'navbar-transparent-visible': isTransparentVisible,
				'navbar-master': routerNavbarRole === 'master',
				'navbar-master-detail': routerNavbarRole === 'detail',
				'navbar-master-detail-root': routerNavbarRoleDetailRoot === true,
				'navbar-master-stacked': routerNavbarMasterStack === true,
				'no-shadow': noShadow,
				'no-hairline': noHairline
			},
			colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*innerClass, innerClassName, sliding*/ 25690112 | $$self.$$.dirty[1] & /*addLeftTitleClass, addCenterTitleClass*/ 768) {
			$: $$invalidate(9, innerClasses = classNames('navbar-inner', innerClass, innerClassName, {
				sliding,
				'navbar-inner-left-title': addLeftTitleClass,
				'navbar-inner-centered-title': addCenterTitleClass
			}));
		}
	};

	$: $$invalidate(15, hasLeftSlots = $$slots['nav-left'] || $$slots['left']);

	// eslint-disable-next-line
	$: $$invalidate(14, hasRightSlots = $$slots['nav-right'] || $$slots['right']);

	// eslint-disable-next-line
	$: $$invalidate(13, hasTitleSlots = $$slots['title']);

	// eslint-disable-next-line
	$: $$invalidate(11, hasTitleLargeSlots = $$slots['title-large']);

	$$props = exclude_internal_props($$props);

	return [
		lec,
		backLink,
		backLinkUrl,
		backLinkForce,
		backLinkShowText,
		title,
		subtitle,
		f7Slot,
		el,
		innerClasses,
		classes,
		hasTitleLargeSlots,
		largeTitle,
		hasTitleSlots,
		hasRightSlots,
		hasLeftSlots,
		onBackClick,
		$$restProps,
		className,
		sliding,
		hidden,
		noShadow,
		noHairline,
		innerClass,
		innerClassName,
		large,
		largeTransparent,
		transparent,
		titleLarge,
		hide,
		show,
		size,
		theme,
		routerPositionClass,
		largeCollapsed,
		routerNavbarRole,
		routerNavbarRoleDetailRoot,
		routerNavbarMasterStack,
		transparentVisible,
		addCenterTitleClass,
		addLeftTitleClass,
		isTransparentVisible,
		isTransparent,
		isLarge,
		slots,
		div2_binding,
		$$scope
	];
}

class Navbar extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$n,
			create_fragment$p,
			safe_not_equal,
			{
				lec: 0,
				class: 18,
				backLink: 1,
				backLinkUrl: 2,
				backLinkForce: 3,
				backLinkShowText: 4,
				sliding: 19,
				title: 5,
				subtitle: 6,
				hidden: 20,
				noShadow: 21,
				noHairline: 22,
				innerClass: 23,
				innerClassName: 24,
				large: 25,
				largeTransparent: 26,
				transparent: 27,
				titleLarge: 28,
				f7Slot: 7,
				hide: 29,
				show: 30,
				size: 31
			},
			null,
			[-1, -1, -1]
		);
	}

	get hide() {
		return this.$$.ctx[29];
	}

	get show() {
		return this.$$.ctx[30];
	}

	get size() {
		return this.$$.ctx[31];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/page-content.liquivelte generated by Svelte v3.50.0 */

function create_if_block_3$4(ctx) {
	let div1;
	let preloader;
	let t;
	let div0;
	let current;
	preloader = new Preloader({ props: { lec: /*lec*/ ctx[0] } });

	return {
		c() {
			div1 = element("div");
			create_component(preloader.$$.fragment);
			t = space();
			div0 = element("div");
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(preloader.$$.fragment, div1_nodes);
			t = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			children(div0).forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "ptr-arrow");
			attr(div1, "class", "ptr-preloader");
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);
			mount_component(preloader, div1, null);
			append_hydration(div1, t);
			append_hydration(div1, div0);
			current = true;
		},
		p(ctx, dirty) {
			const preloader_changes = {};
			if (dirty[0] & /*lec*/ 1) preloader_changes.lec = /*lec*/ ctx[0];
			preloader.$set(preloader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(preloader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(preloader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(preloader);
		}
	};
}

// (136:2) {#if infinite && infiniteTop && infinitePreloader}
function create_if_block_2$4(ctx) {
	let preloader;
	let current;

	preloader = new Preloader({
			props: {
				class: "infinite-scroll-preloader",
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(preloader.$$.fragment);
		},
		l(nodes) {
			claim_component(preloader.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(preloader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const preloader_changes = {};
			if (dirty[0] & /*lec*/ 1) preloader_changes.lec = /*lec*/ ctx[0];
			preloader.$set(preloader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(preloader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(preloader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(preloader, detaching);
		}
	};
}

// (140:2) {#if infinite && !infiniteTop && infinitePreloader}
function create_if_block_1$7(ctx) {
	let preloader;
	let current;

	preloader = new Preloader({
			props: {
				class: "infinite-scroll-preloader",
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(preloader.$$.fragment);
		},
		l(nodes) {
			claim_component(preloader.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(preloader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const preloader_changes = {};
			if (dirty[0] & /*lec*/ 1) preloader_changes.lec = /*lec*/ ctx[0];
			preloader.$set(preloader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(preloader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(preloader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(preloader, detaching);
		}
	};
}

// (143:2) {#if ptr && ptrPreloader && ptrBottom}
function create_if_block$d(ctx) {
	let div1;
	let preloader;
	let t;
	let div0;
	let current;
	preloader = new Preloader({ props: { lec: /*lec*/ ctx[0] } });

	return {
		c() {
			div1 = element("div");
			create_component(preloader.$$.fragment);
			t = space();
			div0 = element("div");
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(preloader.$$.fragment, div1_nodes);
			t = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			children(div0).forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "ptr-arrow");
			attr(div1, "class", "ptr-preloader");
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);
			mount_component(preloader, div1, null);
			append_hydration(div1, t);
			append_hydration(div1, div0);
			current = true;
		},
		p(ctx, dirty) {
			const preloader_changes = {};
			if (dirty[0] & /*lec*/ 1) preloader_changes.lec = /*lec*/ ctx[0];
			preloader.$set(preloader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(preloader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(preloader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(preloader);
		}
	};
}

function create_fragment$o(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let div_data_ptr_mousewheel_value;
	let div_data_infinite_distance_value;
	let current;
	let if_block0 = /*ptr*/ ctx[1] && /*ptrPreloader*/ ctx[3] && !/*ptrBottom*/ ctx[4] && create_if_block_3$4(ctx);
	let if_block1 = /*infinite*/ ctx[6] && /*infiniteTop*/ ctx[7] && /*infinitePreloader*/ ctx[9] && create_if_block_2$4(ctx);
	const default_slot_template = /*#slots*/ ctx[22].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);
	let if_block2 = /*infinite*/ ctx[6] && !/*infiniteTop*/ ctx[7] && /*infinitePreloader*/ ctx[9] && create_if_block_1$7(ctx);
	let if_block3 = /*ptr*/ ctx[1] && /*ptrPreloader*/ ctx[3] && /*ptrBottom*/ ctx[4] && create_if_block$d(ctx);

	let div_levels = [
		{ class: /*pageContentClasses*/ ctx[11] },
		{
			"data-ptr-distance": /*ptrDistance*/ ctx[2]
		},
		{
			"data-ptr-mousewheel": div_data_ptr_mousewheel_value = /*ptrMousewheel*/ ctx[5] || undefined
		},
		{
			"data-infinite-distance": div_data_infinite_distance_value = /*infiniteDistance*/ ctx[8] || undefined
		},
		restProps(/*$$restProps*/ ctx[12])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			if (if_block3) if_block3.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {
				class: true,
				"data-ptr-distance": true,
				"data-ptr-mousewheel": true,
				"data-infinite-distance": true
			});

			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (if_block2) if_block2.l(div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block3) if_block3.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_hydration(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_hydration(div, t1);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_hydration(div, t2);
			if (if_block2) if_block2.m(div, null);
			append_hydration(div, t3);
			if (if_block3) if_block3.m(div, null);
			/*div_binding*/ ctx[23](div);
			current = true;
		},
		p(ctx, dirty) {
			if (/*ptr*/ ctx[1] && /*ptrPreloader*/ ctx[3] && !/*ptrBottom*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*ptr, ptrPreloader, ptrBottom*/ 26) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3$4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*infinite*/ ctx[6] && /*infiniteTop*/ ctx[7] && /*infinitePreloader*/ ctx[9]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*infinite, infiniteTop, infinitePreloader*/ 704) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2$4(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 2097152)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[21],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[21])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[21], dirty, null),
						null
					);
				}
			}

			if (/*infinite*/ ctx[6] && !/*infiniteTop*/ ctx[7] && /*infinitePreloader*/ ctx[9]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*infinite, infiniteTop, infinitePreloader*/ 704) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1$7(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, t3);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*ptr*/ ctx[1] && /*ptrPreloader*/ ctx[3] && /*ptrBottom*/ ctx[4]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*ptr, ptrPreloader, ptrBottom*/ 26) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block$d(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div, null);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*pageContentClasses*/ 2048) && { class: /*pageContentClasses*/ ctx[11] },
				(!current || dirty[0] & /*ptrDistance*/ 4) && {
					"data-ptr-distance": /*ptrDistance*/ ctx[2]
				},
				(!current || dirty[0] & /*ptrMousewheel*/ 32 && div_data_ptr_mousewheel_value !== (div_data_ptr_mousewheel_value = /*ptrMousewheel*/ ctx[5] || undefined)) && {
					"data-ptr-mousewheel": div_data_ptr_mousewheel_value
				},
				(!current || dirty[0] & /*infiniteDistance*/ 256 && div_data_infinite_distance_value !== (div_data_infinite_distance_value = /*infiniteDistance*/ ctx[8] || undefined)) && {
					"data-infinite-distance": div_data_infinite_distance_value
				},
				dirty[0] & /*$$restProps*/ 4096 && restProps(/*$$restProps*/ ctx[12])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			/*div_binding*/ ctx[23](null);
		}
	};
}

let index$q = 0;

function instance$m($$self, $$props, $$invalidate) {
	let pageContentClasses;

	const omit_props_names = [
		"lec","tab","tabActive","ptr","ptrDistance","ptrPreloader","ptrBottom","ptrMousewheel","infinite","infiniteTop","infiniteDistance","infinitePreloader","hideBarsOnScroll","hideNavbarOnScroll","hideToolbarOnScroll","messagesContent","loginScreen","class"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { tab = false } = $$props;
	let { tabActive = false } = $$props;
	let { ptr = false } = $$props;
	let { ptrDistance = undefined } = $$props;
	let { ptrPreloader = true } = $$props;
	let { ptrBottom = false } = $$props;
	let { ptrMousewheel = false } = $$props;
	let { infinite = false } = $$props;
	let { infiniteTop = false } = $$props;
	let { infiniteDistance = undefined } = $$props;
	let { infinitePreloader = true } = $$props;
	let { hideBarsOnScroll = false } = $$props;
	let { hideNavbarOnScroll = false } = $$props;
	let { hideToolbarOnScroll = false } = $$props;
	let { messagesContent = false } = $$props;
	let { loginScreen = false } = $$props;
	let { class: className = undefined } = $$props;
	let pageContentEl;

	// Event handlers
	function onPtrPullStart(ptrEl) {
		if (ptrEl !== pageContentEl) return;
		emit('ptrPullStart');
	}

	function onPtrPullMove(ptrEl) {
		if (ptrEl !== pageContentEl) return;
		emit('ptrPullMove');
	}

	function onPtrPullEnd(ptrEl) {
		if (ptrEl !== pageContentEl) return;
		emit('ptrPullEnd');
	}

	function onPtrRefresh(ptrEl, done) {
		if (ptrEl !== pageContentEl) return;
		emit('ptrRefresh', [done]);
	}

	function onPtrDone(ptrEl) {
		if (ptrEl !== pageContentEl) return;
		emit('ptrDone');
	}

	function onInfinite(infEl) {
		if (infEl !== pageContentEl) return;
		emit('infinite');
	}

	function mountPageContent() {
		if (ptr) {
			app.f7.on('ptrPullStart', onPtrPullStart);
			app.f7.on('ptrPullMove', onPtrPullMove);
			app.f7.on('ptrPullEnd', onPtrPullEnd);
			app.f7.on('ptrRefresh', onPtrRefresh);
			app.f7.on('ptrDone', onPtrDone);
		}

		if (infinite) {
			app.f7.on('infinite', onInfinite);
		}
	}

	function destroyPageContent() {
		if (ptr) {
			app.f7.off('ptrPullStart', onPtrPullStart);
			app.f7.off('ptrPullMove', onPtrPullMove);
			app.f7.off('ptrPullEnd', onPtrPullEnd);
			app.f7.off('ptrRefresh', onPtrRefresh);
			app.f7.off('ptrDone', onPtrDone);
		}

		if (infinite) {
			app.f7.off('infinite', onInfinite);
		}
	}

	useTab(() => pageContentEl, emit);

	onMount(() => {
		f7ready(() => {
			mountPageContent();
		});
	});

	onDestroy(() => {
		if (!app.f7) return;
		destroyPageContent();
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			pageContentEl = $$value;
			$$invalidate(10, pageContentEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(34, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(0, lec = $$new_props.lec);
		if ('tab' in $$new_props) $$invalidate(13, tab = $$new_props.tab);
		if ('tabActive' in $$new_props) $$invalidate(14, tabActive = $$new_props.tabActive);
		if ('ptr' in $$new_props) $$invalidate(1, ptr = $$new_props.ptr);
		if ('ptrDistance' in $$new_props) $$invalidate(2, ptrDistance = $$new_props.ptrDistance);
		if ('ptrPreloader' in $$new_props) $$invalidate(3, ptrPreloader = $$new_props.ptrPreloader);
		if ('ptrBottom' in $$new_props) $$invalidate(4, ptrBottom = $$new_props.ptrBottom);
		if ('ptrMousewheel' in $$new_props) $$invalidate(5, ptrMousewheel = $$new_props.ptrMousewheel);
		if ('infinite' in $$new_props) $$invalidate(6, infinite = $$new_props.infinite);
		if ('infiniteTop' in $$new_props) $$invalidate(7, infiniteTop = $$new_props.infiniteTop);
		if ('infiniteDistance' in $$new_props) $$invalidate(8, infiniteDistance = $$new_props.infiniteDistance);
		if ('infinitePreloader' in $$new_props) $$invalidate(9, infinitePreloader = $$new_props.infinitePreloader);
		if ('hideBarsOnScroll' in $$new_props) $$invalidate(15, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
		if ('hideNavbarOnScroll' in $$new_props) $$invalidate(16, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
		if ('hideToolbarOnScroll' in $$new_props) $$invalidate(17, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
		if ('messagesContent' in $$new_props) $$invalidate(18, messagesContent = $$new_props.messagesContent);
		if ('loginScreen' in $$new_props) $$invalidate(19, loginScreen = $$new_props.loginScreen);
		if ('class' in $$new_props) $$invalidate(20, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(21, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(11, pageContentClasses = classNames(
			className,
			'page-content',
			{
				tab,
				'tab-active': tabActive,
				'ptr-content': ptr,
				'ptr-bottom': ptrBottom,
				'infinite-scroll-content': infinite,
				'infinite-scroll-top': infiniteTop,
				'hide-bars-on-scroll': hideBarsOnScroll,
				'hide-navbar-on-scroll': hideNavbarOnScroll,
				'hide-toolbar-on-scroll': hideToolbarOnScroll,
				'messages-content': messagesContent,
				'login-screen-content': loginScreen
			},
			colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		lec,
		ptr,
		ptrDistance,
		ptrPreloader,
		ptrBottom,
		ptrMousewheel,
		infinite,
		infiniteTop,
		infiniteDistance,
		infinitePreloader,
		pageContentEl,
		pageContentClasses,
		$$restProps,
		tab,
		tabActive,
		hideBarsOnScroll,
		hideNavbarOnScroll,
		hideToolbarOnScroll,
		messagesContent,
		loginScreen,
		className,
		$$scope,
		slots,
		div_binding
	];
}

class Page_content extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$m,
			create_fragment$o,
			safe_not_equal,
			{
				lec: 0,
				tab: 13,
				tabActive: 14,
				ptr: 1,
				ptrDistance: 2,
				ptrPreloader: 3,
				ptrBottom: 4,
				ptrMousewheel: 5,
				infinite: 6,
				infiniteTop: 7,
				infiniteDistance: 8,
				infinitePreloader: 9,
				hideBarsOnScroll: 15,
				hideNavbarOnScroll: 16,
				hideToolbarOnScroll: 17,
				messagesContent: 18,
				loginScreen: 19,
				class: 20
			},
			null,
			[-1, -1]
		);
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/page.liquivelte generated by Svelte v3.50.0 */
const get_static_slot_changes_1 = dirty => ({});
const get_static_slot_context_1 = ctx => ({});
const get_static_slot_changes = dirty => ({});
const get_static_slot_context = ctx => ({});
const get_fixed_slot_changes = dirty => ({});
const get_fixed_slot_context = ctx => ({});

// (347:2) {:else}
function create_else_block$6(ctx) {
	let t;
	let current;
	const static_slot_template = /*#slots*/ ctx[47].static;
	const static_slot = create_slot(static_slot_template, ctx, /*$$scope*/ ctx[49], get_static_slot_context_1);
	const default_slot_template = /*#slots*/ ctx[47].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[49], null);

	return {
		c() {
			if (static_slot) static_slot.c();
			t = space();
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (static_slot) static_slot.l(nodes);
			t = claim_space(nodes);
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (static_slot) {
				static_slot.m(target, anchor);
			}

			insert_hydration(target, t, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (static_slot) {
				if (static_slot.p && (!current || dirty[1] & /*$$scope*/ 262144)) {
					update_slot_base(
						static_slot,
						static_slot_template,
						ctx,
						/*$$scope*/ ctx[49],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[49])
						: get_slot_changes(static_slot_template, /*$$scope*/ ctx[49], dirty, get_static_slot_changes_1),
						get_static_slot_context_1
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 262144)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[49],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[49])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[49], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(static_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(static_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (static_slot) static_slot.d(detaching);
			if (detaching) detach(t);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (321:2) {#if pageContent}
function create_if_block$c(ctx) {
	let pagecontent;
	let current;

	pagecontent = new Page_content({
			props: {
				ptr: /*ptr*/ ctx[3],
				ptrDistance: /*ptrDistance*/ ctx[4],
				ptrPreloader: /*ptrPreloader*/ ctx[5],
				ptrBottom: /*ptrBottom*/ ctx[6],
				ptrMousewheel: /*ptrMousewheel*/ ctx[7],
				infinite: /*infinite*/ ctx[8],
				infiniteTop: /*infiniteTop*/ ctx[9],
				infiniteDistance: /*infiniteDistance*/ ctx[10],
				infinitePreloader: /*infinitePreloader*/ ctx[11],
				hideBarsOnScroll: /*hideBarsOnScroll*/ ctx[12],
				hideNavbarOnScroll: /*hideNavbarOnScroll*/ ctx[13],
				hideToolbarOnScroll: /*hideToolbarOnScroll*/ ctx[14],
				messagesContent: /*messagesContent*/ ctx[15],
				loginScreen: /*loginScreen*/ ctx[16],
				onPtrPullStart: /*onPtrPullStart*/ ctx[19],
				onPtrPullMove: /*onPtrPullMove*/ ctx[20],
				onPtrPullEnd: /*onPtrPullEnd*/ ctx[21],
				onPtrRefresh: /*onPtrRefresh*/ ctx[22],
				onPtrDone: /*onPtrDone*/ ctx[23],
				onInfinite: /*onInfinite*/ ctx[24],
				lec: /*lec*/ ctx[0],
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(pagecontent.$$.fragment);
		},
		l(nodes) {
			claim_component(pagecontent.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(pagecontent, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const pagecontent_changes = {};
			if (dirty[0] & /*ptr*/ 8) pagecontent_changes.ptr = /*ptr*/ ctx[3];
			if (dirty[0] & /*ptrDistance*/ 16) pagecontent_changes.ptrDistance = /*ptrDistance*/ ctx[4];
			if (dirty[0] & /*ptrPreloader*/ 32) pagecontent_changes.ptrPreloader = /*ptrPreloader*/ ctx[5];
			if (dirty[0] & /*ptrBottom*/ 64) pagecontent_changes.ptrBottom = /*ptrBottom*/ ctx[6];
			if (dirty[0] & /*ptrMousewheel*/ 128) pagecontent_changes.ptrMousewheel = /*ptrMousewheel*/ ctx[7];
			if (dirty[0] & /*infinite*/ 256) pagecontent_changes.infinite = /*infinite*/ ctx[8];
			if (dirty[0] & /*infiniteTop*/ 512) pagecontent_changes.infiniteTop = /*infiniteTop*/ ctx[9];
			if (dirty[0] & /*infiniteDistance*/ 1024) pagecontent_changes.infiniteDistance = /*infiniteDistance*/ ctx[10];
			if (dirty[0] & /*infinitePreloader*/ 2048) pagecontent_changes.infinitePreloader = /*infinitePreloader*/ ctx[11];
			if (dirty[0] & /*hideBarsOnScroll*/ 4096) pagecontent_changes.hideBarsOnScroll = /*hideBarsOnScroll*/ ctx[12];
			if (dirty[0] & /*hideNavbarOnScroll*/ 8192) pagecontent_changes.hideNavbarOnScroll = /*hideNavbarOnScroll*/ ctx[13];
			if (dirty[0] & /*hideToolbarOnScroll*/ 16384) pagecontent_changes.hideToolbarOnScroll = /*hideToolbarOnScroll*/ ctx[14];
			if (dirty[0] & /*messagesContent*/ 32768) pagecontent_changes.messagesContent = /*messagesContent*/ ctx[15];
			if (dirty[0] & /*loginScreen*/ 65536) pagecontent_changes.loginScreen = /*loginScreen*/ ctx[16];
			if (dirty[0] & /*lec*/ 1) pagecontent_changes.lec = /*lec*/ ctx[0];

			if (dirty[1] & /*$$scope*/ 262144) {
				pagecontent_changes.$$scope = { dirty, ctx };
			}

			pagecontent.$set(pagecontent_changes);
		},
		i(local) {
			if (current) return;
			transition_in(pagecontent.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(pagecontent.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(pagecontent, detaching);
		}
	};
}

// (322:4) <PageContent        {ptr}       {ptrDistance}       {ptrPreloader}       {ptrBottom}       {ptrMousewheel}       {infinite}       {infiniteTop}       {infiniteDistance}       {infinitePreloader}       {hideBarsOnScroll}       {hideNavbarOnScroll}       {hideToolbarOnScroll}       {messagesContent}       {loginScreen}       {onPtrPullStart}       {onPtrPullMove}       {onPtrPullEnd}       {onPtrRefresh}       {onPtrDone}       {onInfinite}          lec={lec} >
function create_default_slot$2(ctx) {
	let t;
	let current;
	const static_slot_template = /*#slots*/ ctx[47].static;
	const static_slot = create_slot(static_slot_template, ctx, /*$$scope*/ ctx[49], get_static_slot_context);
	const default_slot_template = /*#slots*/ ctx[47].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[49], null);

	return {
		c() {
			if (static_slot) static_slot.c();
			t = space();
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (static_slot) static_slot.l(nodes);
			t = claim_space(nodes);
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (static_slot) {
				static_slot.m(target, anchor);
			}

			insert_hydration(target, t, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (static_slot) {
				if (static_slot.p && (!current || dirty[1] & /*$$scope*/ 262144)) {
					update_slot_base(
						static_slot,
						static_slot_template,
						ctx,
						/*$$scope*/ ctx[49],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[49])
						: get_slot_changes(static_slot_template, /*$$scope*/ ctx[49], dirty, get_static_slot_changes),
						get_static_slot_context
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 262144)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[49],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[49])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[49], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(static_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(static_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (static_slot) static_slot.d(detaching);
			if (detaching) detach(t);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$n(ctx) {
	let div;
	let t;
	let current_block_type_index;
	let if_block;
	let current;
	const fixed_slot_template = /*#slots*/ ctx[47].fixed;
	const fixed_slot = create_slot(fixed_slot_template, ctx, /*$$scope*/ ctx[49], get_fixed_slot_context);
	const if_block_creators = [create_if_block$c, create_else_block$6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*pageContent*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let div_levels = [
		{ class: /*classes*/ ctx[18] },
		{ "data-name": /*name*/ ctx[1] },
		restProps(/*$$restProps*/ ctx[25])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (fixed_slot) fixed_slot.c();
			t = space();
			if_block.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true, "data-name": true });
			var div_nodes = children(div);
			if (fixed_slot) fixed_slot.l(div_nodes);
			t = claim_space(div_nodes);
			if_block.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (fixed_slot) {
				fixed_slot.m(div, null);
			}

			append_hydration(div, t);
			if_blocks[current_block_type_index].m(div, null);
			/*div_binding*/ ctx[48](div);
			current = true;
		},
		p(ctx, dirty) {
			if (fixed_slot) {
				if (fixed_slot.p && (!current || dirty[1] & /*$$scope*/ 262144)) {
					update_slot_base(
						fixed_slot,
						fixed_slot_template,
						ctx,
						/*$$scope*/ ctx[49],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[49])
						: get_slot_changes(fixed_slot_template, /*$$scope*/ ctx[49], dirty, get_fixed_slot_changes),
						get_fixed_slot_context
					);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 262144) && { class: /*classes*/ ctx[18] },
				(!current || dirty[0] & /*name*/ 2) && { "data-name": /*name*/ ctx[1] },
				dirty[0] & /*$$restProps*/ 33554432 && restProps(/*$$restProps*/ ctx[25])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(fixed_slot, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(fixed_slot, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (fixed_slot) fixed_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			/*div_binding*/ ctx[48](null);
		}
	};
}

let index$p = 0;

function instance$l($$self, $$props, $$invalidate) {
	let forceSubnavbar;
	let forceNavbarLarge;
	let classes;

	const omit_props_names = [
		"lec","name","stacked","withSubnavbar","subnavbar","withNavbarLarge","navbarLarge","noNavbar","noToolbar","tabs","pageContent","noSwipeback","ptr","ptrDistance","ptrPreloader","ptrBottom","ptrMousewheel","infinite","infiniteTop","infiniteDistance","infinitePreloader","hideBarsOnScroll","hideNavbarOnScroll","hideToolbarOnScroll","messagesContent","loginScreen","class"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { name = undefined } = $$props;
	let { stacked = undefined } = $$props;
	let { withSubnavbar = undefined } = $$props;
	let { subnavbar = undefined } = $$props;
	let { withNavbarLarge = undefined } = $$props;
	let { navbarLarge = undefined } = $$props;
	let { noNavbar = undefined } = $$props;
	let { noToolbar = undefined } = $$props;
	let { tabs = undefined } = $$props;
	let { pageContent = true } = $$props;
	let { noSwipeback = undefined } = $$props;
	let { ptr = undefined } = $$props;
	let { ptrDistance = undefined } = $$props;
	let { ptrPreloader = true } = $$props;
	let { ptrBottom = undefined } = $$props;
	let { ptrMousewheel = undefined } = $$props;
	let { infinite = undefined } = $$props;
	let { infiniteTop = undefined } = $$props;
	let { infiniteDistance = undefined } = $$props;
	let { infinitePreloader = true } = $$props;
	let { hideBarsOnScroll = undefined } = $$props;
	let { hideNavbarOnScroll = undefined } = $$props;
	let { hideToolbarOnScroll = undefined } = $$props;
	let { messagesContent = undefined } = $$props;
	let { loginScreen = undefined } = $$props;
	let { class: className = undefined } = $$props;

	// State
	let el;

	let hasSubnavbar = false;
	let hasNavbarLarge = false;
	let hasNavbarLargeCollapsed = false;
	let hasCardExpandableOpened = false;
	let routerPositionClass = '';
	let routerForceUnstack = false;
	let routerPageRole = null;
	let routerPageRoleDetailRoot = false;
	let routerPageMasterStack = false;

	// Handlers
	function onPtrPullStart() {
		emit('ptrPullStart');
	}

	function onPtrPullMove() {
		emit('ptrPullMove');
	}

	function onPtrPullEnd() {
		emit('ptrPullEnd');
	}

	function onPtrRefresh(done) {
		emit('ptrRefresh', [done]);
	}

	function onPtrDone() {
		emit('ptrDone');
	}

	function onInfinite() {
		emit('infinite');
	}

	// Main Page Events
	function onPageMounted(page) {
		if (el !== page.el) return;
		emit('pageMounted', [page]);
	}

	function onPageInit(page) {
		if (el !== page.el) return;

		if (typeof withSubnavbar === 'undefined' && typeof subnavbar === 'undefined') {
			if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find('.subnavbar').length || page.$el.children('.navbar').find('.subnavbar').length) {
				$$invalidate(36, hasSubnavbar = true);
			}
		}

		if (typeof withNavbarLarge === 'undefined' && typeof navbarLarge === 'undefined') {
			if (page.$navbarEl && page.$navbarEl.hasClass('navbar-large') || page.$el.children('.navbar-large').length) {
				$$invalidate(37, hasNavbarLarge = true);
			}
		}

		emit('pageInit', [page]);
	}

	function onPageReinit(page) {
		if (el !== page.el) return;
		emit('pageReinit', [page]);
	}

	function onPageBeforeIn(page) {
		if (el !== page.el) return;

		if (!page.swipeBack) {
			if (page.from === 'next') {
				$$invalidate(40, routerPositionClass = 'page-next');
			}

			if (page.from === 'previous') {
				$$invalidate(40, routerPositionClass = 'page-previous');
			}
		}

		emit('pageBeforeIn', [page]);
	}

	function onPageBeforeOut(page) {
		if (el !== page.el) return;
		emit('pageBeforeOut', [page]);
	}

	function onPageAfterOut(page) {
		if (el !== page.el) return;

		if (page.to === 'next') {
			$$invalidate(40, routerPositionClass = 'page-next');
		}

		if (page.to === 'previous') {
			$$invalidate(40, routerPositionClass = 'page-previous');
		}

		emit('pageAfterOut', [page]);
	}

	function onPageAfterIn(page) {
		if (el !== page.el) return;
		$$invalidate(40, routerPositionClass = 'page-current');
		emit('pageAfterIn', [page]);
	}

	function onPageBeforeRemove(page) {
		if (el !== page.el) return;

		if (page.$navbarEl && page.$navbarEl[0] && page.$navbarEl.parent()[0] && page.$navbarEl.parent()[0] !== el) {
			page.$el.prepend(page.$navbarEl);
		}

		emit('pageBeforeRemove', [page]);
	}

	function onPageBeforeUnmount(page) {
		if (el !== page.el) return;
		emit('pageBeforeUnmount', [page]);
	}

	// Helper events
	function onPageStack(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(41, routerForceUnstack = false);
	}

	function onPageUnstack(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(41, routerForceUnstack = true);
	}

	function onPagePosition(pageEl, position) {
		if (el !== pageEl) return;
		$$invalidate(40, routerPositionClass = `page-${position}`);
	}

	function onPageRole(pageEl, rolesData) {
		if (el !== pageEl) return;
		$$invalidate(42, routerPageRole = rolesData.role);
		$$invalidate(43, routerPageRoleDetailRoot = rolesData.detailRoot);
	}

	function onPageMasterStack(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(44, routerPageMasterStack = true);
	}

	function onPageMasterUnstack(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(44, routerPageMasterStack = false);
	}

	function onPageNavbarLargeCollapsed(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(38, hasNavbarLargeCollapsed = true);
	}

	function onPageNavbarLargeExpanded(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(38, hasNavbarLargeCollapsed = false);
	}

	function onCardOpened(cardEl, pageEl) {
		if (el !== pageEl) return;
		$$invalidate(39, hasCardExpandableOpened = true);
	}

	function onCardClose(cardEl, pageEl) {
		if (el !== pageEl) return;
		$$invalidate(39, hasCardExpandableOpened = false);
	}

	function onPageTabShow(pageEl) {
		if (el !== pageEl) return;
		emit('pageTabShow');
	}

	function onPageTabHide(pageEl) {
		if (el !== pageEl) return;
		emit('pageTabHide');
	}

	// Mount/destroy
	function mountPage() {
		app.f7.on('pageMounted', onPageMounted);
		app.f7.on('pageInit', onPageInit);
		app.f7.on('pageReinit', onPageReinit);
		app.f7.on('pageBeforeIn', onPageBeforeIn);
		app.f7.on('pageBeforeOut', onPageBeforeOut);
		app.f7.on('pageAfterOut', onPageAfterOut);
		app.f7.on('pageAfterIn', onPageAfterIn);
		app.f7.on('pageBeforeRemove', onPageBeforeRemove);
		app.f7.on('pageBeforeUnmount', onPageBeforeUnmount);
		app.f7.on('pageStack', onPageStack);
		app.f7.on('pageUnstack', onPageUnstack);
		app.f7.on('pagePosition', onPagePosition);
		app.f7.on('pageRole', onPageRole);
		app.f7.on('pageMasterStack', onPageMasterStack);
		app.f7.on('pageMasterUnstack', onPageMasterUnstack);
		app.f7.on('pageNavbarLargeCollapsed', onPageNavbarLargeCollapsed);
		app.f7.on('pageNavbarLargeExpanded', onPageNavbarLargeExpanded);
		app.f7.on('cardOpened', onCardOpened);
		app.f7.on('cardClose', onCardClose);
		app.f7.on('pageTabShow', onPageTabShow);
		app.f7.on('pageTabHide', onPageTabHide);
	}

	function destroyPage() {
		app.f7.off('pageMounted', onPageMounted);
		app.f7.off('pageInit', onPageInit);
		app.f7.off('pageReinit', onPageReinit);
		app.f7.off('pageBeforeIn', onPageBeforeIn);
		app.f7.off('pageBeforeOut', onPageBeforeOut);
		app.f7.off('pageAfterOut', onPageAfterOut);
		app.f7.off('pageAfterIn', onPageAfterIn);
		app.f7.off('pageBeforeRemove', onPageBeforeRemove);
		app.f7.off('pageBeforeUnmount', onPageBeforeUnmount);
		app.f7.off('pageStack', onPageStack);
		app.f7.off('pageUnstack', onPageUnstack);
		app.f7.off('pagePosition', onPagePosition);
		app.f7.off('pageRole', onPageRole);
		app.f7.off('pageMasterStack', onPageMasterStack);
		app.f7.off('pageMasterUnstack', onPageMasterUnstack);
		app.f7.off('pageNavbarLargeCollapsed', onPageNavbarLargeCollapsed);
		app.f7.off('pageNavbarLargeExpanded', onPageNavbarLargeExpanded);
		app.f7.off('cardOpened', onCardOpened);
		app.f7.off('cardClose', onCardClose);
		app.f7.off('pageTabShow', onPageTabShow);
		app.f7.off('pageTabHide', onPageTabHide);
	}

	onMount(() => {
		f7ready(() => {
			if (el) {
				const dom7 = app.f7.$;
				const fixedEls = dom7(el).children('.page-content').children('[data-f7-slot="fixed"]');

				if (fixedEls.length) {
					for (let i = fixedEls.length - 1; i >= 0; i -= 1) {
						dom7(el).prepend(fixedEls[i]);
					}
				}
			}

			mountPage();
		});
	});

	afterUpdate(() => {
		if (el && app.f7) {
			const dom7 = app.f7.$;
			const fixedEls = dom7(el).children('.page-content').children('[data-f7-slot="fixed"]');

			if (fixedEls.length) {
				for (let i = fixedEls.length - 1; i >= 0; i -= 1) {
					dom7(el).prepend(fixedEls[i]);
				}
			}
		}
	});

	onDestroy(() => {
		if (!app.f7) return;
		destroyPage();
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(17, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(75, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(0, lec = $$new_props.lec);
		if ('name' in $$new_props) $$invalidate(1, name = $$new_props.name);
		if ('stacked' in $$new_props) $$invalidate(26, stacked = $$new_props.stacked);
		if ('withSubnavbar' in $$new_props) $$invalidate(27, withSubnavbar = $$new_props.withSubnavbar);
		if ('subnavbar' in $$new_props) $$invalidate(28, subnavbar = $$new_props.subnavbar);
		if ('withNavbarLarge' in $$new_props) $$invalidate(29, withNavbarLarge = $$new_props.withNavbarLarge);
		if ('navbarLarge' in $$new_props) $$invalidate(30, navbarLarge = $$new_props.navbarLarge);
		if ('noNavbar' in $$new_props) $$invalidate(31, noNavbar = $$new_props.noNavbar);
		if ('noToolbar' in $$new_props) $$invalidate(32, noToolbar = $$new_props.noToolbar);
		if ('tabs' in $$new_props) $$invalidate(33, tabs = $$new_props.tabs);
		if ('pageContent' in $$new_props) $$invalidate(2, pageContent = $$new_props.pageContent);
		if ('noSwipeback' in $$new_props) $$invalidate(34, noSwipeback = $$new_props.noSwipeback);
		if ('ptr' in $$new_props) $$invalidate(3, ptr = $$new_props.ptr);
		if ('ptrDistance' in $$new_props) $$invalidate(4, ptrDistance = $$new_props.ptrDistance);
		if ('ptrPreloader' in $$new_props) $$invalidate(5, ptrPreloader = $$new_props.ptrPreloader);
		if ('ptrBottom' in $$new_props) $$invalidate(6, ptrBottom = $$new_props.ptrBottom);
		if ('ptrMousewheel' in $$new_props) $$invalidate(7, ptrMousewheel = $$new_props.ptrMousewheel);
		if ('infinite' in $$new_props) $$invalidate(8, infinite = $$new_props.infinite);
		if ('infiniteTop' in $$new_props) $$invalidate(9, infiniteTop = $$new_props.infiniteTop);
		if ('infiniteDistance' in $$new_props) $$invalidate(10, infiniteDistance = $$new_props.infiniteDistance);
		if ('infinitePreloader' in $$new_props) $$invalidate(11, infinitePreloader = $$new_props.infinitePreloader);
		if ('hideBarsOnScroll' in $$new_props) $$invalidate(12, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
		if ('hideNavbarOnScroll' in $$new_props) $$invalidate(13, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
		if ('hideToolbarOnScroll' in $$new_props) $$invalidate(14, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
		if ('messagesContent' in $$new_props) $$invalidate(15, messagesContent = $$new_props.messagesContent);
		if ('loginScreen' in $$new_props) $$invalidate(16, loginScreen = $$new_props.loginScreen);
		if ('class' in $$new_props) $$invalidate(35, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(49, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*subnavbar, withSubnavbar*/ 402653184 | $$self.$$.dirty[1] & /*hasSubnavbar*/ 32) {
			$: $$invalidate(46, forceSubnavbar = typeof subnavbar === 'undefined' && typeof withSubnavbar === 'undefined'
			? hasSubnavbar
			: false);
		}

		if ($$self.$$.dirty[0] & /*navbarLarge, withNavbarLarge*/ 1610612736 | $$self.$$.dirty[1] & /*hasNavbarLarge*/ 64) {
			$: $$invalidate(45, forceNavbarLarge = typeof navbarLarge === 'undefined' && typeof withNavbarLarge === 'undefined'
			? hasNavbarLarge
			: false);
		}

		$: $$invalidate(18, classes = classNames(
			className,
			'page',
			routerPositionClass,
			{
				stacked: stacked && !routerForceUnstack,
				tabs,
				'page-with-subnavbar': subnavbar || withSubnavbar || forceSubnavbar,
				'page-with-navbar-large': navbarLarge || withNavbarLarge || forceNavbarLarge,
				'no-navbar': noNavbar,
				'no-toolbar': noToolbar,
				'no-swipeback': noSwipeback,
				'page-master': routerPageRole === 'master',
				'page-master-detail': routerPageRole === 'detail',
				'page-master-detail-root': routerPageRoleDetailRoot === true,
				'page-master-stacked': routerPageMasterStack === true,
				'page-with-navbar-large-collapsed': hasNavbarLargeCollapsed === true,
				'page-with-card-opened': hasCardExpandableOpened === true,
				'login-screen-page': loginScreen
			},
			colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		lec,
		name,
		pageContent,
		ptr,
		ptrDistance,
		ptrPreloader,
		ptrBottom,
		ptrMousewheel,
		infinite,
		infiniteTop,
		infiniteDistance,
		infinitePreloader,
		hideBarsOnScroll,
		hideNavbarOnScroll,
		hideToolbarOnScroll,
		messagesContent,
		loginScreen,
		el,
		classes,
		onPtrPullStart,
		onPtrPullMove,
		onPtrPullEnd,
		onPtrRefresh,
		onPtrDone,
		onInfinite,
		$$restProps,
		stacked,
		withSubnavbar,
		subnavbar,
		withNavbarLarge,
		navbarLarge,
		noNavbar,
		noToolbar,
		tabs,
		noSwipeback,
		className,
		hasSubnavbar,
		hasNavbarLarge,
		hasNavbarLargeCollapsed,
		hasCardExpandableOpened,
		routerPositionClass,
		routerForceUnstack,
		routerPageRole,
		routerPageRoleDetailRoot,
		routerPageMasterStack,
		forceNavbarLarge,
		forceSubnavbar,
		slots,
		div_binding,
		$$scope
	];
}

class Page extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$l,
			create_fragment$n,
			safe_not_equal,
			{
				lec: 0,
				name: 1,
				stacked: 26,
				withSubnavbar: 27,
				subnavbar: 28,
				withNavbarLarge: 29,
				navbarLarge: 30,
				noNavbar: 31,
				noToolbar: 32,
				tabs: 33,
				pageContent: 2,
				noSwipeback: 34,
				ptr: 3,
				ptrDistance: 4,
				ptrPreloader: 5,
				ptrBottom: 6,
				ptrMousewheel: 7,
				infinite: 8,
				infiniteTop: 9,
				infiniteDistance: 10,
				infinitePreloader: 11,
				hideBarsOnScroll: 12,
				hideNavbarOnScroll: 13,
				hideToolbarOnScroll: 14,
				messagesContent: 15,
				loginScreen: 16,
				class: 35
			},
			null,
			[-1, -1, -1]
		);
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/photo-browser.liquivelte generated by Svelte v3.50.0 */
let index$o = 0;

function instance_1$2($$self, $$props, $$invalidate) {
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { init = true } = $$props;
	let { params = undefined } = $$props;
	let { photos = undefined } = $$props;
	let { exposition = true } = $$props;
	let { expositionHideCaptions = false } = $$props;
	let { type = undefined } = $$props;
	let { navbar = true } = $$props;
	let { toolbar = true } = $$props;
	let { theme = undefined } = $$props;
	let { captionsTheme = undefined } = $$props;
	let { iconsColor = undefined } = $$props;
	let { swipeToClose = true } = $$props;
	let { pageBackLinkText = undefined } = $$props;
	let { popupCloseLinkText = undefined } = $$props;
	let { navbarOfText = undefined } = $$props;
	let { navbarShowCount = undefined } = $$props;
	let { swiper = undefined } = $$props;
	let { url = undefined } = $$props;
	let { routableModals = false } = $$props;
	let { virtualSlides = true } = $$props;
	let { view = undefined } = $$props;
	let { renderNavbar = undefined } = $$props;
	let { renderToolbar = undefined } = $$props;
	let { renderCaption = undefined } = $$props;
	let { renderObject = undefined } = $$props;
	let { renderLazyPhoto = undefined } = $$props;
	let { renderPhoto = undefined } = $$props;
	let { renderPage = undefined } = $$props;
	let { renderPopup = undefined } = $$props;
	let { renderStandalone = undefined } = $$props;
	let f7PhotoBrowser;

	function instance() {
		return f7PhotoBrowser;
	}

	function open(index) {
		return f7PhotoBrowser.open(index);
	}

	function close() {
		return f7PhotoBrowser.close();
	}

	function expositionToggle() {
		return f7PhotoBrowser.expositionToggle();
	}

	function expositionEnable() {
		return f7PhotoBrowser.expositionEnable();
	}

	function expositionDisable() {
		return f7PhotoBrowser.expositionDisable();
	}

	let initialWatched = false;

	function watchPhotos(newValue) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7PhotoBrowser) return;
		f7PhotoBrowser.params.photos = newValue;

		if (f7PhotoBrowser.opened && f7PhotoBrowser.swiper) {
			f7PhotoBrowser.swiper.update();
		}
	}

	onMount(() => {
		if (!init) return;

		f7ready(() => {
			let pbParams;

			if (typeof params !== 'undefined') pbParams = params; else {
				pbParams = {
					photos,
					exposition,
					expositionHideCaptions,
					type,
					navbar,
					toolbar,
					theme,
					captionsTheme,
					iconsColor,
					swipeToClose,
					pageBackLinkText,
					popupCloseLinkText,
					navbarOfText,
					navbarShowCount,
					swiper,
					url,
					routableModals,
					virtualSlides,
					view,
					renderNavbar,
					renderToolbar,
					renderCaption,
					renderObject,
					renderLazyPhoto,
					renderPhoto,
					renderPage,
					renderPopup,
					renderStandalone
				};
			}

			Object.keys(pbParams).forEach(param => {
				if (typeof pbParams[param] === 'undefined' || pbParams[param] === '') delete pbParams[param];
			});

			pbParams = extend({}, pbParams, {
				on: {
					open() {
						emit('photoBrowserOpen');
					},
					close() {
						emit('photoBrowserClose');
					},
					opened() {
						emit('photoBrowserOpened');
					},
					closed() {
						emit('photoBrowserClosed');
					},
					swipeToClose() {
						emit('photoBrowserSwipeToClose');
					}
				}
			});

			f7PhotoBrowser = app.f7.photoBrowser.create(pbParams);
		});
	});

	onDestroy(() => {
		if (f7PhotoBrowser && f7PhotoBrowser.destroy) {
			f7PhotoBrowser.destroy();
			f7PhotoBrowser = null;
		}
	});

	$$self.$$set = $$new_props => {
		$$invalidate(42, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('lec' in $$new_props) $$invalidate(0, lec = $$new_props.lec);
		if ('init' in $$new_props) $$invalidate(1, init = $$new_props.init);
		if ('params' in $$new_props) $$invalidate(2, params = $$new_props.params);
		if ('photos' in $$new_props) $$invalidate(3, photos = $$new_props.photos);
		if ('exposition' in $$new_props) $$invalidate(4, exposition = $$new_props.exposition);
		if ('expositionHideCaptions' in $$new_props) $$invalidate(5, expositionHideCaptions = $$new_props.expositionHideCaptions);
		if ('type' in $$new_props) $$invalidate(6, type = $$new_props.type);
		if ('navbar' in $$new_props) $$invalidate(7, navbar = $$new_props.navbar);
		if ('toolbar' in $$new_props) $$invalidate(8, toolbar = $$new_props.toolbar);
		if ('theme' in $$new_props) $$invalidate(9, theme = $$new_props.theme);
		if ('captionsTheme' in $$new_props) $$invalidate(10, captionsTheme = $$new_props.captionsTheme);
		if ('iconsColor' in $$new_props) $$invalidate(11, iconsColor = $$new_props.iconsColor);
		if ('swipeToClose' in $$new_props) $$invalidate(12, swipeToClose = $$new_props.swipeToClose);
		if ('pageBackLinkText' in $$new_props) $$invalidate(13, pageBackLinkText = $$new_props.pageBackLinkText);
		if ('popupCloseLinkText' in $$new_props) $$invalidate(14, popupCloseLinkText = $$new_props.popupCloseLinkText);
		if ('navbarOfText' in $$new_props) $$invalidate(15, navbarOfText = $$new_props.navbarOfText);
		if ('navbarShowCount' in $$new_props) $$invalidate(16, navbarShowCount = $$new_props.navbarShowCount);
		if ('swiper' in $$new_props) $$invalidate(17, swiper = $$new_props.swiper);
		if ('url' in $$new_props) $$invalidate(18, url = $$new_props.url);
		if ('routableModals' in $$new_props) $$invalidate(19, routableModals = $$new_props.routableModals);
		if ('virtualSlides' in $$new_props) $$invalidate(20, virtualSlides = $$new_props.virtualSlides);
		if ('view' in $$new_props) $$invalidate(21, view = $$new_props.view);
		if ('renderNavbar' in $$new_props) $$invalidate(22, renderNavbar = $$new_props.renderNavbar);
		if ('renderToolbar' in $$new_props) $$invalidate(23, renderToolbar = $$new_props.renderToolbar);
		if ('renderCaption' in $$new_props) $$invalidate(24, renderCaption = $$new_props.renderCaption);
		if ('renderObject' in $$new_props) $$invalidate(25, renderObject = $$new_props.renderObject);
		if ('renderLazyPhoto' in $$new_props) $$invalidate(26, renderLazyPhoto = $$new_props.renderLazyPhoto);
		if ('renderPhoto' in $$new_props) $$invalidate(27, renderPhoto = $$new_props.renderPhoto);
		if ('renderPage' in $$new_props) $$invalidate(28, renderPage = $$new_props.renderPage);
		if ('renderPopup' in $$new_props) $$invalidate(29, renderPopup = $$new_props.renderPopup);
		if ('renderStandalone' in $$new_props) $$invalidate(30, renderStandalone = $$new_props.renderStandalone);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*photos*/ 8) {
			$: watchPhotos(photos);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		lec,
		init,
		params,
		photos,
		exposition,
		expositionHideCaptions,
		type,
		navbar,
		toolbar,
		theme,
		captionsTheme,
		iconsColor,
		swipeToClose,
		pageBackLinkText,
		popupCloseLinkText,
		navbarOfText,
		navbarShowCount,
		swiper,
		url,
		routableModals,
		virtualSlides,
		view,
		renderNavbar,
		renderToolbar,
		renderCaption,
		renderObject,
		renderLazyPhoto,
		renderPhoto,
		renderPage,
		renderPopup,
		renderStandalone,
		instance,
		open,
		close,
		expositionToggle,
		expositionEnable,
		expositionDisable
	];
}

class Photo_browser extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance_1$2,
			null,
			safe_not_equal,
			{
				lec: 0,
				init: 1,
				params: 2,
				photos: 3,
				exposition: 4,
				expositionHideCaptions: 5,
				type: 6,
				navbar: 7,
				toolbar: 8,
				theme: 9,
				captionsTheme: 10,
				iconsColor: 11,
				swipeToClose: 12,
				pageBackLinkText: 13,
				popupCloseLinkText: 14,
				navbarOfText: 15,
				navbarShowCount: 16,
				swiper: 17,
				url: 18,
				routableModals: 19,
				virtualSlides: 20,
				view: 21,
				renderNavbar: 22,
				renderToolbar: 23,
				renderCaption: 24,
				renderObject: 25,
				renderLazyPhoto: 26,
				renderPhoto: 27,
				renderPage: 28,
				renderPopup: 29,
				renderStandalone: 30,
				instance: 31,
				open: 32,
				close: 33,
				expositionToggle: 34,
				expositionEnable: 35,
				expositionDisable: 36
			},
			null,
			[-1, -1]
		);
	}

	get instance() {
		return this.$$.ctx[31];
	}

	get open() {
		return this.$$.ctx[32];
	}

	get close() {
		return this.$$.ctx[33];
	}

	get expositionToggle() {
		return this.$$.ctx[34];
	}

	get expositionEnable() {
		return this.$$.ctx[35];
	}

	get expositionDisable() {
		return this.$$.ctx[36];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/pie-chart.liquivelte generated by Svelte v3.50.0 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[29] = list[i];
	child_ctx[31] = i;
	return child_ctx;
}

// (165:4) {#each paths as path, index (index)}
function create_each_block$1(key_1, ctx) {
	let path;
	let path_d_value;
	let path_fill_value;
	let path_data_index_value;
	let path_class_value;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[14](/*index*/ ctx[31]);
	}

	function mouseenter_handler() {
		return /*mouseenter_handler*/ ctx[15](/*index*/ ctx[31]);
	}

	return {
		key: key_1,
		first: null,
		c() {
			path = svg_element("path");
			this.h();
		},
		l(nodes) {
			path = claim_svg_element(nodes, "path", {
				d: true,
				fill: true,
				"data-index": true,
				class: true
			});

			children(path).forEach(detach);
			this.h();
		},
		h() {
			attr(path, "d", path_d_value = /*path*/ ctx[29].points);
			attr(path, "fill", path_fill_value = /*path*/ ctx[29].color);
			attr(path, "data-index", path_data_index_value = /*index*/ ctx[31]);

			attr(path, "class", path_class_value = classNames({
				'pie-chart-hidden': /*currentIndex*/ ctx[1] !== null && /*currentIndex*/ ctx[1] !== /*index*/ ctx[31]
			}));

			this.first = path;
		},
		m(target, anchor) {
			insert_hydration(target, path, anchor);

			if (!mounted) {
				dispose = [
					listen(path, "click", click_handler),
					listen(path, "mouseenter", mouseenter_handler),
					listen(path, "mouseleave", /*mouseleave_handler*/ ctx[16])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*paths*/ 8 && path_d_value !== (path_d_value = /*path*/ ctx[29].points)) {
				attr(path, "d", path_d_value);
			}

			if (dirty[0] & /*paths*/ 8 && path_fill_value !== (path_fill_value = /*path*/ ctx[29].color)) {
				attr(path, "fill", path_fill_value);
			}

			if (dirty[0] & /*paths*/ 8 && path_data_index_value !== (path_data_index_value = /*index*/ ctx[31])) {
				attr(path, "data-index", path_data_index_value);
			}

			if (dirty[0] & /*currentIndex, paths*/ 10 && path_class_value !== (path_class_value = classNames({
				'pie-chart-hidden': /*currentIndex*/ ctx[1] !== null && /*currentIndex*/ ctx[1] !== /*index*/ ctx[31]
			}))) {
				attr(path, "class", path_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(path);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$m(ctx) {
	let div;
	let svg;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let svg_viewBox_value;
	let t;
	let current;
	let each_value = /*paths*/ ctx[3];
	const get_key = ctx => /*index*/ ctx[31];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$1(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
	}

	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
	let div_levels = [{ class: /*classes*/ ctx[4] }, restProps(/*$$restProps*/ ctx[6])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			svg = svg_element("svg");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			svg = claim_svg_element(div_nodes, "svg", {
				xmlns: true,
				width: true,
				height: true,
				viewBox: true,
				style: true
			});

			var svg_nodes = children(svg);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(svg_nodes);
			}

			svg_nodes.forEach(detach);
			t = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "width", /*size*/ ctx[0]);
			attr(svg, "height", /*size*/ ctx[0]);
			attr(svg, "viewBox", svg_viewBox_value = `-${/*size*/ ctx[0] / 3} -${/*size*/ ctx[0] / 3} ${/*size*/ ctx[0] * 2 / 3} ${/*size*/ ctx[0] * 2 / 3}`);
			set_style(svg, "transform", "rotate(-90deg)");
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, svg);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(svg, null);
			}

			append_hydration(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[17](div);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*paths, currentIndex, setCurrentIndex*/ 42) {
				each_value = /*paths*/ ctx[3];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, svg, destroy_block, create_each_block$1, null, get_each_context$1);
			}

			if (!current || dirty[0] & /*size*/ 1) {
				attr(svg, "width", /*size*/ ctx[0]);
			}

			if (!current || dirty[0] & /*size*/ 1) {
				attr(svg, "height", /*size*/ ctx[0]);
			}

			if (!current || dirty[0] & /*size*/ 1 && svg_viewBox_value !== (svg_viewBox_value = `-${/*size*/ ctx[0] / 3} -${/*size*/ ctx[0] / 3} ${/*size*/ ctx[0] * 2 / 3} ${/*size*/ ctx[0] * 2 / 3}`)) {
				attr(svg, "viewBox", svg_viewBox_value);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty[0] & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[17](null);
		}
	};
}

let index$n = 0;

function instance$k($$self, $$props, $$invalidate) {
	let classes;
	let paths;
	const omit_props_names = ["lec","class","size","tooltip","datasets","formatTooltip"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { size = 320 } = $$props;
	let { tooltip = false } = $$props;
	let { datasets = [] } = $$props;
	let { formatTooltip = undefined } = $$props;
	let el;
	let currentIndex = null;
	let previousIndex = null;
	let f7Tooltip = null;
	let timeout = null;

	const setCurrentIndex = index => {
		if (index === null) {
			timeout = setTimeout(() => {
				previousIndex = currentIndex;
				$$invalidate(1, currentIndex = index);
			});
		} else {
			clearTimeout(timeout);
			previousIndex = currentIndex;
			$$invalidate(1, currentIndex = index);
		}
	};

	const getSummValue = () => {
		let summ = 0;

		datasets.map(d => d.value || 0).forEach(value => {
			summ += value;
		});

		return summ;
	};

	const getPaths = () => {
		const paths = [];
		let cumulativePercentage = 0;

		function getCoordinatesForPercentage(percentage) {
			const x = Math.cos(2 * Math.PI * percentage) * (size / 3);
			const y = Math.sin(2 * Math.PI * percentage) * (size / 3);
			return [x, y];
		}

		datasets.forEach(({ value, label, color }) => {
			const percentage = value / getSummValue();
			const [startX, startY] = getCoordinatesForPercentage(cumulativePercentage);
			cumulativePercentage += percentage;
			const [endX, endY] = getCoordinatesForPercentage(cumulativePercentage);
			const largeArcFlag = percentage > 0.5 ? 1 : 0;

			const points = [
				`M ${startX} ${startY}`,
				`A ${size / 3} ${size / 3} 0 ${largeArcFlag} 1 ${endX} ${endY}`,
				'L 0 0'
			].join(' '); // Move
			// Arc
			// Line

			paths.push({ points, label, color });
		});

		return paths;
	};

	const formatTooltipText = () => {
		if (currentIndex === null) return '';
		const { value, label, color } = datasets[currentIndex];
		const percentage = value / getSummValue() * 100;

		const round = v => {
			if (parseInt(v, 10) === v) return v;
			return Math.round(v * 100) / 100;
		};

		if (formatTooltip) {
			return formatTooltip({
				index: currentIndex,
				value,
				label,
				color,
				percentage
			});
		}

		const tooltipText = `${label ? `${label}: ` : ''}${round(value)} (${round(percentage)}%)`;

		return `
      <div class="pie-chart-tooltip-label">
        <span class="pie-chart-tooltip-color" style="background-color: ${color};"></span> ${tooltipText}
      </div>
    `;
	};

	const setTooltip = () => {
		if (currentIndex === null && !f7Tooltip) return;
		if (!tooltip || !el || !app.f7) return;

		if (currentIndex !== null && !f7Tooltip) {
			f7Tooltip = app.f7.tooltip.create({
				trigger: 'manual',
				containerEl: el,
				targetEl: el.querySelector(`path[data-index="${currentIndex}"]`),
				text: formatTooltipText(),
				cssClass: 'pie-chart-tooltip'
			});

			f7Tooltip.show();
			return;
		}

		if (!f7Tooltip) return;

		if (currentIndex !== null) {
			f7Tooltip.setText(formatTooltipText());
			f7Tooltip.setTargetEl(el.querySelector(`path[data-index="${currentIndex}"]`));
			f7Tooltip.show();
		} else {
			f7Tooltip.hide();
		}
	};

	const watchCurrentIndex = () => {
		if (currentIndex === previousIndex) return;
		emit('select', [currentIndex, datasets[currentIndex]]);
		setTooltip();
	};

	onDestroy(() => {
		if (f7Tooltip && f7Tooltip.destroy) {
			f7Tooltip.destroy();
		}

		f7Tooltip = null;
	});

	const click_handler = index => setCurrentIndex(index);
	const mouseenter_handler = index => setCurrentIndex(index);
	const mouseleave_handler = () => setCurrentIndex(null);

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(28, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(7, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ('size' in $$new_props) $$invalidate(0, size = $$new_props.size);
		if ('tooltip' in $$new_props) $$invalidate(9, tooltip = $$new_props.tooltip);
		if ('datasets' in $$new_props) $$invalidate(10, datasets = $$new_props.datasets);
		if ('formatTooltip' in $$new_props) $$invalidate(11, formatTooltip = $$new_props.formatTooltip);
		if ('$$scope' in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*className*/ 256) {
			$: $$invalidate(4, classes = classNames('pie-chart', className));
		}

		if ($$self.$$.dirty[0] & /*datasets*/ 1024) {
			$: $$invalidate(3, paths = getPaths(datasets));
		}

		if ($$self.$$.dirty[0] & /*currentIndex*/ 2) {
			$: watchCurrentIndex(currentIndex);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		size,
		currentIndex,
		el,
		paths,
		classes,
		setCurrentIndex,
		$$restProps,
		lec,
		className,
		tooltip,
		datasets,
		formatTooltip,
		$$scope,
		slots,
		click_handler,
		mouseenter_handler,
		mouseleave_handler,
		div_binding
	];
}

class Pie_chart extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$k,
			create_fragment$m,
			safe_not_equal,
			{
				lec: 7,
				class: 8,
				size: 0,
				tooltip: 9,
				datasets: 10,
				formatTooltip: 11
			},
			null,
			[-1, -1]
		);
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/progressbar.liquivelte generated by Svelte v3.50.0 */

function create_fragment$l(ctx) {
	let span1;
	let span0;

	let span1_levels = [
		{ class: /*classes*/ ctx[3] },
		{ "data-progress": /*progress*/ ctx[0] },
		restProps(/*$$restProps*/ ctx[4])
	];

	let span1_data = {};

	for (let i = 0; i < span1_levels.length; i += 1) {
		span1_data = assign(span1_data, span1_levels[i]);
	}

	return {
		c() {
			span1 = element("span");
			span0 = element("span");
			this.h();
		},
		l(nodes) {
			span1 = claim_element(nodes, "SPAN", { class: true, "data-progress": true });
			var span1_nodes = children(span1);
			span0 = claim_element(span1_nodes, "SPAN", { style: true });
			children(span0).forEach(detach);
			span1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span0, "style", /*transformStyle*/ ctx[2]);
			set_attributes(span1, span1_data);
		},
		m(target, anchor) {
			insert_hydration(target, span1, anchor);
			append_hydration(span1, span0);
			/*span1_binding*/ ctx[9](span1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*transformStyle*/ 4) {
				attr(span0, "style", /*transformStyle*/ ctx[2]);
			}

			set_attributes(span1, span1_data = get_spread_update(span1_levels, [
				dirty & /*classes*/ 8 && { class: /*classes*/ ctx[3] },
				dirty & /*progress*/ 1 && { "data-progress": /*progress*/ ctx[0] },
				dirty & /*$$restProps*/ 16 && restProps(/*$$restProps*/ ctx[4])
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(span1);
			/*span1_binding*/ ctx[9](null);
		}
	};
}

let index$m = 0;

function instance$j($$self, $$props, $$invalidate) {
	let classes;
	let transformStyle;
	const omit_props_names = ["lec","class","progress","infinite","set"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let { progress = 0 } = $$props;
	let { infinite = false } = $$props;
	let el;

	function set(progress, speed) {
		if (!app.f7) return;
		app.f7.progressbar.set(el, progress, speed);
	}

	function span1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(5, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('progress' in $$new_props) $$invalidate(0, progress = $$new_props.progress);
		if ('infinite' in $$new_props) $$invalidate(7, infinite = $$new_props.infinite);
	};

	$$self.$$.update = () => {
		$: $$invalidate(3, classes = classNames(className, 'progressbar', { 'progressbar-infinite': infinite }, colorClasses($$props)));

		if ($$self.$$.dirty & /*progress*/ 1) {
			$: $$invalidate(2, transformStyle = {
				transform: progress ? `translate3d(${-100 + progress}%, 0, 0)` : '',
				WebkitTransform: progress ? `translate3d(${-100 + progress}%, 0, 0)` : ''
			});
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		progress,
		el,
		transformStyle,
		classes,
		$$restProps,
		lec,
		className,
		infinite,
		set,
		span1_binding
	];
}

class Progressbar extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$j, create_fragment$l, safe_not_equal, {
			lec: 5,
			class: 6,
			progress: 0,
			infinite: 7,
			set: 8
		});
	}

	get set() {
		return this.$$.ctx[8];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/radio.liquivelte generated by Svelte v3.50.0 */

function create_fragment$k(ctx) {
	let label;
	let input;
	let input_value_value;
	let t0;
	let i;
	let t1;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	let label_levels = [{ class: /*classes*/ ctx[6] }, restProps(/*$$restProps*/ ctx[8])];
	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	return {
		c() {
			label = element("label");
			input = element("input");
			t0 = space();
			i = element("i");
			t1 = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			label = claim_element(nodes, "LABEL", { class: true });
			var label_nodes = children(label);
			input = claim_element(label_nodes, "INPUT", { type: true, name: true });
			t0 = claim_space(label_nodes);
			i = claim_element(label_nodes, "I", { class: true });
			children(i).forEach(detach);
			t1 = claim_space(label_nodes);
			if (default_slot) default_slot.l(label_nodes);
			label_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(input, "type", "radio");
			attr(input, "name", /*name*/ ctx[1]);

			input.value = input_value_value = typeof /*value*/ ctx[2] === 'undefined'
			? ''
			: /*value*/ ctx[2];

			input.disabled = /*disabled*/ ctx[3];
			input.readOnly = /*readonly*/ ctx[4];
			input.checked = /*checked*/ ctx[0];
			attr(i, "class", "icon-radio");
			set_attributes(label, label_data);
		},
		m(target, anchor) {
			insert_hydration(target, label, anchor);
			append_hydration(label, input);
			/*input_binding*/ ctx[13](input);
			append_hydration(label, t0);
			append_hydration(label, i);
			append_hydration(label, t1);

			if (default_slot) {
				default_slot.m(label, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(input, "change", /*onChange*/ ctx[7]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*name*/ 2) {
				attr(input, "name", /*name*/ ctx[1]);
			}

			if (!current || dirty & /*value*/ 4 && input_value_value !== (input_value_value = typeof /*value*/ ctx[2] === 'undefined'
			? ''
			: /*value*/ ctx[2])) {
				input.value = input_value_value;
			}

			if (!current || dirty & /*disabled*/ 8) {
				input.disabled = /*disabled*/ ctx[3];
			}

			if (!current || dirty & /*readonly*/ 16) {
				input.readOnly = /*readonly*/ ctx[4];
			}

			if (!current || dirty & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				(!current || dirty & /*classes*/ 64) && { class: /*classes*/ ctx[6] },
				dirty & /*$$restProps*/ 256 && restProps(/*$$restProps*/ ctx[8])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label);
			/*input_binding*/ ctx[13](null);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

let index$l = 0;

function instance$i($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class","checked","name","value","disabled","readonly"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { checked = undefined } = $$props;
	let { name = undefined } = $$props;
	let { value = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let inputEl;

	function onChange(event) {
		emit('change', [event]);
		$$invalidate(0, checked = event.target.checked);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputEl = $$value;
			$$invalidate(5, inputEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(16, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(9, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(10, className = $$new_props.class);
		if ('checked' in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ('name' in $$new_props) $$invalidate(1, name = $$new_props.name);
		if ('value' in $$new_props) $$invalidate(2, value = $$new_props.value);
		if ('disabled' in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
		if ('readonly' in $$new_props) $$invalidate(4, readonly = $$new_props.readonly);
		if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(6, classes = classNames(className, 'radio', { disabled }, colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);

	return [
		checked,
		name,
		value,
		disabled,
		readonly,
		inputEl,
		classes,
		onChange,
		$$restProps,
		lec,
		className,
		$$scope,
		slots,
		input_binding
	];
}

class Radio extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$i, create_fragment$k, safe_not_equal, {
			lec: 9,
			class: 10,
			checked: 0,
			name: 1,
			value: 2,
			disabled: 3,
			readonly: 4
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/row.liquivelte generated by Svelte v3.50.0 */

function create_if_block_2$3(ctx) {
	let p;
	let t;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
	let if_block = /*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2] && create_if_block_3$3(ctx);
	let p_levels = [{ class: /*classes*/ ctx[4] }, restProps(/*$$restProps*/ ctx[6])];
	let p_data = {};

	for (let i = 0; i < p_levels.length; i += 1) {
		p_data = assign(p_data, p_levels[i]);
	}

	return {
		c() {
			p = element("p");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			if (default_slot) default_slot.l(p_nodes);
			t = claim_space(p_nodes);
			if (if_block) if_block.l(p_nodes);
			p_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(p, p_data);
		},
		m(target, anchor) {
			insert_hydration(target, p, anchor);

			if (default_slot) {
				default_slot.m(p, null);
			}

			append_hydration(p, t);
			if (if_block) if_block.m(p, null);
			/*p_binding*/ ctx[15](p);
			current = true;

			if (!mounted) {
				dispose = listen(p, "click", /*onClick*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
						null
					);
				}
			}

			if (/*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2]) {
				if (if_block) {
					
				} else {
					if_block = create_if_block_3$3(ctx);
					if_block.c();
					if_block.m(p, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			set_attributes(p, p_data = get_spread_update(p_levels, [
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(p);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			/*p_binding*/ ctx[15](null);
			mounted = false;
			dispose();
		}
	};
}

// (58:0) {#if tag === 'div'}
function create_if_block$b(ctx) {
	let div;
	let t;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
	let if_block = /*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2] && create_if_block_1$6(ctx);
	let div_levels = [{ class: /*classes*/ ctx[4] }, restProps(/*$$restProps*/ ctx[6])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			t = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_hydration(div, t);
			if (if_block) if_block.m(div, null);
			/*div_binding*/ ctx[14](div);
			current = true;

			if (!mounted) {
				dispose = listen(div, "click", /*onClick*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
						null
					);
				}
			}

			if (/*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2]) {
				if (if_block) {
					
				} else {
					if_block = create_if_block_1$6(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			/*div_binding*/ ctx[14](null);
			mounted = false;
			dispose();
		}
	};
}

// (66:4) {#if resizable && resizableHandler}
function create_if_block_3$3(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "resize-handler");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (61:4) {#if resizable && resizableHandler}
function create_if_block_1$6(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "resize-handler");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

function create_fragment$j(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$b, create_if_block_2$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tag*/ ctx[0] === 'div') return 0;
		if (/*tag*/ ctx[0] === 'p') return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, -1))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

let index$k = 0;

function instance$h($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"lec","class","noGap","tag","resizable","resizableFixed","resizableAbsolute","resizableHandler"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { noGap = false } = $$props;
	let { tag = 'div' } = $$props;
	let { resizable = false } = $$props;
	let { resizableFixed = false } = $$props;
	let { resizableAbsolute = false } = $$props;
	let { resizableHandler = true } = $$props;
	let el;

	function onClick() {
		emit('click');
	}

	function onResize(targetEl) {
		if (el !== targetEl) return;
		emit('gridResize');
	}

	onMount(() => {
		f7ready(() => {
			app.f7.on('gridResize', onResize);
		});
	});

	onDestroy(() => {
		if (!app.f7) return;
		app.f7.off('gridResize', onResize);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	function p_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(19, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(7, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ('noGap' in $$new_props) $$invalidate(9, noGap = $$new_props.noGap);
		if ('tag' in $$new_props) $$invalidate(0, tag = $$new_props.tag);
		if ('resizable' in $$new_props) $$invalidate(1, resizable = $$new_props.resizable);
		if ('resizableFixed' in $$new_props) $$invalidate(10, resizableFixed = $$new_props.resizableFixed);
		if ('resizableAbsolute' in $$new_props) $$invalidate(11, resizableAbsolute = $$new_props.resizableAbsolute);
		if ('resizableHandler' in $$new_props) $$invalidate(2, resizableHandler = $$new_props.resizableHandler);
		if ('$$scope' in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(4, classes = classNames(
			className,
			'row',
			{
				'no-gap': noGap,
				resizable,
				'resizable-fixed': resizableFixed,
				'resizable-absolute': resizableAbsolute
			},
			colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		tag,
		resizable,
		resizableHandler,
		el,
		classes,
		onClick,
		$$restProps,
		lec,
		className,
		noGap,
		resizableFixed,
		resizableAbsolute,
		$$scope,
		slots,
		div_binding,
		p_binding
	];
}

class Row extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$h, create_fragment$j, safe_not_equal, {
			lec: 7,
			class: 8,
			noGap: 9,
			tag: 0,
			resizable: 1,
			resizableFixed: 10,
			resizableAbsolute: 11,
			resizableHandler: 2
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/searchbar.liquivelte generated by Svelte v3.50.0 */

const get_after_inner_slot_changes_1 = dirty => ({
	searchbar: dirty[0] & /*f7Searchbar*/ 4096
});

const get_after_inner_slot_context_1 = ctx => ({ searchbar: /*f7Searchbar*/ ctx[12] });

const get_default_slot_changes_1 = dirty => ({
	searchbar: dirty[0] & /*f7Searchbar*/ 4096
});

const get_default_slot_context_1 = ctx => ({ searchbar: /*f7Searchbar*/ ctx[12] });

const get_inner_end_slot_changes_1 = dirty => ({
	searchbar: dirty[0] & /*f7Searchbar*/ 4096
});

const get_inner_end_slot_context_1 = ctx => ({ searchbar: /*f7Searchbar*/ ctx[12] });

const get_input_wrap_end_slot_changes_1 = dirty => ({
	searchbar: dirty[0] & /*f7Searchbar*/ 4096
});

const get_input_wrap_end_slot_context_1 = ctx => ({ searchbar: /*f7Searchbar*/ ctx[12] });

const get_input_wrap_start_slot_changes_1 = dirty => ({
	searchbar: dirty[0] & /*f7Searchbar*/ 4096
});

const get_input_wrap_start_slot_context_1 = ctx => ({ searchbar: /*f7Searchbar*/ ctx[12] });

const get_inner_start_slot_changes_1 = dirty => ({
	searchbar: dirty[0] & /*f7Searchbar*/ 4096
});

const get_inner_start_slot_context_1 = ctx => ({ searchbar: /*f7Searchbar*/ ctx[12] });

const get_before_inner_slot_changes_1 = dirty => ({
	searchbar: dirty[0] & /*f7Searchbar*/ 4096
});

const get_before_inner_slot_context_1 = ctx => ({ searchbar: /*f7Searchbar*/ ctx[12] });

const get_after_inner_slot_changes$1 = dirty => ({
	searchbar: dirty[0] & /*f7Searchbar*/ 4096
});

const get_after_inner_slot_context$1 = ctx => ({ searchbar: /*f7Searchbar*/ ctx[12] });

const get_default_slot_changes = dirty => ({
	searchbar: dirty[0] & /*f7Searchbar*/ 4096
});

const get_default_slot_context = ctx => ({ searchbar: /*f7Searchbar*/ ctx[12] });

const get_inner_end_slot_changes = dirty => ({
	searchbar: dirty[0] & /*f7Searchbar*/ 4096
});

const get_inner_end_slot_context = ctx => ({ searchbar: /*f7Searchbar*/ ctx[12] });

const get_input_wrap_end_slot_changes = dirty => ({
	searchbar: dirty[0] & /*f7Searchbar*/ 4096
});

const get_input_wrap_end_slot_context = ctx => ({ searchbar: /*f7Searchbar*/ ctx[12] });

const get_input_wrap_start_slot_changes = dirty => ({
	searchbar: dirty[0] & /*f7Searchbar*/ 4096
});

const get_input_wrap_start_slot_context = ctx => ({ searchbar: /*f7Searchbar*/ ctx[12] });

const get_inner_start_slot_changes = dirty => ({
	searchbar: dirty[0] & /*f7Searchbar*/ 4096
});

const get_inner_start_slot_context = ctx => ({ searchbar: /*f7Searchbar*/ ctx[12] });

const get_before_inner_slot_changes$1 = dirty => ({
	searchbar: dirty[0] & /*f7Searchbar*/ 4096
});

const get_before_inner_slot_context$1 = ctx => ({ searchbar: /*f7Searchbar*/ ctx[12] });

// (221:0) {:else}
function create_else_block$5(ctx) {
	let div2;
	let t0;
	let div1;
	let t1;
	let div0;
	let t2;
	let input;
	let input_value_value;
	let t3;
	let i;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let t9;
	let current;
	let mounted;
	let dispose;
	const before_inner_slot_template = /*#slots*/ ctx[53]["before-inner"];
	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[52], get_before_inner_slot_context_1);
	const inner_start_slot_template = /*#slots*/ ctx[53]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[52], get_inner_start_slot_context_1);
	const input_wrap_start_slot_template = /*#slots*/ ctx[53]["input-wrap-start"];
	const input_wrap_start_slot = create_slot(input_wrap_start_slot_template, ctx, /*$$scope*/ ctx[52], get_input_wrap_start_slot_context_1);
	let if_block0 = /*clearButton*/ ctx[9] && create_if_block_4$1(ctx);
	const input_wrap_end_slot_template = /*#slots*/ ctx[53]["input-wrap-end"];
	const input_wrap_end_slot = create_slot(input_wrap_end_slot_template, ctx, /*$$scope*/ ctx[52], get_input_wrap_end_slot_context_1);
	let if_block1 = /*disableButton*/ ctx[7] && create_if_block_3$2(ctx);
	const inner_end_slot_template = /*#slots*/ ctx[53]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[52], get_inner_end_slot_context_1);
	const default_slot_template = /*#slots*/ ctx[53].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[52], get_default_slot_context_1);
	const after_inner_slot_template = /*#slots*/ ctx[53]["after-inner"];
	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[52], get_after_inner_slot_context_1);

	let div2_levels = [
		{ class: /*classes*/ ctx[13] },
		{ "data-f7-slot": /*f7Slot*/ ctx[10] },
		restProps(/*$$restProps*/ ctx[21])
	];

	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	return {
		c() {
			div2 = element("div");
			if (before_inner_slot) before_inner_slot.c();
			t0 = space();
			div1 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t1 = space();
			div0 = element("div");
			if (input_wrap_start_slot) input_wrap_start_slot.c();
			t2 = space();
			input = element("input");
			t3 = space();
			i = element("i");
			t4 = space();
			if (if_block0) if_block0.c();
			t5 = space();
			if (input_wrap_end_slot) input_wrap_end_slot.c();
			t6 = space();
			if (if_block1) if_block1.c();
			t7 = space();
			if (inner_end_slot) inner_end_slot.c();
			t8 = space();
			if (default_slot) default_slot.c();
			t9 = space();
			if (after_inner_slot) after_inner_slot.c();
			this.h();
		},
		l(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true, "data-f7-slot": true });
			var div2_nodes = children(div2);
			if (before_inner_slot) before_inner_slot.l(div2_nodes);
			t0 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (inner_start_slot) inner_start_slot.l(div1_nodes);
			t1 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (input_wrap_start_slot) input_wrap_start_slot.l(div0_nodes);
			t2 = claim_space(div0_nodes);

			input = claim_element(div0_nodes, "INPUT", {
				placeholder: true,
				autocomplete: true,
				autocorrect: true,
				autocapitalize: true,
				spellcheck: true,
				type: true
			});

			t3 = claim_space(div0_nodes);
			i = claim_element(div0_nodes, "I", { class: true });
			children(i).forEach(detach);
			t4 = claim_space(div0_nodes);
			if (if_block0) if_block0.l(div0_nodes);
			t5 = claim_space(div0_nodes);
			if (input_wrap_end_slot) input_wrap_end_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			t6 = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			t7 = claim_space(div1_nodes);
			if (inner_end_slot) inner_end_slot.l(div1_nodes);
			t8 = claim_space(div1_nodes);
			if (default_slot) default_slot.l(div1_nodes);
			div1_nodes.forEach(detach);
			t9 = claim_space(div2_nodes);
			if (after_inner_slot) after_inner_slot.l(div2_nodes);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			input.value = input_value_value = typeof /*value*/ ctx[0] === 'undefined'
			? ''
			: /*value*/ ctx[0];

			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			attr(input, "autocomplete", /*autocomplete*/ ctx[3]);
			attr(input, "autocorrect", /*autocorrect*/ ctx[4]);
			attr(input, "autocapitalize", /*autocapitalize*/ ctx[5]);
			attr(input, "spellcheck", /*spellcheck*/ ctx[6]);
			attr(input, "type", "search");
			attr(i, "class", "searchbar-icon");
			attr(div0, "class", "searchbar-input-wrap");
			attr(div1, "class", "searchbar-inner");
			set_attributes(div2, div2_data);
		},
		m(target, anchor) {
			insert_hydration(target, div2, anchor);

			if (before_inner_slot) {
				before_inner_slot.m(div2, null);
			}

			append_hydration(div2, t0);
			append_hydration(div2, div1);

			if (inner_start_slot) {
				inner_start_slot.m(div1, null);
			}

			append_hydration(div1, t1);
			append_hydration(div1, div0);

			if (input_wrap_start_slot) {
				input_wrap_start_slot.m(div0, null);
			}

			append_hydration(div0, t2);
			append_hydration(div0, input);
			append_hydration(div0, t3);
			append_hydration(div0, i);
			append_hydration(div0, t4);
			if (if_block0) if_block0.m(div0, null);
			append_hydration(div0, t5);

			if (input_wrap_end_slot) {
				input_wrap_end_slot.m(div0, null);
			}

			append_hydration(div1, t6);
			if (if_block1) if_block1.m(div1, null);
			append_hydration(div1, t7);

			if (inner_end_slot) {
				inner_end_slot.m(div1, null);
			}

			append_hydration(div1, t8);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_hydration(div2, t9);

			if (after_inner_slot) {
				after_inner_slot.m(div2, null);
			}

			/*div2_binding*/ ctx[55](div2);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "input", /*onInput*/ ctx[15]),
					listen(input, "change", /*onChange*/ ctx[14]),
					listen(input, "focus", /*onFocus*/ ctx[16]),
					listen(input, "blur", /*onBlur*/ ctx[17])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (before_inner_slot) {
				if (before_inner_slot.p && (!current || dirty[0] & /*f7Searchbar*/ 4096 | dirty[1] & /*$$scope*/ 2097152)) {
					update_slot_base(
						before_inner_slot,
						before_inner_slot_template,
						ctx,
						/*$$scope*/ ctx[52],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[52])
						: get_slot_changes(before_inner_slot_template, /*$$scope*/ ctx[52], dirty, get_before_inner_slot_changes_1),
						get_before_inner_slot_context_1
					);
				}
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && (!current || dirty[0] & /*f7Searchbar*/ 4096 | dirty[1] & /*$$scope*/ 2097152)) {
					update_slot_base(
						inner_start_slot,
						inner_start_slot_template,
						ctx,
						/*$$scope*/ ctx[52],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[52])
						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[52], dirty, get_inner_start_slot_changes_1),
						get_inner_start_slot_context_1
					);
				}
			}

			if (input_wrap_start_slot) {
				if (input_wrap_start_slot.p && (!current || dirty[0] & /*f7Searchbar*/ 4096 | dirty[1] & /*$$scope*/ 2097152)) {
					update_slot_base(
						input_wrap_start_slot,
						input_wrap_start_slot_template,
						ctx,
						/*$$scope*/ ctx[52],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[52])
						: get_slot_changes(input_wrap_start_slot_template, /*$$scope*/ ctx[52], dirty, get_input_wrap_start_slot_changes_1),
						get_input_wrap_start_slot_context_1
					);
				}
			}

			if (!current || dirty[0] & /*value*/ 1 && input_value_value !== (input_value_value = typeof /*value*/ ctx[0] === 'undefined'
			? ''
			: /*value*/ ctx[0]) && input.value !== input_value_value) {
				input.value = input_value_value;
			}

			if (!current || dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (!current || dirty[0] & /*autocomplete*/ 8) {
				attr(input, "autocomplete", /*autocomplete*/ ctx[3]);
			}

			if (!current || dirty[0] & /*autocorrect*/ 16) {
				attr(input, "autocorrect", /*autocorrect*/ ctx[4]);
			}

			if (!current || dirty[0] & /*autocapitalize*/ 32) {
				attr(input, "autocapitalize", /*autocapitalize*/ ctx[5]);
			}

			if (!current || dirty[0] & /*spellcheck*/ 64) {
				attr(input, "spellcheck", /*spellcheck*/ ctx[6]);
			}

			if (/*clearButton*/ ctx[9]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4$1(ctx);
					if_block0.c();
					if_block0.m(div0, t5);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (input_wrap_end_slot) {
				if (input_wrap_end_slot.p && (!current || dirty[0] & /*f7Searchbar*/ 4096 | dirty[1] & /*$$scope*/ 2097152)) {
					update_slot_base(
						input_wrap_end_slot,
						input_wrap_end_slot_template,
						ctx,
						/*$$scope*/ ctx[52],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[52])
						: get_slot_changes(input_wrap_end_slot_template, /*$$scope*/ ctx[52], dirty, get_input_wrap_end_slot_changes_1),
						get_input_wrap_end_slot_context_1
					);
				}
			}

			if (/*disableButton*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3$2(ctx);
					if_block1.c();
					if_block1.m(div1, t7);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && (!current || dirty[0] & /*f7Searchbar*/ 4096 | dirty[1] & /*$$scope*/ 2097152)) {
					update_slot_base(
						inner_end_slot,
						inner_end_slot_template,
						ctx,
						/*$$scope*/ ctx[52],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[52])
						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[52], dirty, get_inner_end_slot_changes_1),
						get_inner_end_slot_context_1
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*f7Searchbar*/ 4096 | dirty[1] & /*$$scope*/ 2097152)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[52],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[52])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[52], dirty, get_default_slot_changes_1),
						get_default_slot_context_1
					);
				}
			}

			if (after_inner_slot) {
				if (after_inner_slot.p && (!current || dirty[0] & /*f7Searchbar*/ 4096 | dirty[1] & /*$$scope*/ 2097152)) {
					update_slot_base(
						after_inner_slot,
						after_inner_slot_template,
						ctx,
						/*$$scope*/ ctx[52],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[52])
						: get_slot_changes(after_inner_slot_template, /*$$scope*/ ctx[52], dirty, get_after_inner_slot_changes_1),
						get_after_inner_slot_context_1
					);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty[0] & /*classes*/ 8192) && { class: /*classes*/ ctx[13] },
				(!current || dirty[0] & /*f7Slot*/ 1024) && { "data-f7-slot": /*f7Slot*/ ctx[10] },
				dirty[0] & /*$$restProps*/ 2097152 && restProps(/*$$restProps*/ ctx[21])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(before_inner_slot, local);
			transition_in(inner_start_slot, local);
			transition_in(input_wrap_start_slot, local);
			transition_in(input_wrap_end_slot, local);
			transition_in(inner_end_slot, local);
			transition_in(default_slot, local);
			transition_in(after_inner_slot, local);
			current = true;
		},
		o(local) {
			transition_out(before_inner_slot, local);
			transition_out(inner_start_slot, local);
			transition_out(input_wrap_start_slot, local);
			transition_out(input_wrap_end_slot, local);
			transition_out(inner_end_slot, local);
			transition_out(default_slot, local);
			transition_out(after_inner_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			if (before_inner_slot) before_inner_slot.d(detaching);
			if (inner_start_slot) inner_start_slot.d(detaching);
			if (input_wrap_start_slot) input_wrap_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (input_wrap_end_slot) input_wrap_end_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (after_inner_slot) after_inner_slot.d(detaching);
			/*div2_binding*/ ctx[55](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (181:0) {#if form}
function create_if_block$a(ctx) {
	let form_1;
	let t0;
	let div1;
	let t1;
	let div0;
	let t2;
	let input;
	let input_value_value;
	let t3;
	let i;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let t9;
	let current;
	let mounted;
	let dispose;
	const before_inner_slot_template = /*#slots*/ ctx[53]["before-inner"];
	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[52], get_before_inner_slot_context$1);
	const inner_start_slot_template = /*#slots*/ ctx[53]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[52], get_inner_start_slot_context);
	const input_wrap_start_slot_template = /*#slots*/ ctx[53]["input-wrap-start"];
	const input_wrap_start_slot = create_slot(input_wrap_start_slot_template, ctx, /*$$scope*/ ctx[52], get_input_wrap_start_slot_context);
	let if_block0 = /*clearButton*/ ctx[9] && create_if_block_2$2(ctx);
	const input_wrap_end_slot_template = /*#slots*/ ctx[53]["input-wrap-end"];
	const input_wrap_end_slot = create_slot(input_wrap_end_slot_template, ctx, /*$$scope*/ ctx[52], get_input_wrap_end_slot_context);
	let if_block1 = /*disableButton*/ ctx[7] && create_if_block_1$5(ctx);
	const inner_end_slot_template = /*#slots*/ ctx[53]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[52], get_inner_end_slot_context);
	const default_slot_template = /*#slots*/ ctx[53].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[52], get_default_slot_context);
	const after_inner_slot_template = /*#slots*/ ctx[53]["after-inner"];
	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[52], get_after_inner_slot_context$1);

	let form_1_levels = [
		{ class: /*classes*/ ctx[13] },
		{ "data-f7-slot": /*f7Slot*/ ctx[10] },
		restProps(/*$$restProps*/ ctx[21])
	];

	let form_1_data = {};

	for (let i = 0; i < form_1_levels.length; i += 1) {
		form_1_data = assign(form_1_data, form_1_levels[i]);
	}

	return {
		c() {
			form_1 = element("form");
			if (before_inner_slot) before_inner_slot.c();
			t0 = space();
			div1 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t1 = space();
			div0 = element("div");
			if (input_wrap_start_slot) input_wrap_start_slot.c();
			t2 = space();
			input = element("input");
			t3 = space();
			i = element("i");
			t4 = space();
			if (if_block0) if_block0.c();
			t5 = space();
			if (input_wrap_end_slot) input_wrap_end_slot.c();
			t6 = space();
			if (if_block1) if_block1.c();
			t7 = space();
			if (inner_end_slot) inner_end_slot.c();
			t8 = space();
			if (default_slot) default_slot.c();
			t9 = space();
			if (after_inner_slot) after_inner_slot.c();
			this.h();
		},
		l(nodes) {
			form_1 = claim_element(nodes, "FORM", { class: true, "data-f7-slot": true });
			var form_1_nodes = children(form_1);
			if (before_inner_slot) before_inner_slot.l(form_1_nodes);
			t0 = claim_space(form_1_nodes);
			div1 = claim_element(form_1_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (inner_start_slot) inner_start_slot.l(div1_nodes);
			t1 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (input_wrap_start_slot) input_wrap_start_slot.l(div0_nodes);
			t2 = claim_space(div0_nodes);

			input = claim_element(div0_nodes, "INPUT", {
				placeholder: true,
				autocomplete: true,
				autocorrect: true,
				autocapitalize: true,
				spellcheck: true,
				type: true
			});

			t3 = claim_space(div0_nodes);
			i = claim_element(div0_nodes, "I", { class: true });
			children(i).forEach(detach);
			t4 = claim_space(div0_nodes);
			if (if_block0) if_block0.l(div0_nodes);
			t5 = claim_space(div0_nodes);
			if (input_wrap_end_slot) input_wrap_end_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			t6 = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			t7 = claim_space(div1_nodes);
			if (inner_end_slot) inner_end_slot.l(div1_nodes);
			t8 = claim_space(div1_nodes);
			if (default_slot) default_slot.l(div1_nodes);
			div1_nodes.forEach(detach);
			t9 = claim_space(form_1_nodes);
			if (after_inner_slot) after_inner_slot.l(form_1_nodes);
			form_1_nodes.forEach(detach);
			this.h();
		},
		h() {
			input.value = input_value_value = typeof /*value*/ ctx[0] === 'undefined'
			? ''
			: /*value*/ ctx[0];

			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			attr(input, "autocomplete", /*autocomplete*/ ctx[3]);
			attr(input, "autocorrect", /*autocorrect*/ ctx[4]);
			attr(input, "autocapitalize", /*autocapitalize*/ ctx[5]);
			attr(input, "spellcheck", /*spellcheck*/ ctx[6]);
			attr(input, "type", "search");
			attr(i, "class", "searchbar-icon");
			attr(div0, "class", "searchbar-input-wrap");
			attr(div1, "class", "searchbar-inner");
			set_attributes(form_1, form_1_data);
		},
		m(target, anchor) {
			insert_hydration(target, form_1, anchor);

			if (before_inner_slot) {
				before_inner_slot.m(form_1, null);
			}

			append_hydration(form_1, t0);
			append_hydration(form_1, div1);

			if (inner_start_slot) {
				inner_start_slot.m(div1, null);
			}

			append_hydration(div1, t1);
			append_hydration(div1, div0);

			if (input_wrap_start_slot) {
				input_wrap_start_slot.m(div0, null);
			}

			append_hydration(div0, t2);
			append_hydration(div0, input);
			append_hydration(div0, t3);
			append_hydration(div0, i);
			append_hydration(div0, t4);
			if (if_block0) if_block0.m(div0, null);
			append_hydration(div0, t5);

			if (input_wrap_end_slot) {
				input_wrap_end_slot.m(div0, null);
			}

			append_hydration(div1, t6);
			if (if_block1) if_block1.m(div1, null);
			append_hydration(div1, t7);

			if (inner_end_slot) {
				inner_end_slot.m(div1, null);
			}

			append_hydration(div1, t8);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_hydration(form_1, t9);

			if (after_inner_slot) {
				after_inner_slot.m(form_1, null);
			}

			/*form_1_binding*/ ctx[54](form_1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "input", /*onInput*/ ctx[15]),
					listen(input, "change", /*onChange*/ ctx[14]),
					listen(input, "focus", /*onFocus*/ ctx[16]),
					listen(input, "blur", /*onBlur*/ ctx[17]),
					listen(form_1, "submit", /*onSubmit*/ ctx[18])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (before_inner_slot) {
				if (before_inner_slot.p && (!current || dirty[0] & /*f7Searchbar*/ 4096 | dirty[1] & /*$$scope*/ 2097152)) {
					update_slot_base(
						before_inner_slot,
						before_inner_slot_template,
						ctx,
						/*$$scope*/ ctx[52],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[52])
						: get_slot_changes(before_inner_slot_template, /*$$scope*/ ctx[52], dirty, get_before_inner_slot_changes$1),
						get_before_inner_slot_context$1
					);
				}
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && (!current || dirty[0] & /*f7Searchbar*/ 4096 | dirty[1] & /*$$scope*/ 2097152)) {
					update_slot_base(
						inner_start_slot,
						inner_start_slot_template,
						ctx,
						/*$$scope*/ ctx[52],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[52])
						: get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[52], dirty, get_inner_start_slot_changes),
						get_inner_start_slot_context
					);
				}
			}

			if (input_wrap_start_slot) {
				if (input_wrap_start_slot.p && (!current || dirty[0] & /*f7Searchbar*/ 4096 | dirty[1] & /*$$scope*/ 2097152)) {
					update_slot_base(
						input_wrap_start_slot,
						input_wrap_start_slot_template,
						ctx,
						/*$$scope*/ ctx[52],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[52])
						: get_slot_changes(input_wrap_start_slot_template, /*$$scope*/ ctx[52], dirty, get_input_wrap_start_slot_changes),
						get_input_wrap_start_slot_context
					);
				}
			}

			if (!current || dirty[0] & /*value*/ 1 && input_value_value !== (input_value_value = typeof /*value*/ ctx[0] === 'undefined'
			? ''
			: /*value*/ ctx[0]) && input.value !== input_value_value) {
				input.value = input_value_value;
			}

			if (!current || dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (!current || dirty[0] & /*autocomplete*/ 8) {
				attr(input, "autocomplete", /*autocomplete*/ ctx[3]);
			}

			if (!current || dirty[0] & /*autocorrect*/ 16) {
				attr(input, "autocorrect", /*autocorrect*/ ctx[4]);
			}

			if (!current || dirty[0] & /*autocapitalize*/ 32) {
				attr(input, "autocapitalize", /*autocapitalize*/ ctx[5]);
			}

			if (!current || dirty[0] & /*spellcheck*/ 64) {
				attr(input, "spellcheck", /*spellcheck*/ ctx[6]);
			}

			if (/*clearButton*/ ctx[9]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$2(ctx);
					if_block0.c();
					if_block0.m(div0, t5);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (input_wrap_end_slot) {
				if (input_wrap_end_slot.p && (!current || dirty[0] & /*f7Searchbar*/ 4096 | dirty[1] & /*$$scope*/ 2097152)) {
					update_slot_base(
						input_wrap_end_slot,
						input_wrap_end_slot_template,
						ctx,
						/*$$scope*/ ctx[52],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[52])
						: get_slot_changes(input_wrap_end_slot_template, /*$$scope*/ ctx[52], dirty, get_input_wrap_end_slot_changes),
						get_input_wrap_end_slot_context
					);
				}
			}

			if (/*disableButton*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1$5(ctx);
					if_block1.c();
					if_block1.m(div1, t7);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && (!current || dirty[0] & /*f7Searchbar*/ 4096 | dirty[1] & /*$$scope*/ 2097152)) {
					update_slot_base(
						inner_end_slot,
						inner_end_slot_template,
						ctx,
						/*$$scope*/ ctx[52],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[52])
						: get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[52], dirty, get_inner_end_slot_changes),
						get_inner_end_slot_context
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*f7Searchbar*/ 4096 | dirty[1] & /*$$scope*/ 2097152)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[52],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[52])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[52], dirty, get_default_slot_changes),
						get_default_slot_context
					);
				}
			}

			if (after_inner_slot) {
				if (after_inner_slot.p && (!current || dirty[0] & /*f7Searchbar*/ 4096 | dirty[1] & /*$$scope*/ 2097152)) {
					update_slot_base(
						after_inner_slot,
						after_inner_slot_template,
						ctx,
						/*$$scope*/ ctx[52],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[52])
						: get_slot_changes(after_inner_slot_template, /*$$scope*/ ctx[52], dirty, get_after_inner_slot_changes$1),
						get_after_inner_slot_context$1
					);
				}
			}

			set_attributes(form_1, form_1_data = get_spread_update(form_1_levels, [
				(!current || dirty[0] & /*classes*/ 8192) && { class: /*classes*/ ctx[13] },
				(!current || dirty[0] & /*f7Slot*/ 1024) && { "data-f7-slot": /*f7Slot*/ ctx[10] },
				dirty[0] & /*$$restProps*/ 2097152 && restProps(/*$$restProps*/ ctx[21])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(before_inner_slot, local);
			transition_in(inner_start_slot, local);
			transition_in(input_wrap_start_slot, local);
			transition_in(input_wrap_end_slot, local);
			transition_in(inner_end_slot, local);
			transition_in(default_slot, local);
			transition_in(after_inner_slot, local);
			current = true;
		},
		o(local) {
			transition_out(before_inner_slot, local);
			transition_out(inner_start_slot, local);
			transition_out(input_wrap_start_slot, local);
			transition_out(input_wrap_end_slot, local);
			transition_out(inner_end_slot, local);
			transition_out(default_slot, local);
			transition_out(after_inner_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(form_1);
			if (before_inner_slot) before_inner_slot.d(detaching);
			if (inner_start_slot) inner_start_slot.d(detaching);
			if (input_wrap_start_slot) input_wrap_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (input_wrap_end_slot) input_wrap_end_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (after_inner_slot) after_inner_slot.d(detaching);
			/*form_1_binding*/ ctx[54](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (242:8) {#if clearButton}
function create_if_block_4$1(ctx) {
	let span;
	let mounted;
	let dispose;

	return {
		c() {
			span = element("span");
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "input-clear-button");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);

			if (!mounted) {
				dispose = listen(span, "click", /*onClearButtonClick*/ ctx[19]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
			mounted = false;
			dispose();
		}
	};
}

// (245:6) {#if disableButton}
function create_if_block_3$2(ctx) {
	let span;
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			span = element("span");
			t = text(/*disableButtonText*/ ctx[8]);
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*disableButtonText*/ ctx[8]);
			span_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "searchbar-disable-button");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);

			if (!mounted) {
				dispose = listen(span, "click", /*onDisableButtonClick*/ ctx[20]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*disableButtonText*/ 256) set_data(t, /*disableButtonText*/ ctx[8]);
		},
		d(detaching) {
			if (detaching) detach(span);
			mounted = false;
			dispose();
		}
	};
}

// (208:8) {#if clearButton}
function create_if_block_2$2(ctx) {
	let span;
	let mounted;
	let dispose;

	return {
		c() {
			span = element("span");
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "input-clear-button");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);

			if (!mounted) {
				dispose = listen(span, "click", /*onClearButtonClick*/ ctx[19]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
			mounted = false;
			dispose();
		}
	};
}

// (211:6) {#if disableButton}
function create_if_block_1$5(ctx) {
	let span;
	let t;
	let mounted;
	let dispose;

	return {
		c() {
			span = element("span");
			t = text(/*disableButtonText*/ ctx[8]);
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*disableButtonText*/ ctx[8]);
			span_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "searchbar-disable-button");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);

			if (!mounted) {
				dispose = listen(span, "click", /*onDisableButtonClick*/ ctx[20]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*disableButtonText*/ 256) set_data(t, /*disableButtonText*/ ctx[8]);
		},
		d(detaching) {
			if (detaching) detach(span);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$i(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$a, create_else_block$5];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*form*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

let index$j = 0;

function instance_1$1($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"lec","class","noShadow","noHairline","form","placeholder","autocomplete","autocorrect","autocapitalize","spellcheck","disableButton","disableButtonText","clearButton","value","inputEvents","expandable","inline","searchContainer","searchIn","searchItem","searchGroup","searchGroupTitle","foundEl","notFoundEl","backdrop","backdropEl","hideOnEnableEl","hideOnSearchEl","ignore","customSearch","removeDiacritics","hideDividers","hideGroups","init","f7Slot","instance","search","enable","disable","toggle","clear"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { noShadow = false } = $$props;
	let { noHairline = false } = $$props;
	let { form = true } = $$props;
	let { placeholder = 'Search' } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { disableButton = true } = $$props;
	let { disableButtonText = 'Cancel' } = $$props;
	let { clearButton = true } = $$props;
	let { value = undefined } = $$props;
	let { inputEvents = 'change input compositionend' } = $$props;
	let { expandable = false } = $$props;
	let { inline = false } = $$props;
	let { searchContainer = undefined } = $$props;
	let { searchIn = '.item-title' } = $$props;
	let { searchItem = 'li' } = $$props;
	let { searchGroup = '.list-group' } = $$props;
	let { searchGroupTitle = '.item-divider, .list-group-title' } = $$props;
	let { foundEl = '.searchbar-found' } = $$props;
	let { notFoundEl = '.searchbar-not-found' } = $$props;
	let { backdrop = undefined } = $$props;
	let { backdropEl = undefined } = $$props;
	let { hideOnEnableEl = '.searchbar-hide-on-enable' } = $$props;
	let { hideOnSearchEl = '.searchbar-hide-on-search' } = $$props;
	let { ignore = '.searchbar-ignore' } = $$props;
	let { customSearch = false } = $$props;
	let { removeDiacritics = false } = $$props;
	let { hideDividers = true } = $$props;
	let { hideGroups = true } = $$props;
	let { init = true } = $$props;
	let { f7Slot = 'fixed' } = $$props;
	let el;
	let f7Searchbar;

	function instance() {
		return f7Searchbar;
	}

	function search(query) {
		if (!f7Searchbar) return undefined;
		return f7Searchbar.search(query);
	}

	function enable() {
		if (!f7Searchbar) return undefined;
		return f7Searchbar.enable();
	}

	function disable() {
		if (!f7Searchbar) return undefined;
		return f7Searchbar.disable();
	}

	function toggle() {
		if (!f7Searchbar) return undefined;
		return f7Searchbar.toggle();
	}

	function clear() {
		if (!f7Searchbar) return undefined;
		return f7Searchbar.clear();
	}

	function onChange(event) {
		emit('change', [event]);
	}

	function onInput(event) {
		emit('input', [event]);
		$$invalidate(0, value = event.target.value);
	}

	function onFocus(event) {
		emit('focus', [event]);
	}

	function onBlur(event) {
		emit('blur', [event]);
	}

	function onSubmit(event) {
		emit('submit', [event]);
	}

	function onClearButtonClick(event) {
		emit('click:clear', [event]);
	}

	function onDisableButtonClick(event) {
		emit('click:disable', [event]);
	}

	onMount(() => {
		if (!init) return;

		f7ready(() => {
			const params = noUndefinedProps({
				el,
				inputEvents,
				searchContainer,
				searchIn,
				searchItem,
				searchGroup,
				searchGroupTitle,
				hideOnEnableEl,
				hideOnSearchEl,
				foundEl,
				notFoundEl,
				backdrop,
				backdropEl,
				disableButton,
				ignore,
				customSearch,
				removeDiacritics,
				hideDividers,
				hideGroups,
				expandable,
				inline,
				on: {
					search(searchbar, query, previousQuery) {
						emit('searchbarSearch', [searchbar, query, previousQuery]);
					},
					clear(searchbar, previousQuery) {
						emit('searchbarClear', [searchbar, previousQuery]);
					},
					enable(searchbar) {
						emit('searchbarEnable', [searchbar]);
					},
					disable(searchbar) {
						emit('searchbarDisable', [searchbar]);
					}
				}
			});

			Object.keys(params).forEach(key => {
				if (params[key] === '') {
					delete params[key];
				}
			});

			$$invalidate(12, f7Searchbar = app.f7.searchbar.create(params));
		});
	});

	onDestroy(() => {
		if (f7Searchbar && f7Searchbar.destroy) {
			f7Searchbar.destroy();
			$$invalidate(12, f7Searchbar = null);
		}
	});

	function form_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(11, el);
		});
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(11, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(58, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(21, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(22, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(23, className = $$new_props.class);
		if ('noShadow' in $$new_props) $$invalidate(24, noShadow = $$new_props.noShadow);
		if ('noHairline' in $$new_props) $$invalidate(25, noHairline = $$new_props.noHairline);
		if ('form' in $$new_props) $$invalidate(1, form = $$new_props.form);
		if ('placeholder' in $$new_props) $$invalidate(2, placeholder = $$new_props.placeholder);
		if ('autocomplete' in $$new_props) $$invalidate(3, autocomplete = $$new_props.autocomplete);
		if ('autocorrect' in $$new_props) $$invalidate(4, autocorrect = $$new_props.autocorrect);
		if ('autocapitalize' in $$new_props) $$invalidate(5, autocapitalize = $$new_props.autocapitalize);
		if ('spellcheck' in $$new_props) $$invalidate(6, spellcheck = $$new_props.spellcheck);
		if ('disableButton' in $$new_props) $$invalidate(7, disableButton = $$new_props.disableButton);
		if ('disableButtonText' in $$new_props) $$invalidate(8, disableButtonText = $$new_props.disableButtonText);
		if ('clearButton' in $$new_props) $$invalidate(9, clearButton = $$new_props.clearButton);
		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ('inputEvents' in $$new_props) $$invalidate(26, inputEvents = $$new_props.inputEvents);
		if ('expandable' in $$new_props) $$invalidate(27, expandable = $$new_props.expandable);
		if ('inline' in $$new_props) $$invalidate(28, inline = $$new_props.inline);
		if ('searchContainer' in $$new_props) $$invalidate(29, searchContainer = $$new_props.searchContainer);
		if ('searchIn' in $$new_props) $$invalidate(30, searchIn = $$new_props.searchIn);
		if ('searchItem' in $$new_props) $$invalidate(31, searchItem = $$new_props.searchItem);
		if ('searchGroup' in $$new_props) $$invalidate(32, searchGroup = $$new_props.searchGroup);
		if ('searchGroupTitle' in $$new_props) $$invalidate(33, searchGroupTitle = $$new_props.searchGroupTitle);
		if ('foundEl' in $$new_props) $$invalidate(34, foundEl = $$new_props.foundEl);
		if ('notFoundEl' in $$new_props) $$invalidate(35, notFoundEl = $$new_props.notFoundEl);
		if ('backdrop' in $$new_props) $$invalidate(36, backdrop = $$new_props.backdrop);
		if ('backdropEl' in $$new_props) $$invalidate(37, backdropEl = $$new_props.backdropEl);
		if ('hideOnEnableEl' in $$new_props) $$invalidate(38, hideOnEnableEl = $$new_props.hideOnEnableEl);
		if ('hideOnSearchEl' in $$new_props) $$invalidate(39, hideOnSearchEl = $$new_props.hideOnSearchEl);
		if ('ignore' in $$new_props) $$invalidate(40, ignore = $$new_props.ignore);
		if ('customSearch' in $$new_props) $$invalidate(41, customSearch = $$new_props.customSearch);
		if ('removeDiacritics' in $$new_props) $$invalidate(42, removeDiacritics = $$new_props.removeDiacritics);
		if ('hideDividers' in $$new_props) $$invalidate(43, hideDividers = $$new_props.hideDividers);
		if ('hideGroups' in $$new_props) $$invalidate(44, hideGroups = $$new_props.hideGroups);
		if ('init' in $$new_props) $$invalidate(45, init = $$new_props.init);
		if ('f7Slot' in $$new_props) $$invalidate(10, f7Slot = $$new_props.f7Slot);
		if ('$$scope' in $$new_props) $$invalidate(52, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(13, classes = classNames(
			className,
			'searchbar',
			{
				'searchbar-inline': inline,
				'no-shadow': noShadow,
				'no-hairline': noHairline,
				'searchbar-expandable': expandable
			},
			colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		value,
		form,
		placeholder,
		autocomplete,
		autocorrect,
		autocapitalize,
		spellcheck,
		disableButton,
		disableButtonText,
		clearButton,
		f7Slot,
		el,
		f7Searchbar,
		classes,
		onChange,
		onInput,
		onFocus,
		onBlur,
		onSubmit,
		onClearButtonClick,
		onDisableButtonClick,
		$$restProps,
		lec,
		className,
		noShadow,
		noHairline,
		inputEvents,
		expandable,
		inline,
		searchContainer,
		searchIn,
		searchItem,
		searchGroup,
		searchGroupTitle,
		foundEl,
		notFoundEl,
		backdrop,
		backdropEl,
		hideOnEnableEl,
		hideOnSearchEl,
		ignore,
		customSearch,
		removeDiacritics,
		hideDividers,
		hideGroups,
		init,
		instance,
		search,
		enable,
		disable,
		toggle,
		clear,
		$$scope,
		slots,
		form_1_binding,
		div2_binding
	];
}

class Searchbar extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance_1$1,
			create_fragment$i,
			safe_not_equal,
			{
				lec: 22,
				class: 23,
				noShadow: 24,
				noHairline: 25,
				form: 1,
				placeholder: 2,
				autocomplete: 3,
				autocorrect: 4,
				autocapitalize: 5,
				spellcheck: 6,
				disableButton: 7,
				disableButtonText: 8,
				clearButton: 9,
				value: 0,
				inputEvents: 26,
				expandable: 27,
				inline: 28,
				searchContainer: 29,
				searchIn: 30,
				searchItem: 31,
				searchGroup: 32,
				searchGroupTitle: 33,
				foundEl: 34,
				notFoundEl: 35,
				backdrop: 36,
				backdropEl: 37,
				hideOnEnableEl: 38,
				hideOnSearchEl: 39,
				ignore: 40,
				customSearch: 41,
				removeDiacritics: 42,
				hideDividers: 43,
				hideGroups: 44,
				init: 45,
				f7Slot: 10,
				instance: 46,
				search: 47,
				enable: 48,
				disable: 49,
				toggle: 50,
				clear: 51
			},
			null,
			[-1, -1]
		);
	}

	get instance() {
		return this.$$.ctx[46];
	}

	get search() {
		return this.$$.ctx[47];
	}

	get enable() {
		return this.$$.ctx[48];
	}

	get disable() {
		return this.$$.ctx[49];
	}

	get toggle() {
		return this.$$.ctx[50];
	}

	get clear() {
		return this.$$.ctx[51];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/segmented.liquivelte generated by Svelte v3.50.0 */

function create_if_block_2$1(ctx) {
	let p;
	let t;
	let current;
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);
	let if_block = (/*strong*/ ctx[0] || /*strongIos*/ ctx[1] || /*strongMd*/ ctx[2] || /*strongAurora*/ ctx[3]) && create_if_block_3$1(ctx);
	let p_levels = [{ class: /*classes*/ ctx[5] }, restProps(/*$$restProps*/ ctx[6])];
	let p_data = {};

	for (let i = 0; i < p_levels.length; i += 1) {
		p_data = assign(p_data, p_levels[i]);
	}

	return {
		c() {
			p = element("p");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			if (default_slot) default_slot.l(p_nodes);
			t = claim_space(p_nodes);
			if (if_block) if_block.l(p_nodes);
			p_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(p, p_data);
		},
		m(target, anchor) {
			insert_hydration(target, p, anchor);

			if (default_slot) {
				default_slot.m(p, null);
			}

			append_hydration(p, t);
			if (if_block) if_block.m(p, null);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[17],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
						null
					);
				}
			}

			if (/*strong*/ ctx[0] || /*strongIos*/ ctx[1] || /*strongMd*/ ctx[2] || /*strongAurora*/ ctx[3]) {
				if (if_block) {
					
				} else {
					if_block = create_if_block_3$1(ctx);
					if_block.c();
					if_block.m(p, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			set_attributes(p, p_data = get_spread_update(p_levels, [
				(!current || dirty & /*classes*/ 32) && { class: /*classes*/ ctx[5] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(p);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
		}
	};
}

// (49:0) {#if tag === 'div'}
function create_if_block$9(ctx) {
	let div;
	let t;
	let current;
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);
	let if_block = (/*strong*/ ctx[0] || /*strongIos*/ ctx[1] || /*strongMd*/ ctx[2] || /*strongAurora*/ ctx[3]) && create_if_block_1$4(ctx);
	let div_levels = [{ class: /*classes*/ ctx[5] }, restProps(/*$$restProps*/ ctx[6])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			t = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_hydration(div, t);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[17],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
						null
					);
				}
			}

			if (/*strong*/ ctx[0] || /*strongIos*/ ctx[1] || /*strongMd*/ ctx[2] || /*strongAurora*/ ctx[3]) {
				if (if_block) {
					
				} else {
					if_block = create_if_block_1$4(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 32) && { class: /*classes*/ ctx[5] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
		}
	};
}

// (57:4) {#if strong || strongIos || strongMd || strongAurora}
function create_if_block_3$1(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "segmented-highlight");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (52:4) {#if strong || strongIos || strongMd || strongAurora}
function create_if_block_1$4(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			children(span).forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "segmented-highlight");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

function create_fragment$h(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$9, create_if_block_2$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tag*/ ctx[4] === 'div') return 0;
		if (/*tag*/ ctx[4] === 'p') return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, -1))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

let index$i = 0;

function instance$g($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"lec","class","raised","raisedIos","raisedMd","raisedAurora","round","roundIos","roundMd","roundAurora","strong","strongIos","strongMd","strongAurora","tag"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let { raised = false } = $$props;
	let { raisedIos = false } = $$props;
	let { raisedMd = false } = $$props;
	let { raisedAurora = false } = $$props;
	let { round = false } = $$props;
	let { roundIos = false } = $$props;
	let { roundMd = false } = $$props;
	let { roundAurora = false } = $$props;
	let { strong = false } = $$props;
	let { strongIos = false } = $$props;
	let { strongMd = false } = $$props;
	let { strongAurora = false } = $$props;
	let { tag = 'div' } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(20, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(7, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ('raised' in $$new_props) $$invalidate(9, raised = $$new_props.raised);
		if ('raisedIos' in $$new_props) $$invalidate(10, raisedIos = $$new_props.raisedIos);
		if ('raisedMd' in $$new_props) $$invalidate(11, raisedMd = $$new_props.raisedMd);
		if ('raisedAurora' in $$new_props) $$invalidate(12, raisedAurora = $$new_props.raisedAurora);
		if ('round' in $$new_props) $$invalidate(13, round = $$new_props.round);
		if ('roundIos' in $$new_props) $$invalidate(14, roundIos = $$new_props.roundIos);
		if ('roundMd' in $$new_props) $$invalidate(15, roundMd = $$new_props.roundMd);
		if ('roundAurora' in $$new_props) $$invalidate(16, roundAurora = $$new_props.roundAurora);
		if ('strong' in $$new_props) $$invalidate(0, strong = $$new_props.strong);
		if ('strongIos' in $$new_props) $$invalidate(1, strongIos = $$new_props.strongIos);
		if ('strongMd' in $$new_props) $$invalidate(2, strongMd = $$new_props.strongMd);
		if ('strongAurora' in $$new_props) $$invalidate(3, strongAurora = $$new_props.strongAurora);
		if ('tag' in $$new_props) $$invalidate(4, tag = $$new_props.tag);
		if ('$$scope' in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(5, classes = classNames(
			className,
			{
				segmented: true,
				'segmented-raised': raised,
				'segmented-raised-ios': raisedIos,
				'segmented-raised-aurora': raisedAurora,
				'segmented-raised-md': raisedMd,
				'segmented-round': round,
				'segmented-round-ios': roundIos,
				'segmented-round-aurora': roundAurora,
				'segmented-round-md': roundMd,
				'segmented-strong': strong,
				'segmented-strong-ios': strongIos,
				'segmented-strong-md': strongMd,
				'segmented-strong-aurora': strongAurora
			},
			colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		strong,
		strongIos,
		strongMd,
		strongAurora,
		tag,
		classes,
		$$restProps,
		lec,
		className,
		raised,
		raisedIos,
		raisedMd,
		raisedAurora,
		round,
		roundIos,
		roundMd,
		roundAurora,
		$$scope,
		slots
	];
}

class Segmented extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$g, create_fragment$h, safe_not_equal, {
			lec: 7,
			class: 8,
			raised: 9,
			raisedIos: 10,
			raisedMd: 11,
			raisedAurora: 12,
			round: 13,
			roundIos: 14,
			roundMd: 15,
			roundAurora: 16,
			strong: 0,
			strongIos: 1,
			strongMd: 2,
			strongAurora: 3,
			tag: 4
		});
	}
}

// eslint-disable-next-line

// eslint-disable-next-line

// eslint-disable-next-line

// eslint-disable-next-line

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/stepper.liquivelte generated by Svelte v3.50.0 */

function create_if_block_1$3(ctx) {
	let div;
	let input_1;
	let input_1_min_value;
	let input_1_max_value;
	let input_1_step_value;
	let input_1_value_value;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			input_1 = element("input");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			input_1 = claim_element(div_nodes, "INPUT", {
				name: true,
				id: true,
				type: true,
				min: true,
				max: true,
				step: true
			});

			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(input_1, "name", /*name*/ ctx[4]);
			attr(input_1, "id", /*inputId*/ ctx[5]);
			attr(input_1, "type", /*inputType*/ ctx[7]);

			attr(input_1, "min", input_1_min_value = /*inputType*/ ctx[7] === 'number'
			? /*min*/ ctx[1]
			: undefined);

			attr(input_1, "max", input_1_max_value = /*inputType*/ ctx[7] === 'number'
			? /*max*/ ctx[2]
			: undefined);

			attr(input_1, "step", input_1_step_value = /*inputType*/ ctx[7] === 'number'
			? /*step*/ ctx[3]
			: undefined);

			input_1.value = input_1_value_value = typeof /*value*/ ctx[0] === 'undefined'
			? ''
			: /*value*/ ctx[0];

			input_1.readOnly = /*inputReadonly*/ ctx[8];
			attr(div, "class", "stepper-input-wrap");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, input_1);

			if (!mounted) {
				dispose = [
					listen(input_1, "input", /*onInput*/ ctx[12]),
					listen(input_1, "change", /*onChange*/ ctx[13])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*name*/ 16) {
				attr(input_1, "name", /*name*/ ctx[4]);
			}

			if (dirty[0] & /*inputId*/ 32) {
				attr(input_1, "id", /*inputId*/ ctx[5]);
			}

			if (dirty[0] & /*inputType*/ 128) {
				attr(input_1, "type", /*inputType*/ ctx[7]);
			}

			if (dirty[0] & /*inputType, min*/ 130 && input_1_min_value !== (input_1_min_value = /*inputType*/ ctx[7] === 'number'
			? /*min*/ ctx[1]
			: undefined)) {
				attr(input_1, "min", input_1_min_value);
			}

			if (dirty[0] & /*inputType, max*/ 132 && input_1_max_value !== (input_1_max_value = /*inputType*/ ctx[7] === 'number'
			? /*max*/ ctx[2]
			: undefined)) {
				attr(input_1, "max", input_1_max_value);
			}

			if (dirty[0] & /*inputType, step*/ 136 && input_1_step_value !== (input_1_step_value = /*inputType*/ ctx[7] === 'number'
			? /*step*/ ctx[3]
			: undefined)) {
				attr(input_1, "step", input_1_step_value);
			}

			if (dirty[0] & /*value*/ 1 && input_1_value_value !== (input_1_value_value = typeof /*value*/ ctx[0] === 'undefined'
			? ''
			: /*value*/ ctx[0]) && input_1.value !== input_1_value_value) {
				input_1.value = input_1_value_value;
			}

			if (dirty[0] & /*inputReadonly*/ 256) {
				input_1.readOnly = /*inputReadonly*/ ctx[8];
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (172:2) {#if !input && !buttonsOnly}
function create_if_block$8(ctx) {
	let div;
	let t_value = plainText(/*value*/ ctx[0]) + "";
	let t;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "stepper-value");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*value*/ 1 && t_value !== (t_value = plainText(/*value*/ ctx[0]) + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$g(ctx) {
	let div2;
	let div0;
	let t0;
	let t1;
	let t2;
	let div1;
	let mounted;
	let dispose;
	let if_block0 = /*input*/ ctx[6] && !/*buttonsOnly*/ ctx[9] && create_if_block_1$3(ctx);
	let if_block1 = !/*input*/ ctx[6] && !/*buttonsOnly*/ ctx[9] && create_if_block$8(ctx);
	let div2_levels = [{ class: /*classes*/ ctx[11] }, restProps(/*$$restProps*/ ctx[16])];
	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div1 = element("div");
			this.h();
		},
		l(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			children(div0).forEach(detach);
			t0 = claim_space(div2_nodes);
			if (if_block0) if_block0.l(div2_nodes);
			t1 = claim_space(div2_nodes);
			if (if_block1) if_block1.l(div2_nodes);
			t2 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			children(div1).forEach(detach);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "stepper-button-minus");
			attr(div1, "class", "stepper-button-plus");
			set_attributes(div2, div2_data);
		},
		m(target, anchor) {
			insert_hydration(target, div2, anchor);
			append_hydration(div2, div0);
			append_hydration(div2, t0);
			if (if_block0) if_block0.m(div2, null);
			append_hydration(div2, t1);
			if (if_block1) if_block1.m(div2, null);
			append_hydration(div2, t2);
			append_hydration(div2, div1);
			/*div2_binding*/ ctx[49](div2);

			if (!mounted) {
				dispose = [
					listen(div0, "click", /*onMinusClick*/ ctx[14]),
					listen(div1, "click", /*onPlusClick*/ ctx[15])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*input*/ ctx[6] && !/*buttonsOnly*/ ctx[9]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$3(ctx);
					if_block0.c();
					if_block0.m(div2, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!/*input*/ ctx[6] && !/*buttonsOnly*/ ctx[9]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$8(ctx);
					if_block1.c();
					if_block1.m(div2, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				dirty[0] & /*classes*/ 2048 && { class: /*classes*/ ctx[11] },
				dirty[0] & /*$$restProps*/ 65536 && restProps(/*$$restProps*/ ctx[16])
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			/*div2_binding*/ ctx[49](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

let index$h = 0;

function instance_1($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"lec","class","init","value","min","max","step","formatValue","name","inputId","input","inputType","inputReadonly","autorepeat","autorepeatDynamic","wraps","manualInputMode","decimalPoint","buttonsEndInputMode","disabled","buttonsOnly","round","roundMd","roundIos","roundAurora","fill","fillMd","fillIos","fillAurora","large","largeMd","largeIos","largeAurora","small","smallMd","smallIos","smallAurora","raised","raisedMd","raisedIos","raisedAurora","instance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { init = true } = $$props;
	let { value = 0 } = $$props;
	let { min = 0 } = $$props;
	let { max = 100 } = $$props;
	let { step = 1 } = $$props;
	let { formatValue = undefined } = $$props;
	let { name = undefined } = $$props;
	let { inputId = undefined } = $$props;
	let { input = true } = $$props;
	let { inputType = 'text' } = $$props;
	let { inputReadonly = false } = $$props;
	let { autorepeat = false } = $$props;
	let { autorepeatDynamic = false } = $$props;
	let { wraps = false } = $$props;
	let { manualInputMode = false } = $$props;
	let { decimalPoint = 4 } = $$props;
	let { buttonsEndInputMode = true } = $$props;
	let { disabled = undefined } = $$props;
	let { buttonsOnly = undefined } = $$props;
	let { round = false } = $$props;
	let { roundMd = false } = $$props;
	let { roundIos = false } = $$props;
	let { roundAurora = false } = $$props;
	let { fill = false } = $$props;
	let { fillMd = false } = $$props;
	let { fillIos = false } = $$props;
	let { fillAurora = false } = $$props;
	let { large = false } = $$props;
	let { largeMd = false } = $$props;
	let { largeIos = false } = $$props;
	let { largeAurora = false } = $$props;
	let { small = false } = $$props;
	let { smallMd = false } = $$props;
	let { smallIos = false } = $$props;
	let { smallAurora = false } = $$props;
	let { raised = false } = $$props;
	let { raisedMd = false } = $$props;
	let { raisedIos = false } = $$props;
	let { raisedAurora = false } = $$props;
	let el;
	let f7Stepper;

	function instance() {
		return f7Stepper;
	}

	function watchValue(newValue) {
		if (!f7Stepper) return;
		f7Stepper.setValue(newValue);
	}

	function onInput(event) {
		emit('input', [event, f7Stepper]);
	}

	function onChange(event) {
		emit('change', [event, f7Stepper]);
	}

	function onMinusClick(event) {
		emit('stepperMinusClick', [event, f7Stepper]);
	}

	function onPlusClick(event) {
		emit('stepperPlusClick', [event, f7Stepper]);
	}

	onMount(() => {
		if (!init) return;

		f7ready(() => {
			f7Stepper = app.f7.stepper.create(noUndefinedProps({
				el,
				min,
				max,
				value,
				step,
				formatValue,
				autorepeat,
				autorepeatDynamic,
				wraps,
				manualInputMode,
				decimalPoint,
				buttonsEndInputMode,
				on: {
					change(stepper, newValue) {
						emit('stepperChange', [newValue]);
						$$invalidate(0, value = newValue);
					}
				}
			}));
		});
	});

	onDestroy(() => {
		if (f7Stepper && f7Stepper.destroy) {
			f7Stepper.destroy();
			f7Stepper = null;
		}
	});

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(10, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(54, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(17, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(18, className = $$new_props.class);
		if ('init' in $$new_props) $$invalidate(19, init = $$new_props.init);
		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ('min' in $$new_props) $$invalidate(1, min = $$new_props.min);
		if ('max' in $$new_props) $$invalidate(2, max = $$new_props.max);
		if ('step' in $$new_props) $$invalidate(3, step = $$new_props.step);
		if ('formatValue' in $$new_props) $$invalidate(20, formatValue = $$new_props.formatValue);
		if ('name' in $$new_props) $$invalidate(4, name = $$new_props.name);
		if ('inputId' in $$new_props) $$invalidate(5, inputId = $$new_props.inputId);
		if ('input' in $$new_props) $$invalidate(6, input = $$new_props.input);
		if ('inputType' in $$new_props) $$invalidate(7, inputType = $$new_props.inputType);
		if ('inputReadonly' in $$new_props) $$invalidate(8, inputReadonly = $$new_props.inputReadonly);
		if ('autorepeat' in $$new_props) $$invalidate(21, autorepeat = $$new_props.autorepeat);
		if ('autorepeatDynamic' in $$new_props) $$invalidate(22, autorepeatDynamic = $$new_props.autorepeatDynamic);
		if ('wraps' in $$new_props) $$invalidate(23, wraps = $$new_props.wraps);
		if ('manualInputMode' in $$new_props) $$invalidate(24, manualInputMode = $$new_props.manualInputMode);
		if ('decimalPoint' in $$new_props) $$invalidate(25, decimalPoint = $$new_props.decimalPoint);
		if ('buttonsEndInputMode' in $$new_props) $$invalidate(26, buttonsEndInputMode = $$new_props.buttonsEndInputMode);
		if ('disabled' in $$new_props) $$invalidate(27, disabled = $$new_props.disabled);
		if ('buttonsOnly' in $$new_props) $$invalidate(9, buttonsOnly = $$new_props.buttonsOnly);
		if ('round' in $$new_props) $$invalidate(28, round = $$new_props.round);
		if ('roundMd' in $$new_props) $$invalidate(29, roundMd = $$new_props.roundMd);
		if ('roundIos' in $$new_props) $$invalidate(30, roundIos = $$new_props.roundIos);
		if ('roundAurora' in $$new_props) $$invalidate(31, roundAurora = $$new_props.roundAurora);
		if ('fill' in $$new_props) $$invalidate(32, fill = $$new_props.fill);
		if ('fillMd' in $$new_props) $$invalidate(33, fillMd = $$new_props.fillMd);
		if ('fillIos' in $$new_props) $$invalidate(34, fillIos = $$new_props.fillIos);
		if ('fillAurora' in $$new_props) $$invalidate(35, fillAurora = $$new_props.fillAurora);
		if ('large' in $$new_props) $$invalidate(36, large = $$new_props.large);
		if ('largeMd' in $$new_props) $$invalidate(37, largeMd = $$new_props.largeMd);
		if ('largeIos' in $$new_props) $$invalidate(38, largeIos = $$new_props.largeIos);
		if ('largeAurora' in $$new_props) $$invalidate(39, largeAurora = $$new_props.largeAurora);
		if ('small' in $$new_props) $$invalidate(40, small = $$new_props.small);
		if ('smallMd' in $$new_props) $$invalidate(41, smallMd = $$new_props.smallMd);
		if ('smallIos' in $$new_props) $$invalidate(42, smallIos = $$new_props.smallIos);
		if ('smallAurora' in $$new_props) $$invalidate(43, smallAurora = $$new_props.smallAurora);
		if ('raised' in $$new_props) $$invalidate(44, raised = $$new_props.raised);
		if ('raisedMd' in $$new_props) $$invalidate(45, raisedMd = $$new_props.raisedMd);
		if ('raisedIos' in $$new_props) $$invalidate(46, raisedIos = $$new_props.raisedIos);
		if ('raisedAurora' in $$new_props) $$invalidate(47, raisedAurora = $$new_props.raisedAurora);
	};

	$$self.$$.update = () => {
		$: $$invalidate(11, classes = classNames(
			className,
			'stepper',
			{
				disabled,
				'stepper-round': round,
				'stepper-round-ios': roundIos,
				'stepper-round-md': roundMd,
				'stepper-round-aurora': roundAurora,
				'stepper-fill': fill,
				'stepper-fill-ios': fillIos,
				'stepper-fill-md': fillMd,
				'stepper-fill-aurora': fillAurora,
				'stepper-large': large,
				'stepper-large-ios': largeIos,
				'stepper-large-md': largeMd,
				'stepper-large-aurora': largeAurora,
				'stepper-small': small,
				'stepper-small-ios': smallIos,
				'stepper-small-md': smallMd,
				'stepper-small-aurora': smallAurora,
				'stepper-raised': raised,
				'stepper-raised-ios': raisedIos,
				'stepper-raised-md': raisedMd,
				'stepper-raised-aurora': raisedAurora
			},
			colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*value*/ 1) {
			$: watchValue(value);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		value,
		min,
		max,
		step,
		name,
		inputId,
		input,
		inputType,
		inputReadonly,
		buttonsOnly,
		el,
		classes,
		onInput,
		onChange,
		onMinusClick,
		onPlusClick,
		$$restProps,
		lec,
		className,
		init,
		formatValue,
		autorepeat,
		autorepeatDynamic,
		wraps,
		manualInputMode,
		decimalPoint,
		buttonsEndInputMode,
		disabled,
		round,
		roundMd,
		roundIos,
		roundAurora,
		fill,
		fillMd,
		fillIos,
		fillAurora,
		large,
		largeMd,
		largeIos,
		largeAurora,
		small,
		smallMd,
		smallIos,
		smallAurora,
		raised,
		raisedMd,
		raisedIos,
		raisedAurora,
		instance,
		div2_binding
	];
}

class Stepper extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance_1,
			create_fragment$g,
			safe_not_equal,
			{
				lec: 17,
				class: 18,
				init: 19,
				value: 0,
				min: 1,
				max: 2,
				step: 3,
				formatValue: 20,
				name: 4,
				inputId: 5,
				input: 6,
				inputType: 7,
				inputReadonly: 8,
				autorepeat: 21,
				autorepeatDynamic: 22,
				wraps: 23,
				manualInputMode: 24,
				decimalPoint: 25,
				buttonsEndInputMode: 26,
				disabled: 27,
				buttonsOnly: 9,
				round: 28,
				roundMd: 29,
				roundIos: 30,
				roundAurora: 31,
				fill: 32,
				fillMd: 33,
				fillIos: 34,
				fillAurora: 35,
				large: 36,
				largeMd: 37,
				largeIos: 38,
				largeAurora: 39,
				small: 40,
				smallMd: 41,
				smallIos: 42,
				smallAurora: 43,
				raised: 44,
				raisedMd: 45,
				raisedIos: 46,
				raisedAurora: 47,
				instance: 48
			},
			null,
			[-1, -1]
		);
	}

	get instance() {
		return this.$$.ctx[48];
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/subnavbar.liquivelte generated by Svelte v3.50.0 */

function create_else_block$4(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (30:2) {#if inner}
function create_if_block$7(ctx) {
	let div;
	let t;
	let current;
	let if_block = /*title*/ ctx[0] && create_if_block_1$2(ctx);
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "subnavbar-inner");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*title*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$2(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (32:6) {#if title}
function create_if_block_1$2(ctx) {
	let div;
	let t;

	return {
		c() {
			div = element("div");
			t = text(/*title*/ ctx[0]);
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, /*title*/ ctx[0]);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "subnavbar-title");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 1) set_data(t, /*title*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$f(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$7, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*inner*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let div_levels = [
		{ class: /*classes*/ ctx[3] },
		{ "data-f7-slot": /*f7Slot*/ ctx[2] },
		restProps(/*$$restProps*/ ctx[4])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if_block.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true, "data-f7-slot": true });
			var div_nodes = children(div);
			if_block.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				(!current || dirty & /*f7Slot*/ 4) && { "data-f7-slot": /*f7Slot*/ ctx[2] },
				dirty & /*$$restProps*/ 16 && restProps(/*$$restProps*/ ctx[4])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
		}
	};
}

let index$g = 0;

function instance$f($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class","sliding","title","inner","f7Slot"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let { sliding = undefined } = $$props;
	let { title = undefined } = $$props;
	let { inner = true } = $$props;
	let { f7Slot = 'fixed' } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(5, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('sliding' in $$new_props) $$invalidate(7, sliding = $$new_props.sliding);
		if ('title' in $$new_props) $$invalidate(0, title = $$new_props.title);
		if ('inner' in $$new_props) $$invalidate(1, inner = $$new_props.inner);
		if ('f7Slot' in $$new_props) $$invalidate(2, f7Slot = $$new_props.f7Slot);
		if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(3, classes = classNames(className, 'subnavbar', { sliding }, colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);

	return [
		title,
		inner,
		f7Slot,
		classes,
		$$restProps,
		lec,
		className,
		sliding,
		$$scope,
		slots
	];
}

class Subnavbar extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
			lec: 5,
			class: 6,
			sliding: 7,
			title: 0,
			inner: 1,
			f7Slot: 2
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/swipeout-actions.liquivelte generated by Svelte v3.50.0 */

function create_fragment$e(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$f = 0;

function instance$e($$self, $$props, $$invalidate) {
	let classes;
	let sideComputed;
	const omit_props_names = ["lec","class","left","right","side"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let { left = undefined } = $$props;
	let { right = undefined } = $$props;
	let { side = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('left' in $$new_props) $$invalidate(4, left = $$new_props.left);
		if ('right' in $$new_props) $$invalidate(5, right = $$new_props.right);
		if ('side' in $$new_props) $$invalidate(6, side = $$new_props.side);
		if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*side, left, right*/ 112) {
			// eslint-disable-next-line
			$: $$invalidate(7, sideComputed = side || (left ? 'left' : right ? 'right' : 'left'));
		}

		$: $$invalidate(0, classes = classNames(className, `swipeout-actions-${sideComputed}`, colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);

	return [
		classes,
		$$restProps,
		lec,
		className,
		left,
		right,
		side,
		sideComputed,
		$$scope,
		slots
	];
}

class Swipeout_actions extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
			lec: 2,
			class: 3,
			left: 4,
			right: 5,
			side: 6
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/swipeout-button.liquivelte generated by Svelte v3.50.0 */

function create_fragment$d(ctx) {
	let a;
	let t0_value = plainText(/*text*/ ctx[0]) + "";
	let t0;
	let t1;
	let a_href_value;
	let a_data_confirm_value;
	let a_data_confirm_title_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	let a_levels = [
		{
			href: a_href_value = /*href*/ ctx[3] || '#'
		},
		{
			"data-confirm": a_data_confirm_value = /*confirmText*/ ctx[2] || undefined
		},
		{
			"data-confirm-title": a_data_confirm_title_value = /*confirmTitle*/ ctx[1] || undefined
		},
		{ class: /*classes*/ ctx[4] },
		restProps(/*$$restProps*/ ctx[6])
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			a = claim_element(nodes, "A", {
				href: true,
				"data-confirm": true,
				"data-confirm-title": true,
				class: true
			});

			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			t1 = claim_space(a_nodes);
			if (default_slot) default_slot.l(a_nodes);
			a_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(a, a_data);
		},
		m(target, anchor) {
			insert_hydration(target, a, anchor);
			append_hydration(a, t0);
			append_hydration(a, t1);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(a, "click", /*onClick*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*text*/ 1) && t0_value !== (t0_value = plainText(/*text*/ ctx[0]) + "")) set_data(t0, t0_value);

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
						null
					);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*href*/ 8 && a_href_value !== (a_href_value = /*href*/ ctx[3] || '#')) && { href: a_href_value },
				(!current || dirty & /*confirmText*/ 4 && a_data_confirm_value !== (a_data_confirm_value = /*confirmText*/ ctx[2] || undefined)) && { "data-confirm": a_data_confirm_value },
				(!current || dirty & /*confirmTitle*/ 2 && a_data_confirm_title_value !== (a_data_confirm_title_value = /*confirmTitle*/ ctx[1] || undefined)) && {
					"data-confirm-title": a_data_confirm_title_value
				},
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

let index$e = 0;

function instance$d($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"lec","class","text","confirmTitle","confirmText","overswipe","close","delete","href"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { text = undefined } = $$props;
	let { confirmTitle = undefined } = $$props;
	let { confirmText = undefined } = $$props;
	let { overswipe = undefined } = $$props;
	let { close = undefined } = $$props;
	let { delete: deleteProp = undefined } = $$props;
	let { href = undefined } = $$props;

	function onClick() {
		emit('click');
	}

	$$self.$$set = $$new_props => {
		$$invalidate(16, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(7, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ('text' in $$new_props) $$invalidate(0, text = $$new_props.text);
		if ('confirmTitle' in $$new_props) $$invalidate(1, confirmTitle = $$new_props.confirmTitle);
		if ('confirmText' in $$new_props) $$invalidate(2, confirmText = $$new_props.confirmText);
		if ('overswipe' in $$new_props) $$invalidate(9, overswipe = $$new_props.overswipe);
		if ('close' in $$new_props) $$invalidate(10, close = $$new_props.close);
		if ('delete' in $$new_props) $$invalidate(11, deleteProp = $$new_props.delete);
		if ('href' in $$new_props) $$invalidate(3, href = $$new_props.href);
		if ('$$scope' in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(4, classes = classNames(
			className,
			{
				'swipeout-overswipe': overswipe,
				'swipeout-delete': deleteProp,
				'swipeout-close': close
			},
			colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		text,
		confirmTitle,
		confirmText,
		href,
		classes,
		onClick,
		$$restProps,
		lec,
		className,
		overswipe,
		close,
		deleteProp,
		$$scope,
		slots
	];
}

class Swipeout_button extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$d, create_fragment$d, safe_not_equal, {
			lec: 7,
			class: 8,
			text: 0,
			confirmTitle: 1,
			confirmText: 2,
			overswipe: 9,
			close: 10,
			delete: 11,
			href: 3
		});
	}
}

// eslint-disable-next-line

// eslint-disable-next-line

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/tab.liquivelte generated by Svelte v3.50.0 */

function create_if_block$6(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*tabContent*/ ctx[2].props];
	var switch_value = /*tabContent*/ ctx[2].component;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_hydration(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = (dirty & /*tabContent*/ 4)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*tabContent*/ ctx[2].props)])
			: {};

			if (switch_value !== (switch_value = /*tabContent*/ ctx[2].component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

function create_fragment$c(ctx) {
	let div;
	let t;
	let current;
	let if_block = /*tabContent*/ ctx[2] && create_if_block$6(ctx);
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	let div_levels = [
		{ id: /*id*/ ctx[0] },
		{ class: /*classes*/ ctx[3] },
		restProps(/*$$restProps*/ ctx[4])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[10](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*tabContent*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*tabContent*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$6(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*id*/ 1) && { id: /*id*/ ctx[0] },
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				dirty & /*$$restProps*/ 16 && restProps(/*$$restProps*/ ctx[4])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[10](null);
		}
	};
}

let index$d = 0;

function instance$c($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class","tabActive","id"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { tabActive = false } = $$props;
	let { id = undefined } = $$props;
	const RouterContext = getContext('RouterContext') || {};
	let el;
	let routerData = null;
	let initialTabContent = null;

	if (!routerData && RouterContext && RouterContext.route && RouterContext.route.route && RouterContext.route.route.tab && RouterContext.route.route.tab.id === id) {
		const { component, asyncComponent, options: tabRouteOptions } = RouterContext.route.route.tab;

		if (component || asyncComponent) {
			const parentProps = RouterContext.route.route.options && RouterContext.route.route.options.props;

			initialTabContent = {
				id: getComponentId(),
				component: component || asyncComponent,
				isAsync: !!asyncComponent,
				props: {
					...parentProps || {},
					...tabRouteOptions && tabRouteOptions.props || {},
					f7router: RouterContext.router,
					f7route: RouterContext.route,
					...RouterContext.route.params
				}
			};
		}
	}

	let tabContent = initialTabContent || null;
	useTab(() => el, emit);

	onMount(() => {
		if (el && initialTabContent) {
			$$invalidate(1, el.f7RouterTabLoaded = true, el);
		}

		f7ready(() => {
			if (!routerData) {
				routerData = {
					el,
					setTabContent(tc) {
						tick().then(() => {
							$$invalidate(2, tabContent = tc);
						});
					}
				};

				app.f7routers.tabs.push(routerData);
			} else {
				routerData.el = el;
			}
		});
	});

	afterUpdate(() => {
		if (!routerData) return;
		app.f7events.emit('tabRouterDidUpdate', routerData);
	});

	onDestroy(() => {
		if (!routerData) return;
		app.f7routers.tabs.splice(app.f7routers.tabs.indexOf(routerData), 1);
		routerData = null;
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(16, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(5, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('tabActive' in $$new_props) $$invalidate(7, tabActive = $$new_props.tabActive);
		if ('id' in $$new_props) $$invalidate(0, id = $$new_props.id);
		if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(3, classes = classNames(className, 'tab', tabActive && 'tab-active', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);

	return [
		id,
		el,
		tabContent,
		classes,
		$$restProps,
		lec,
		className,
		tabActive,
		$$scope,
		slots,
		div_binding
	];
}

class Tab extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$c, create_fragment$c, safe_not_equal, { lec: 5, class: 6, tabActive: 7, id: 0 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/tabs.liquivelte generated by Svelte v3.50.0 */

function create_else_block$3(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	let div_levels = [
		{
			class: div_class_value = classNames(/*tabsClasses*/ ctx[3], /*classes*/ ctx[5])
		},
		restProps(/*$$restProps*/ ctx[6])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*tabsClasses, classes*/ 40 && div_class_value !== (div_class_value = classNames(/*tabsClasses*/ ctx[3], /*classes*/ ctx[5]))) && { class: div_class_value },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (39:0) {#if animated || swipeable}
function create_if_block$5(ctx) {
	let div1;
	let div0;
	let div1_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	let div1_levels = [
		{
			class: div1_class_value = classNames(/*wrapClasses*/ ctx[4], /*classes*/ ctx[5])
		},
		restProps(/*$$restProps*/ ctx[6])
	];

	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (default_slot) default_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", /*tabsClasses*/ ctx[3]);
			set_attributes(div1, div1_data);
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);
			append_hydration(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div1_binding*/ ctx[13](div1);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*tabsClasses*/ 8) {
				attr(div0, "class", /*tabsClasses*/ ctx[3]);
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty & /*wrapClasses, classes*/ 48 && div1_class_value !== (div1_class_value = classNames(/*wrapClasses*/ ctx[4], /*classes*/ ctx[5]))) && { class: div1_class_value },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
			/*div1_binding*/ ctx[13](null);
		}
	};
}

function create_fragment$b(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$5, create_else_block$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*animated*/ ctx[0] || /*swipeable*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

let index$c = 0;

function instance$b($$self, $$props, $$invalidate) {
	let classes;
	let wrapClasses;
	let tabsClasses;
	const omit_props_names = ["lec","class","animated","swipeable","routable","swiperParams"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;
	let { animated = false } = $$props;
	let { swipeable = false } = $$props;
	let { routable = false } = $$props;
	let { swiperParams = undefined } = $$props;
	let wrapEl;

	onMount(() => {
		if (swipeable && swiperParams && wrapEl) {
			$$invalidate(2, wrapEl.f7SwiperParams = swiperParams, wrapEl);
		}
	});

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			wrapEl = $$value;
			$$invalidate(2, wrapEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(7, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ('animated' in $$new_props) $$invalidate(0, animated = $$new_props.animated);
		if ('swipeable' in $$new_props) $$invalidate(1, swipeable = $$new_props.swipeable);
		if ('routable' in $$new_props) $$invalidate(9, routable = $$new_props.routable);
		if ('swiperParams' in $$new_props) $$invalidate(10, swiperParams = $$new_props.swiperParams);
		if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(5, classes = classNames(className, colorClasses($$props)));

		if ($$self.$$.dirty & /*animated, swipeable*/ 3) {
			$: $$invalidate(4, wrapClasses = classNames({
				'tabs-animated-wrap': animated,
				'tabs-swipeable-wrap': swipeable
			}));
		}

		if ($$self.$$.dirty & /*routable*/ 512) {
			$: $$invalidate(3, tabsClasses = classNames({ tabs: true, 'tabs-routable': routable }));
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		animated,
		swipeable,
		wrapEl,
		tabsClasses,
		wrapClasses,
		classes,
		$$restProps,
		lec,
		className,
		routable,
		swiperParams,
		$$scope,
		slots,
		div1_binding
	];
}

class Tabs extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
			lec: 7,
			class: 8,
			animated: 0,
			swipeable: 1,
			routable: 9,
			swiperParams: 10
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/toolbar.liquivelte generated by Svelte v3.50.0 */
const get_after_inner_slot_changes = dirty => ({});
const get_after_inner_slot_context = ctx => ({});
const get_before_inner_slot_changes = dirty => ({});
const get_before_inner_slot_context = ctx => ({});

// (111:2) {:else}
function create_else_block$2(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[25].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[24], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 16777216)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[24],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[24])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[24], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (107:2) {#if inner}
function create_if_block$4(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[25].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[24], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "toolbar-inner");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 16777216)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[24],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[24])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[24], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$a(ctx) {
	let div;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let current;
	const before_inner_slot_template = /*#slots*/ ctx[25]["before-inner"];
	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[24], get_before_inner_slot_context);
	const if_block_creators = [create_if_block$4, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*inner*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const after_inner_slot_template = /*#slots*/ ctx[25]["after-inner"];
	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[24], get_after_inner_slot_context);

	let div_levels = [
		{ class: /*classes*/ ctx[3] },
		{ "data-f7-slot": /*f7Slot*/ ctx[1] },
		restProps(/*$$restProps*/ ctx[4])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (before_inner_slot) before_inner_slot.c();
			t0 = space();
			if_block.c();
			t1 = space();
			if (after_inner_slot) after_inner_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true, "data-f7-slot": true });
			var div_nodes = children(div);
			if (before_inner_slot) before_inner_slot.l(div_nodes);
			t0 = claim_space(div_nodes);
			if_block.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (after_inner_slot) after_inner_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (before_inner_slot) {
				before_inner_slot.m(div, null);
			}

			append_hydration(div, t0);
			if_blocks[current_block_type_index].m(div, null);
			append_hydration(div, t1);

			if (after_inner_slot) {
				after_inner_slot.m(div, null);
			}

			/*div_binding*/ ctx[26](div);
			current = true;
		},
		p(ctx, dirty) {
			if (before_inner_slot) {
				if (before_inner_slot.p && (!current || dirty[0] & /*$$scope*/ 16777216)) {
					update_slot_base(
						before_inner_slot,
						before_inner_slot_template,
						ctx,
						/*$$scope*/ ctx[24],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[24])
						: get_slot_changes(before_inner_slot_template, /*$$scope*/ ctx[24], dirty, get_before_inner_slot_changes),
						get_before_inner_slot_context
					);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, t1);
			}

			if (after_inner_slot) {
				if (after_inner_slot.p && (!current || dirty[0] & /*$$scope*/ 16777216)) {
					update_slot_base(
						after_inner_slot,
						after_inner_slot_template,
						ctx,
						/*$$scope*/ ctx[24],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[24])
						: get_slot_changes(after_inner_slot_template, /*$$scope*/ ctx[24], dirty, get_after_inner_slot_changes),
						get_after_inner_slot_context
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				(!current || dirty[0] & /*f7Slot*/ 2) && { "data-f7-slot": /*f7Slot*/ ctx[1] },
				dirty[0] & /*$$restProps*/ 16 && restProps(/*$$restProps*/ ctx[4])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(before_inner_slot, local);
			transition_in(if_block);
			transition_in(after_inner_slot, local);
			current = true;
		},
		o(local) {
			transition_out(before_inner_slot, local);
			transition_out(if_block);
			transition_out(after_inner_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (before_inner_slot) before_inner_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (after_inner_slot) after_inner_slot.d(detaching);
			/*div_binding*/ ctx[26](null);
		}
	};
}

let index$b = 0;

function instance$a($$self, $$props, $$invalidate) {
	let classes;

	const omit_props_names = [
		"lec","class","tabbar","labels","scrollable","hidden","noShadow","noHairline","noBorder","position","topMd","topIos","topAurora","top","bottomMd","bottomIos","bottomAurora","bottom","inner","f7Slot"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { tabbar = false } = $$props;
	let { labels = false } = $$props;
	let { scrollable = false } = $$props;
	let { hidden = false } = $$props;
	let { noShadow = false } = $$props;
	let { noHairline = false } = $$props;
	let { noBorder = false } = $$props;
	let { position = undefined } = $$props;
	let { topMd = undefined } = $$props;
	let { topIos = undefined } = $$props;
	let { topAurora = undefined } = $$props;
	let { top = undefined } = $$props;
	let { bottomMd = undefined } = $$props;
	let { bottomIos = undefined } = $$props;
	let { bottomAurora = undefined } = $$props;
	let { bottom = undefined } = $$props;
	let { inner = true } = $$props;
	let { f7Slot = 'fixed' } = $$props;
	let el;

	let theme = useTheme(t => {
		$$invalidate(23, theme = t);
	});

	setReactiveContext('TabbarContext', () => ({ tabbarHasLabels: labels }));

	function onShow(toolbarEl) {
		if (el !== toolbarEl) return;
		emit('toolbarShow');
	}

	function onHide(toolbarEl) {
		if (el !== toolbarEl) return;
		emit('toolbarHide');
	}

	onMount(() => {
		f7ready(() => {
			if (tabbar) app.f7.toolbar.setHighlight(el);
			app.f7.on('toolbarShow', onShow);
			app.f7.on('toolbarHide', onHide);
		});
	});

	afterUpdate(() => {
		if (tabbar && app.f7 && el) {
			app.f7.toolbar.setHighlight(el);
		}
	});

	onDestroy(() => {
		if (!app.f7) return;
		app.f7.off('toolbarShow', onShow);
		app.f7.off('toolbarHide', onHide);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(31, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(5, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('tabbar' in $$new_props) $$invalidate(7, tabbar = $$new_props.tabbar);
		if ('labels' in $$new_props) $$invalidate(8, labels = $$new_props.labels);
		if ('scrollable' in $$new_props) $$invalidate(9, scrollable = $$new_props.scrollable);
		if ('hidden' in $$new_props) $$invalidate(10, hidden = $$new_props.hidden);
		if ('noShadow' in $$new_props) $$invalidate(11, noShadow = $$new_props.noShadow);
		if ('noHairline' in $$new_props) $$invalidate(12, noHairline = $$new_props.noHairline);
		if ('noBorder' in $$new_props) $$invalidate(13, noBorder = $$new_props.noBorder);
		if ('position' in $$new_props) $$invalidate(14, position = $$new_props.position);
		if ('topMd' in $$new_props) $$invalidate(15, topMd = $$new_props.topMd);
		if ('topIos' in $$new_props) $$invalidate(16, topIos = $$new_props.topIos);
		if ('topAurora' in $$new_props) $$invalidate(17, topAurora = $$new_props.topAurora);
		if ('top' in $$new_props) $$invalidate(18, top = $$new_props.top);
		if ('bottomMd' in $$new_props) $$invalidate(19, bottomMd = $$new_props.bottomMd);
		if ('bottomIos' in $$new_props) $$invalidate(20, bottomIos = $$new_props.bottomIos);
		if ('bottomAurora' in $$new_props) $$invalidate(21, bottomAurora = $$new_props.bottomAurora);
		if ('bottom' in $$new_props) $$invalidate(22, bottom = $$new_props.bottom);
		if ('inner' in $$new_props) $$invalidate(0, inner = $$new_props.inner);
		if ('f7Slot' in $$new_props) $$invalidate(1, f7Slot = $$new_props.f7Slot);
		if ('$$scope' in $$new_props) $$invalidate(24, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(3, classes = classNames(
			className,
			'toolbar',
			{
				tabbar,
				'toolbar-bottom': theme && theme.md && bottomMd || theme && theme.ios && bottomIos || theme && theme.aurora && bottomAurora || bottom || position === 'bottom',
				'toolbar-top': theme && theme.md && topMd || theme && theme.ios && topIos || theme && theme.aurora && topAurora || top || position === 'top',
				'tabbar-labels': labels,
				'tabbar-scrollable': scrollable,
				'toolbar-hidden': hidden,
				'no-shadow': noShadow,
				'no-hairline': noHairline || noBorder
			},
			colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		inner,
		f7Slot,
		el,
		classes,
		$$restProps,
		lec,
		className,
		tabbar,
		labels,
		scrollable,
		hidden,
		noShadow,
		noHairline,
		noBorder,
		position,
		topMd,
		topIos,
		topAurora,
		top,
		bottomMd,
		bottomIos,
		bottomAurora,
		bottom,
		theme,
		$$scope,
		slots,
		div_binding
	];
}

class Toolbar extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$a,
			create_fragment$a,
			safe_not_equal,
			{
				lec: 5,
				class: 6,
				tabbar: 7,
				labels: 8,
				scrollable: 9,
				hidden: 10,
				noShadow: 11,
				noHairline: 12,
				noBorder: 13,
				position: 14,
				topMd: 15,
				topIos: 16,
				topAurora: 17,
				top: 18,
				bottomMd: 19,
				bottomIos: 20,
				bottomAurora: 21,
				bottom: 22,
				inner: 0,
				f7Slot: 1
			},
			null,
			[-1, -1]
		);
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/treeview-item.liquivelte generated by Svelte v3.50.0 */
const get_children_slot_changes = dirty => ({});
const get_children_slot_context = ctx => ({});
const get_children_start_slot_changes = dirty => ({});
const get_children_start_slot_context = ctx => ({});
const get_root_end_slot_changes_1 = dirty => ({});
const get_root_end_slot_context_1 = ctx => ({});
const get_root_slot_changes_1 = dirty => ({});
const get_root_slot_context_1 = ctx => ({});
const get_content_end_slot_changes_1 = dirty => ({});
const get_content_end_slot_context_1 = ctx => ({});
const get_content_slot_changes_1 = dirty => ({});
const get_content_slot_context_1 = ctx => ({});
const get_label_slot_changes_1 = dirty => ({});
const get_label_slot_context_1 = ctx => ({});
const get_label_start_slot_changes_1 = dirty => ({});
const get_label_start_slot_context_1 = ctx => ({});
const get_media_slot_changes_1 = dirty => ({});
const get_media_slot_context_1 = ctx => ({});
const get_content_start_slot_changes_1 = dirty => ({});
const get_content_start_slot_context_1 = ctx => ({});
const get_root_start_slot_changes_1 = dirty => ({});
const get_root_start_slot_context_1 = ctx => ({});
const get_root_end_slot_changes = dirty => ({});
const get_root_end_slot_context = ctx => ({});
const get_root_slot_changes = dirty => ({});
const get_root_slot_context = ctx => ({});
const get_content_end_slot_changes = dirty => ({});
const get_content_end_slot_context = ctx => ({});
const get_content_slot_changes = dirty => ({});
const get_content_slot_context = ctx => ({});
const get_label_slot_changes = dirty => ({});
const get_label_slot_context = ctx => ({});
const get_label_start_slot_changes = dirty => ({});
const get_label_start_slot_context = ctx => ({});
const get_media_slot_changes = dirty => ({});
const get_media_slot_context = ctx => ({});
const get_content_start_slot_changes = dirty => ({});
const get_content_start_slot_context = ctx => ({});
const get_root_start_slot_changes = dirty => ({});
const get_root_start_slot_context = ctx => ({});

// (135:2) {:else}
function create_else_block$1(ctx) {
	let a;
	let t0;
	let t1;
	let div1;
	let t2;
	let t3;
	let t4;
	let div0;
	let t5;
	let t6_value = plainText(/*label*/ ctx[1]) + "";
	let t6;
	let t7;
	let t8;
	let t9;
	let t10;
	let t11;
	let current;
	let mounted;
	let dispose;
	const root_start_slot_template = /*#slots*/ ctx[21]["root-start"];
	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[20], get_root_start_slot_context_1);
	let if_block0 = /*needToggle*/ ctx[6] && create_if_block_5(ctx);
	const content_start_slot_template = /*#slots*/ ctx[21]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[20], get_content_start_slot_context_1);
	let if_block1 = /*icon*/ ctx[5] && create_if_block_4(ctx);
	const media_slot_template = /*#slots*/ ctx[21].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[20], get_media_slot_context_1);
	const label_start_slot_template = /*#slots*/ ctx[21]["label-start"];
	const label_start_slot = create_slot(label_start_slot_template, ctx, /*$$scope*/ ctx[20], get_label_start_slot_context_1);
	const label_slot_template = /*#slots*/ ctx[21].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[20], get_label_slot_context_1);
	const content_slot_template = /*#slots*/ ctx[21].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[20], get_content_slot_context_1);
	const content_end_slot_template = /*#slots*/ ctx[21]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[20], get_content_end_slot_context_1);
	const root_slot_template = /*#slots*/ ctx[21].root;
	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[20], get_root_slot_context_1);
	const root_end_slot_template = /*#slots*/ ctx[21]["root-end"];
	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[20], get_root_end_slot_context_1);
	let a_levels = [{ class: /*itemRootClasses*/ ctx[8] }, /*itemRootAttrs*/ ctx[7]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	return {
		c() {
			a = element("a");
			if (root_start_slot) root_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (media_slot) media_slot.c();
			t4 = space();
			div0 = element("div");
			if (label_start_slot) label_start_slot.c();
			t5 = space();
			t6 = text(t6_value);
			t7 = space();
			if (label_slot) label_slot.c();
			t8 = space();
			if (content_slot) content_slot.c();
			t9 = space();
			if (content_end_slot) content_end_slot.c();
			t10 = space();
			if (root_slot) root_slot.c();
			t11 = space();
			if (root_end_slot) root_end_slot.c();
			this.h();
		},
		l(nodes) {
			a = claim_element(nodes, "A", { class: true });
			var a_nodes = children(a);
			if (root_start_slot) root_start_slot.l(a_nodes);
			t0 = claim_space(a_nodes);
			if (if_block0) if_block0.l(a_nodes);
			t1 = claim_space(a_nodes);
			div1 = claim_element(a_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (content_start_slot) content_start_slot.l(div1_nodes);
			t2 = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			t3 = claim_space(div1_nodes);
			if (media_slot) media_slot.l(div1_nodes);
			t4 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (label_start_slot) label_start_slot.l(div0_nodes);
			t5 = claim_space(div0_nodes);
			t6 = claim_text(div0_nodes, t6_value);
			t7 = claim_space(div0_nodes);
			if (label_slot) label_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			t8 = claim_space(div1_nodes);
			if (content_slot) content_slot.l(div1_nodes);
			t9 = claim_space(div1_nodes);
			if (content_end_slot) content_end_slot.l(div1_nodes);
			div1_nodes.forEach(detach);
			t10 = claim_space(a_nodes);
			if (root_slot) root_slot.l(a_nodes);
			t11 = claim_space(a_nodes);
			if (root_end_slot) root_end_slot.l(a_nodes);
			a_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "treeview-item-label");
			attr(div1, "class", "treeview-item-content");
			set_attributes(a, a_data);
		},
		m(target, anchor) {
			insert_hydration(target, a, anchor);

			if (root_start_slot) {
				root_start_slot.m(a, null);
			}

			append_hydration(a, t0);
			if (if_block0) if_block0.m(a, null);
			append_hydration(a, t1);
			append_hydration(a, div1);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_hydration(div1, t2);
			if (if_block1) if_block1.m(div1, null);
			append_hydration(div1, t3);

			if (media_slot) {
				media_slot.m(div1, null);
			}

			append_hydration(div1, t4);
			append_hydration(div1, div0);

			if (label_start_slot) {
				label_start_slot.m(div0, null);
			}

			append_hydration(div0, t5);
			append_hydration(div0, t6);
			append_hydration(div0, t7);

			if (label_slot) {
				label_slot.m(div0, null);
			}

			append_hydration(div1, t8);

			if (content_slot) {
				content_slot.m(div1, null);
			}

			append_hydration(div1, t9);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			append_hydration(a, t10);

			if (root_slot) {
				root_slot.m(a, null);
			}

			append_hydration(a, t11);

			if (root_end_slot) {
				root_end_slot.m(a, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(a, "click", /*onClick*/ ctx[10]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (root_start_slot) {
				if (root_start_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						root_start_slot,
						root_start_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(root_start_slot_template, /*$$scope*/ ctx[20], dirty, get_root_start_slot_changes_1),
						get_root_start_slot_context_1
					);
				}
			}

			if (/*needToggle*/ ctx[6]) {
				if (if_block0) {
					
				} else {
					if_block0 = create_if_block_5(ctx);
					if_block0.c();
					if_block0.m(a, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (content_start_slot) {
				if (content_start_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						content_start_slot,
						content_start_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[20], dirty, get_content_start_slot_changes_1),
						get_content_start_slot_context_1
					);
				}
			}

			if (/*icon*/ ctx[5]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*icon*/ 32) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_4(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (media_slot) {
				if (media_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						media_slot,
						media_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[20], dirty, get_media_slot_changes_1),
						get_media_slot_context_1
					);
				}
			}

			if (label_start_slot) {
				if (label_start_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						label_start_slot,
						label_start_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(label_start_slot_template, /*$$scope*/ ctx[20], dirty, get_label_start_slot_changes_1),
						get_label_start_slot_context_1
					);
				}
			}

			if ((!current || dirty & /*label*/ 2) && t6_value !== (t6_value = plainText(/*label*/ ctx[1]) + "")) set_data(t6, t6_value);

			if (label_slot) {
				if (label_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						label_slot,
						label_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[20], dirty, get_label_slot_changes_1),
						get_label_slot_context_1
					);
				}
			}

			if (content_slot) {
				if (content_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						content_slot,
						content_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[20], dirty, get_content_slot_changes_1),
						get_content_slot_context_1
					);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						content_end_slot,
						content_end_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[20], dirty, get_content_end_slot_changes_1),
						get_content_end_slot_context_1
					);
				}
			}

			if (root_slot) {
				if (root_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						root_slot,
						root_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(root_slot_template, /*$$scope*/ ctx[20], dirty, get_root_slot_changes_1),
						get_root_slot_context_1
					);
				}
			}

			if (root_end_slot) {
				if (root_end_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						root_end_slot,
						root_end_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(root_end_slot_template, /*$$scope*/ ctx[20], dirty, get_root_end_slot_changes_1),
						get_root_end_slot_context_1
					);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*itemRootClasses*/ 256) && { class: /*itemRootClasses*/ ctx[8] },
				dirty & /*itemRootAttrs*/ 128 && /*itemRootAttrs*/ ctx[7]
			]));
		},
		i(local) {
			if (current) return;
			transition_in(root_start_slot, local);
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(media_slot, local);
			transition_in(label_start_slot, local);
			transition_in(label_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			transition_in(root_slot, local);
			transition_in(root_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(root_start_slot, local);
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(media_slot, local);
			transition_out(label_start_slot, local);
			transition_out(label_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			transition_out(root_slot, local);
			transition_out(root_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if (root_start_slot) root_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (media_slot) media_slot.d(detaching);
			if (label_start_slot) label_start_slot.d(detaching);
			if (label_slot) label_slot.d(detaching);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			if (root_slot) root_slot.d(detaching);
			if (root_end_slot) root_end_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

// (112:2) {#if treeviewRootTag === 'div'}
function create_if_block_1$1(ctx) {
	let div2;
	let t0;
	let t1;
	let div1;
	let t2;
	let t3;
	let t4;
	let div0;
	let t5;
	let t6_value = plainText(/*label*/ ctx[1]) + "";
	let t6;
	let t7;
	let t8;
	let t9;
	let t10;
	let t11;
	let current;
	let mounted;
	let dispose;
	const root_start_slot_template = /*#slots*/ ctx[21]["root-start"];
	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[20], get_root_start_slot_context);
	let if_block0 = /*needToggle*/ ctx[6] && create_if_block_3(ctx);
	const content_start_slot_template = /*#slots*/ ctx[21]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[20], get_content_start_slot_context);
	let if_block1 = /*icon*/ ctx[5] && create_if_block_2(ctx);
	const media_slot_template = /*#slots*/ ctx[21].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[20], get_media_slot_context);
	const label_start_slot_template = /*#slots*/ ctx[21]["label-start"];
	const label_start_slot = create_slot(label_start_slot_template, ctx, /*$$scope*/ ctx[20], get_label_start_slot_context);
	const label_slot_template = /*#slots*/ ctx[21].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[20], get_label_slot_context);
	const content_slot_template = /*#slots*/ ctx[21].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[20], get_content_slot_context);
	const content_end_slot_template = /*#slots*/ ctx[21]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[20], get_content_end_slot_context);
	const root_slot_template = /*#slots*/ ctx[21].root;
	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[20], get_root_slot_context);
	const root_end_slot_template = /*#slots*/ ctx[21]["root-end"];
	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[20], get_root_end_slot_context);
	let div2_levels = [{ class: /*itemRootClasses*/ ctx[8] }, /*itemRootAttrs*/ ctx[7]];
	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	return {
		c() {
			div2 = element("div");
			if (root_start_slot) root_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (media_slot) media_slot.c();
			t4 = space();
			div0 = element("div");
			if (label_start_slot) label_start_slot.c();
			t5 = space();
			t6 = text(t6_value);
			t7 = space();
			if (label_slot) label_slot.c();
			t8 = space();
			if (content_slot) content_slot.c();
			t9 = space();
			if (content_end_slot) content_end_slot.c();
			t10 = space();
			if (root_slot) root_slot.c();
			t11 = space();
			if (root_end_slot) root_end_slot.c();
			this.h();
		},
		l(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			if (root_start_slot) root_start_slot.l(div2_nodes);
			t0 = claim_space(div2_nodes);
			if (if_block0) if_block0.l(div2_nodes);
			t1 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (content_start_slot) content_start_slot.l(div1_nodes);
			t2 = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			t3 = claim_space(div1_nodes);
			if (media_slot) media_slot.l(div1_nodes);
			t4 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (label_start_slot) label_start_slot.l(div0_nodes);
			t5 = claim_space(div0_nodes);
			t6 = claim_text(div0_nodes, t6_value);
			t7 = claim_space(div0_nodes);
			if (label_slot) label_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			t8 = claim_space(div1_nodes);
			if (content_slot) content_slot.l(div1_nodes);
			t9 = claim_space(div1_nodes);
			if (content_end_slot) content_end_slot.l(div1_nodes);
			div1_nodes.forEach(detach);
			t10 = claim_space(div2_nodes);
			if (root_slot) root_slot.l(div2_nodes);
			t11 = claim_space(div2_nodes);
			if (root_end_slot) root_end_slot.l(div2_nodes);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "treeview-item-label");
			attr(div1, "class", "treeview-item-content");
			set_attributes(div2, div2_data);
		},
		m(target, anchor) {
			insert_hydration(target, div2, anchor);

			if (root_start_slot) {
				root_start_slot.m(div2, null);
			}

			append_hydration(div2, t0);
			if (if_block0) if_block0.m(div2, null);
			append_hydration(div2, t1);
			append_hydration(div2, div1);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_hydration(div1, t2);
			if (if_block1) if_block1.m(div1, null);
			append_hydration(div1, t3);

			if (media_slot) {
				media_slot.m(div1, null);
			}

			append_hydration(div1, t4);
			append_hydration(div1, div0);

			if (label_start_slot) {
				label_start_slot.m(div0, null);
			}

			append_hydration(div0, t5);
			append_hydration(div0, t6);
			append_hydration(div0, t7);

			if (label_slot) {
				label_slot.m(div0, null);
			}

			append_hydration(div1, t8);

			if (content_slot) {
				content_slot.m(div1, null);
			}

			append_hydration(div1, t9);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			append_hydration(div2, t10);

			if (root_slot) {
				root_slot.m(div2, null);
			}

			append_hydration(div2, t11);

			if (root_end_slot) {
				root_end_slot.m(div2, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(div2, "click", /*onClick*/ ctx[10]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (root_start_slot) {
				if (root_start_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						root_start_slot,
						root_start_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(root_start_slot_template, /*$$scope*/ ctx[20], dirty, get_root_start_slot_changes),
						get_root_start_slot_context
					);
				}
			}

			if (/*needToggle*/ ctx[6]) {
				if (if_block0) {
					
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					if_block0.m(div2, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (content_start_slot) {
				if (content_start_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						content_start_slot,
						content_start_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[20], dirty, get_content_start_slot_changes),
						get_content_start_slot_context
					);
				}
			}

			if (/*icon*/ ctx[5]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*icon*/ 32) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (media_slot) {
				if (media_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						media_slot,
						media_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(media_slot_template, /*$$scope*/ ctx[20], dirty, get_media_slot_changes),
						get_media_slot_context
					);
				}
			}

			if (label_start_slot) {
				if (label_start_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						label_start_slot,
						label_start_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(label_start_slot_template, /*$$scope*/ ctx[20], dirty, get_label_start_slot_changes),
						get_label_start_slot_context
					);
				}
			}

			if ((!current || dirty & /*label*/ 2) && t6_value !== (t6_value = plainText(/*label*/ ctx[1]) + "")) set_data(t6, t6_value);

			if (label_slot) {
				if (label_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						label_slot,
						label_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[20], dirty, get_label_slot_changes),
						get_label_slot_context
					);
				}
			}

			if (content_slot) {
				if (content_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						content_slot,
						content_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[20], dirty, get_content_slot_changes),
						get_content_slot_context
					);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						content_end_slot,
						content_end_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[20], dirty, get_content_end_slot_changes),
						get_content_end_slot_context
					);
				}
			}

			if (root_slot) {
				if (root_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						root_slot,
						root_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(root_slot_template, /*$$scope*/ ctx[20], dirty, get_root_slot_changes),
						get_root_slot_context
					);
				}
			}

			if (root_end_slot) {
				if (root_end_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						root_end_slot,
						root_end_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(root_end_slot_template, /*$$scope*/ ctx[20], dirty, get_root_end_slot_changes),
						get_root_end_slot_context
					);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty & /*itemRootClasses*/ 256) && { class: /*itemRootClasses*/ ctx[8] },
				dirty & /*itemRootAttrs*/ 128 && /*itemRootAttrs*/ ctx[7]
			]));
		},
		i(local) {
			if (current) return;
			transition_in(root_start_slot, local);
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(media_slot, local);
			transition_in(label_start_slot, local);
			transition_in(label_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			transition_in(root_slot, local);
			transition_in(root_end_slot, local);
			current = true;
		},
		o(local) {
			transition_out(root_start_slot, local);
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(media_slot, local);
			transition_out(label_start_slot, local);
			transition_out(label_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			transition_out(root_slot, local);
			transition_out(root_end_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			if (root_start_slot) root_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (media_slot) media_slot.d(detaching);
			if (label_start_slot) label_start_slot.d(detaching);
			if (label_slot) label_slot.d(detaching);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			if (root_slot) root_slot.d(detaching);
			if (root_end_slot) root_end_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

// (138:6) {#if needToggle}
function create_if_block_5(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "treeview-toggle");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (143:8) {#if icon}
function create_if_block_4(ctx) {
	let useicon;
	let current;

	useicon = new Use_icon({
			props: {
				icon: /*icon*/ ctx[5],
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(useicon.$$.fragment);
		},
		l(nodes) {
			claim_component(useicon.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(useicon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const useicon_changes = {};
			if (dirty & /*icon*/ 32) useicon_changes.icon = /*icon*/ ctx[5];
			if (dirty & /*lec*/ 1) useicon_changes.lec = /*lec*/ ctx[0];
			useicon.$set(useicon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(useicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(useicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(useicon, detaching);
		}
	};
}

// (115:6) {#if needToggle}
function create_if_block_3(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "treeview-toggle");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (120:8) {#if icon}
function create_if_block_2(ctx) {
	let useicon;
	let current;

	useicon = new Use_icon({
			props: {
				icon: /*icon*/ ctx[5],
				lec: /*lec*/ ctx[0]
			}
		});

	return {
		c() {
			create_component(useicon.$$.fragment);
		},
		l(nodes) {
			claim_component(useicon.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(useicon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const useicon_changes = {};
			if (dirty & /*icon*/ 32) useicon_changes.icon = /*icon*/ ctx[5];
			if (dirty & /*lec*/ 1) useicon_changes.lec = /*lec*/ ctx[0];
			useicon.$set(useicon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(useicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(useicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(useicon, detaching);
		}
	};
}

// (159:2) {#if hasChildren}
function create_if_block$3(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	const children_start_slot_template = /*#slots*/ ctx[21]["children-start"];
	const children_start_slot = create_slot(children_start_slot_template, ctx, /*$$scope*/ ctx[20], get_children_start_slot_context);
	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);
	const children_slot_template = /*#slots*/ ctx[21].children;
	const children_slot = create_slot(children_slot_template, ctx, /*$$scope*/ ctx[20], get_children_slot_context);

	return {
		c() {
			div = element("div");
			if (children_start_slot) children_start_slot.c();
			t0 = space();
			if (default_slot) default_slot.c();
			t1 = space();
			if (children_slot) children_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (children_start_slot) children_start_slot.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (children_slot) children_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "treeview-item-children");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (children_start_slot) {
				children_start_slot.m(div, null);
			}

			append_hydration(div, t0);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_hydration(div, t1);

			if (children_slot) {
				children_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (children_start_slot) {
				if (children_start_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						children_start_slot,
						children_start_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(children_start_slot_template, /*$$scope*/ ctx[20], dirty, get_children_start_slot_changes),
						get_children_start_slot_context
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
						null
					);
				}
			}

			if (children_slot) {
				if (children_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						children_slot,
						children_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(children_slot_template, /*$$scope*/ ctx[20], dirty, get_children_slot_changes),
						get_children_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(children_start_slot, local);
			transition_in(default_slot, local);
			transition_in(children_slot, local);
			current = true;
		},
		o(local) {
			transition_out(children_start_slot, local);
			transition_out(default_slot, local);
			transition_out(children_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (children_start_slot) children_start_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (children_slot) children_slot.d(detaching);
		}
	};
}

function create_fragment$9(ctx) {
	let div;
	let current_block_type_index;
	let if_block0;
	let t;
	let current;
	const if_block_creators = [create_if_block_1$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*treeviewRootTag*/ ctx[4] === 'div') return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*hasChildren*/ ctx[2] && create_if_block$3(ctx);
	let div_levels = [{ class: /*classes*/ ctx[9] }, restProps(/*$$restProps*/ ctx[11])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if_block0.l(div_nodes);
			t = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			append_hydration(div, t);
			if (if_block1) if_block1.m(div, null);
			/*div_binding*/ ctx[22](div);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(div, t);
			}

			if (/*hasChildren*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*hasChildren*/ 4) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 512) && { class: /*classes*/ ctx[9] },
				dirty & /*$$restProps*/ 2048 && restProps(/*$$restProps*/ ctx[11])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			/*div_binding*/ ctx[22](null);
		}
	};
}

let index$a = 0;

function instance$9($$self, $$props, $$invalidate) {
	let classes;
	let itemRootClasses;
	let itemRootAttrs;
	let hasChildren;
	let needToggle;
	let icon;
	let treeviewRootTag;

	const omit_props_names = [
		"lec","class","toggle","itemToggle","selectable","selected","opened","label","loadChildren","link"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let { class: className = undefined } = $$props;
	let { toggle = undefined } = $$props;
	let { itemToggle = false } = $$props;
	let { selectable = false } = $$props;
	let { selected = false } = $$props;
	let { opened = false } = $$props;
	let { label = undefined } = $$props;
	let { loadChildren = false } = $$props;
	let { link = undefined } = $$props;
	let el;

	function onClick(e) {
		emit('click', [e]);
	}

	function onOpen(itemEl) {
		if (itemEl !== el) return;
		emit('treeviewOpen', [el]);
	}

	function onClose(itemEl) {
		if (itemEl !== el) return;
		emit('treeviewClose', [el]);
	}

	function onLoadChildren(itemEl, done) {
		if (itemEl !== el) return;
		emit('treeviewLoadChildren', [el, done]);
	}

	onMount(() => {
		if (!el) return;

		f7ready(() => {
			app.f7.on('treeviewOpen', onOpen);
			app.f7.on('treeviewClose', onClose);
			app.f7.on('treeviewLoadChildren', onLoadChildren);
		});
	});

	onDestroy(() => {
		if (!el || !app.f7) return;
		app.f7.off('treeviewOpen', onOpen);
		app.f7.off('treeviewClose', onClose);
		app.f7.off('treeviewLoadChildren', onLoadChildren);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(28, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(0, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(12, className = $$new_props.class);
		if ('toggle' in $$new_props) $$invalidate(13, toggle = $$new_props.toggle);
		if ('itemToggle' in $$new_props) $$invalidate(14, itemToggle = $$new_props.itemToggle);
		if ('selectable' in $$new_props) $$invalidate(15, selectable = $$new_props.selectable);
		if ('selected' in $$new_props) $$invalidate(16, selected = $$new_props.selected);
		if ('opened' in $$new_props) $$invalidate(17, opened = $$new_props.opened);
		if ('label' in $$new_props) $$invalidate(1, label = $$new_props.label);
		if ('loadChildren' in $$new_props) $$invalidate(18, loadChildren = $$new_props.loadChildren);
		if ('link' in $$new_props) $$invalidate(19, link = $$new_props.link);
		if ('$$scope' in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(9, classes = classNames(
			className,
			'treeview-item',
			{
				'treeview-item-opened': opened,
				'treeview-load-children': loadChildren
			},
			colorClasses($$props)
		));

		$: $$invalidate(8, itemRootClasses = classNames(
			'treeview-item-root',
			{
				'treeview-item-selectable': selectable,
				'treeview-item-selected': selected,
				'treeview-item-toggle': itemToggle
			},
			routerClasses($$props),
			actionsClasses($$props)
		));

		$: $$invalidate(7, itemRootAttrs = extend(
			{
				href: link === true ? '#' : link || undefined
			},
			routerAttrs($$props),
			actionsAttrs($$props)
		));

		if ($$self.$$.dirty & /*toggle, hasChildren*/ 8196) {
			/* eslint-enable no-undef */
			$: $$invalidate(6, needToggle = typeof toggle === 'undefined' ? hasChildren : toggle);
		}

		$: $$invalidate(5, icon = useIcon($$props));

		if ($$self.$$.dirty & /*link*/ 524288) {
			$: $$invalidate(4, treeviewRootTag = link || link === '' ? 'a' : 'div');
		}
	};

	$: $$invalidate(2, hasChildren = $$slots.default || $$slots.children || $$slots['children-start']);
	$$props = exclude_internal_props($$props);

	return [
		lec,
		label,
		hasChildren,
		el,
		treeviewRootTag,
		icon,
		needToggle,
		itemRootAttrs,
		itemRootClasses,
		classes,
		onClick,
		$$restProps,
		className,
		toggle,
		itemToggle,
		selectable,
		selected,
		opened,
		loadChildren,
		link,
		$$scope,
		slots,
		div_binding
	];
}

class Treeview_item extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
			lec: 0,
			class: 12,
			toggle: 13,
			itemToggle: 14,
			selectable: 15,
			selected: 16,
			opened: 17,
			label: 1,
			loadChildren: 18,
			link: 19
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/treeview.liquivelte generated by Svelte v3.50.0 */

function create_fragment$8(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$9 = 0;

function instance$8($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'treeview', colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, className, $$scope, slots];
}

class Treeview extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { lec: 2, class: 3 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/views.liquivelte generated by Svelte v3.50.0 */

function create_fragment$7(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			set_attributes(div, div_data);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

let index$8 = 0;

function instance$7($$self, $$props, $$invalidate) {
	let classes;
	const omit_props_names = ["lec","tabs","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { tabs = false } = $$props;
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('lec' in $$new_props) $$invalidate(2, lec = $$new_props.lec);
		if ('tabs' in $$new_props) $$invalidate(3, tabs = $$new_props.tabs);
		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		$: $$invalidate(0, classes = classNames(className, 'views', { tabs }, colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, lec, tabs, className, $$scope, slots];
}

class Views extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { lec: 2, tabs: 3, class: 4 });
	}
}

/**
 * Framework7 Liquivelte 7.0.9
 * Build full featured iOS & Android apps using Framework7 & Svelte
 * https://framework7.io/svelte/
 *
 * Copyright 2014-2022 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: December 4, 2022
 */

const theme = {
  Helpers: {
    serialize: function serialize(form) {
      var arr = [];
      Array.prototype.slice.call(form.elements).forEach(function (field) {
        if (
          !field.name ||
          field.disabled ||
          ['file', 'reset', 'submit', 'button'].indexOf(field.type) > -1
        )
          return;
        if (field.type === 'select-multiple') {
          Array.prototype.slice.call(field.options).forEach(function (option) {
            if (!option.selected) return;
            arr.push(
              encodeURIComponent(field.name) +
              '=' +
              encodeURIComponent(option.value)
            );
          });
          return;
        }
        if (['checkbox', 'radio'].indexOf(field.type) > -1 && !field.checked)
          return;
        arr.push(
          encodeURIComponent(field.name) + '=' + encodeURIComponent(field.value)
        );
      });
      return arr.join('&');
    }
  }
};

function handleize(str) {
  str = str.toLowerCase();

  var toReplace = ['"', "'", "\\", "(", ")", "[", "]"];

  // For the old browsers
  for (var i = 0; i < toReplace.length; ++i) {
    str = str.replace(toReplace[i], "");
  }

  str = str.replace(/\W+/g, "-");

  if (str.charAt(str.length - 1) == "-") {
    str = str.replace(/-+\z/, "");
  }

  if (str.charAt(0) == "-") {
    str = str.replace(/\A-+/, "");
  }

  return str;
};
function updateHistoryState(variant) {
  if (!history.replaceState || !variant) {
    return;
  }

  var newurl =
    window.location.protocol +
    '//' +
    window.location.host +
    window.location.pathname +
    '?variant=' +
    variant.id;
  window.history.replaceState({ path: newurl }, '', newurl);
}

/**
 * @typedef {object} AddToCartResult
 * @property 
 */
/**
 * @param  {HTMLFormElement | Number} formOrVariantId
 * @param  {Number} quantity
 * @param  {Object} properties
 * @returns 
 */
async function addToCart(formOrVariantId, quantity, properties) {
  let result = {};
  let response;
  try {
    if (formOrVariantId.constructor === HTMLFormElement) {
      response = await fetch('/cart/add.js', {
        method: 'POST',
        credentials: 'same-origin',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-Requested-With': 'XMLHttpRequest'
        },
        body: theme.Helpers.serialize(formOrVariantId)
      });
    }
    else {
      response = await fetch(`/cart/update.js`, {
        method: 'POST',
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({items: [
          {
            quantity,
            id: formOrVariantId,
            properties
          }
        ]})
      });
    }
    const responseData = await response.json();

    if (responseData.status && responseData.status !== 200) {
      var error = new Error(responseData.description);
      // error.isFromServer = true;
      throw error;
    }
    document.body.dispatchEvent(new CustomEvent('shopify:added_to_cart', { detail: responseData }));
    result = responseData;
  } catch (err) {
    result = {
      status: 500,
      description: err.message
    };
  }
  return result;
}

function preloadImage(src) {
  return new Promise(done => {
    var img = new Image();
    img.onload = done;
    img.src = src;
  });
}

function isValidHttpUrl(string) {
  let url;
  string = string.replace(/^\/\//, 'https://');
  try {
    url = new URL(string);
  } catch (_) {
    return false;
  }

  return url.protocol === "http:" || url.protocol === "https:";
}


function getScrollbarWidth() {

  // Creating invisible container
  const outer = document.createElement('div');
  outer.style.visibility = 'hidden';
  outer.style.overflow = 'scroll'; // forcing scrollbar to appear
  outer.style.msOverflowStyle = 'scrollbar'; // needed for WinJS apps
  document.body.appendChild(outer);

  // Creating inner element and placing it in the container
  const inner = document.createElement('div');
  inner.style.width = '100%';
  inner.style.display = 'block';
  outer.appendChild(inner);

  // Calculating difference between container's full width and the child width
  const scrollbarWidth = (outer.offsetWidth - inner.offsetWidth);

  // Removing temporary elements from the DOM
  outer.parentNode.removeChild(outer);

  return scrollbarWidth;

}

var y_offsetWhenScrollDisabled = 0;

// window.addEventListener('scroll', e => {
//   const y_offsetWhenScrollDisabled = Math.max(window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop);

//   document.documentElement.scrollTop = y_offsetWhenScrollDisabled;
//   window.pageYOffset = y_offsetWhenScrollDisabled;
//   document.body.scrollTop = y_offsetWhenScrollDisabled;
// });

function disableScrollOnBody() {
  y_offsetWhenScrollDisabled = Math.max(window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop);
  document.body.classList.add('prevent-scrolling');
  document.body.setAttribute('style', `margin-top: -${y_offsetWhenScrollDisabled}px; width: ${window.innerWidth - getScrollbarWidth()}px;`);
}
function enableScrollOnBody() {
  if (document.body.classList.contains('prevent-scrolling')) {
    document.body.classList.remove('prevent-scrolling');
    document.body.style.marginTop = '';
    document.documentElement.scrollTop = y_offsetWhenScrollDisabled;
    window.pageYOffset = y_offsetWhenScrollDisabled;
    document.body.scrollTop = y_offsetWhenScrollDisabled;
    document.body.style.width = ``;
  }
}

function getFocusableElements(container) {
  return Array.from(
    container.querySelectorAll(
      "summary, a[href], button:enabled, [tabindex]:not([tabindex^='-']), [draggable], area, input:not([type=hidden]):enabled, select:enabled, textarea:enabled, object, iframe"
    )
  );
}

// document.querySelectorAll('[id^="Details-"] summary').forEach((summary) => {
//   summary.setAttribute('role', 'button');
//   summary.setAttribute('aria-expanded', 'false');

//   if(summary.nextElementSibling.getAttribute('id')) {
//     summary.setAttribute('aria-controls', summary.nextElementSibling.id);
//   }

//   summary.addEventListener('click', (event) => {
//     event.currentTarget.setAttribute('aria-expanded', !event.currentTarget.closest('details').hasAttribute('open'));
//   });

//   if (summary.closest('header-drawer')) return;
//   summary.parentElement.addEventListener('keyup', onKeyUpEscape);
// });

const trapFocusHandlers = {};

function trapFocus$1(container, elementToFocus = container) {
  var elements = getFocusableElements(container);
  var first = elements[0];
  var last = elements[elements.length - 1];

  removeTrapFocus$1();

  trapFocusHandlers.focusin = (event) => {
    if (
      event.target !== container &&
      event.target !== last &&
      event.target !== first
    )
      return;

    document.addEventListener('keydown', trapFocusHandlers.keydown);
  };

  trapFocusHandlers.focusout = function() {
    document.removeEventListener('keydown', trapFocusHandlers.keydown);
  };

  trapFocusHandlers.keydown = function(event) {
    if (event.code.toUpperCase() !== 'TAB') return; // If not TAB key
    // On the last focusable element and tab forward, focus the first element.
    if (event.target === last && !event.shiftKey) {
      event.preventDefault();
      first.focus();
    }

    //  On the first focusable element and tab backward, focus the last element.
    if (
      (event.target === container || event.target === first) &&
      event.shiftKey
    ) {
      event.preventDefault();
      last.focus();
    }
  };

  document.addEventListener('focusout', trapFocusHandlers.focusout);
  document.addEventListener('focusin', trapFocusHandlers.focusin);

  elementToFocus.focus();
}

// Here run the querySelector to figure out if the browser supports :focus-visible or not and run code based on it.
try {
  document.querySelector(":focus-visible");
} catch(e) {
  focusVisiblePolyfill();
}

function focusVisiblePolyfill() {
  const navKeys = ['ARROWUP', 'ARROWDOWN', 'ARROWLEFT', 'ARROWRIGHT', 'TAB', 'ENTER', 'SPACE', 'ESCAPE', 'HOME', 'END', 'PAGEUP', 'PAGEDOWN'];
  let currentFocusedElement = null;
  let mouseClick = null;

  window.addEventListener('keydown', (event) => {
    if(navKeys.includes(event.code.toUpperCase())) {
      mouseClick = false;
    }
  });

  window.addEventListener('mousedown', (event) => {
    mouseClick = true;
  });

  window.addEventListener('focus', () => {
    if (currentFocusedElement) currentFocusedElement.classList.remove('focused');

    if (mouseClick) return;

    currentFocusedElement = document.activeElement;
    currentFocusedElement.classList.add('focused');

  }, true);
}

function pauseAllMedia() {
  document.querySelectorAll('.js-youtube').forEach((video) => {
    video.contentWindow.postMessage('{"event":"command","func":"' + 'pauseVideo' + '","args":""}', '*');
  });
  document.querySelectorAll('.js-vimeo').forEach((video) => {
    video.contentWindow.postMessage('{"method":"pause"}', '*');
  });
  document.querySelectorAll('video').forEach((video) => video.pause());
  document.querySelectorAll('product-model').forEach((model) => {
    if (model.modelViewerUI) model.modelViewerUI.pause();
  });
}

function removeTrapFocus$1(elementToFocus = null) {
  document.removeEventListener('focusin', trapFocusHandlers.focusin);
  document.removeEventListener('focusout', trapFocusHandlers.focusout);
  document.removeEventListener('keydown', trapFocusHandlers.keydown);

  if (elementToFocus) elementToFocus.focus();
}

function onKeyUpEscape(event) {
  if (event.code.toUpperCase() !== 'ESCAPE') return;

  const openDetailsElement = event.target.closest('details[open]');
  if (!openDetailsElement) return;

  const summaryElement = openDetailsElement.querySelector('summary');
  openDetailsElement.removeAttribute('open');
  summaryElement.setAttribute('aria-expanded', false);
  summaryElement.focus();
}

function debounce$1(fn, wait) {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn.apply(this, args), wait);
  };
}

function fetchConfig(type = 'json') {
  return {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', 'Accept': `application/${type}` }
  };
}

/*
 * Shopify Common JS
 *
 */
if ((typeof window.Shopify) == 'undefined') {
  window.Shopify = {};
}

Shopify.bind = function(fn, scope) {
  return function() {
    return fn.apply(scope, arguments);
  }
};

Shopify.setSelectorByValue = function(selector, value) {
  for (var i = 0, count = selector.options.length; i < count; i++) {
    var option = selector.options[i];
    if (value == option.value || value == option.innerHTML) {
      selector.selectedIndex = i;
      return i;
    }
  }
};

Shopify.addListener = function(target, eventName, callback) {
  target.addEventListener ? target.addEventListener(eventName, callback, false) : target.attachEvent('on'+eventName, callback);
};

Shopify.postLink = function(path, options) {
  options = options || {};
  var method = options['method'] || 'post';
  var params = options['parameters'] || {};

  var form = document.createElement("form");
  form.setAttribute("method", method);
  form.setAttribute("action", path);

  for(var key in params) {
    var hiddenField = document.createElement("input");
    hiddenField.setAttribute("type", "hidden");
    hiddenField.setAttribute("name", key);
    hiddenField.setAttribute("value", params[key]);
    form.appendChild(hiddenField);
  }
  document.body.appendChild(form);
  form.submit();
  document.body.removeChild(form);
};

Shopify.CountryProvinceSelector = function(country_domid, province_domid, options) {
  this.countryEl         = document.getElementById(country_domid);
  this.provinceEl        = document.getElementById(province_domid);
  this.provinceContainer = document.getElementById(options['hideElement'] || province_domid);

  Shopify.addListener(this.countryEl, 'change', Shopify.bind(this.countryHandler,this));

  this.initCountry();
  this.initProvince();
};

Shopify.CountryProvinceSelector.prototype = {
  initCountry: function() {
    var value = this.countryEl.getAttribute('data-default');
    Shopify.setSelectorByValue(this.countryEl, value);
    this.countryHandler();
  },

  initProvince: function() {
    var value = this.provinceEl.getAttribute('data-default');
    if (value && this.provinceEl.options.length > 0) {
      Shopify.setSelectorByValue(this.provinceEl, value);
    }
  },

  countryHandler: function(e) {
    var opt       = this.countryEl.options[this.countryEl.selectedIndex];
    var raw       = opt.getAttribute('data-provinces');
    var provinces = JSON.parse(raw);

    this.clearOptions(this.provinceEl);
    if (provinces && provinces.length == 0) {
      this.provinceContainer.style.display = 'none';
    } else {
      for (var i = 0; i < provinces.length; i++) {
        var opt = document.createElement('option');
        opt.value = provinces[i][0];
        opt.innerHTML = provinces[i][1];
        this.provinceEl.appendChild(opt);
      }

      this.provinceContainer.style.display = "";
    }
  },

  clearOptions: function(selector) {
    while (selector.firstChild) {
      selector.removeChild(selector.firstChild);
    }
  },

  setOptions: function(selector, values) {
    for (var i = 0, count = values.length; i < values.length; i++) {
      var opt = document.createElement('option');
      opt.value = values[i];
      opt.innerHTML = values[i];
      selector.appendChild(opt);
    }
  }
};

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/sections/header/components/navigation.liquivelte generated by Svelte v3.50.0 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	child_ctx[6] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[6] === 0,
		index: /*index*/ child_ctx[6] + 1,
		index0: /*index*/ child_ctx[6],
		last: /*index*/ child_ctx[6] === /*links*/ child_ctx[0].length - 1,
		rindex: /*links*/ child_ctx[0].length - /*index*/ child_ctx[6],
		rindex0: /*links*/ child_ctx[0].length - /*index*/ child_ctx[6] - 1,
		length: /*links*/ child_ctx[0].length
	};

	child_ctx[4] = constants_0;
	return child_ctx;
}

// (23:6) {#if lnk.links }
function create_if_block$2(ctx) {
	let details;
	let summary;
	let navigation;
	let details_id_value;
	let current;
	navigation = new Navigation({ props: { links: /*lnk*/ ctx[3].links } });

	return {
		c() {
			details = element("details");
			summary = element("summary");
			create_component(navigation.$$.fragment);
			this.h();
		},
		l(nodes) {
			details = claim_element(nodes, "DETAILS", { id: true });
			var details_nodes = children(details);
			summary = claim_element(details_nodes, "SUMMARY", { class: true });
			var summary_nodes = children(summary);
			claim_component(navigation.$$.fragment, summary_nodes);
			summary_nodes.forEach(detach);
			details_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(summary, "class", "menu-drawer__menu-item list-menu__item link link--text focus-inset");
			toggle_class(summary, "menu-drawer__menu-item--active", /*lnk*/ ctx[3].child_active);
			attr(details, "id", details_id_value = "Details-menu-drawer-menu-item-" + /*forloop*/ ctx[4].index);
		},
		m(target, anchor) {
			insert_hydration(target, details, anchor);
			append_hydration(details, summary);
			mount_component(navigation, summary, null);
			current = true;
		},
		p(ctx, dirty) {
			const navigation_changes = {};
			if (dirty & /*links*/ 1) navigation_changes.links = /*lnk*/ ctx[3].links;
			navigation.$set(navigation_changes);

			if (!current || dirty & /*links*/ 1) {
				toggle_class(summary, "menu-drawer__menu-item--active", /*lnk*/ ctx[3].child_active);
			}

			if (!current || dirty & /*links*/ 1 && details_id_value !== (details_id_value = "Details-menu-drawer-menu-item-" + /*forloop*/ ctx[4].index)) {
				attr(details, "id", details_id_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(navigation.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(navigation.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(details);
			destroy_component(navigation);
		}
	};
}

// (12:2) {#each  links as lnk, index  }
function create_each_block(ctx) {
	let li;
	let t0;
	let a;
	let t1_value = /*liquid*/ ctx[1].escape(/*lnk*/ ctx[3].title) + "";
	let t1;
	let a_href_value;
	let t2;
	let current;
	let if_block = /*lnk*/ ctx[3].links && create_if_block$2(ctx);

	return {
		c() {
			li = element("li");
			if (if_block) if_block.c();
			t0 = space();
			a = element("a");
			t1 = text(t1_value);
			t2 = space();
			this.h();
		},
		l(nodes) {
			li = claim_element(nodes, "LI", {});
			var li_nodes = children(li);
			if (if_block) if_block.l(li_nodes);
			t0 = claim_space(li_nodes);
			a = claim_element(li_nodes, "A", { href: true, class: true });
			var a_nodes = children(a);
			t1 = claim_text(a_nodes, t1_value);
			a_nodes.forEach(detach);
			t2 = claim_space(li_nodes);
			li_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(a, "href", a_href_value = /*lnk*/ ctx[3].url);
			attr(a, "class", "menu-drawer__menu-item list-menu__item link link--text focus-inset");
			toggle_class(a, "menu-drawer__menu-item--active", /*lnk*/ ctx[3].current);
		},
		m(target, anchor) {
			insert_hydration(target, li, anchor);
			if (if_block) if_block.m(li, null);
			append_hydration(li, t0);
			append_hydration(li, a);
			append_hydration(a, t1);
			append_hydration(li, t2);
			current = true;
		},
		p(ctx, dirty) {
			if (/*lnk*/ ctx[3].links) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*links*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(li, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if ((!current || dirty & /*links*/ 1) && t1_value !== (t1_value = /*liquid*/ ctx[1].escape(/*lnk*/ ctx[3].title) + "")) set_data(t1, t1_value);

			if (!current || dirty & /*links*/ 1 && a_href_value !== (a_href_value = /*lnk*/ ctx[3].url)) {
				attr(a, "href", a_href_value);
			}

			if (!current || dirty & /*links*/ 1) {
				toggle_class(a, "menu-drawer__menu-item--active", /*lnk*/ ctx[3].current);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (if_block) if_block.d();
		}
	};
}

function create_fragment$6(ctx) {
	let ul;
	let current;
	let each_value = /*links*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l(nodes) {
			ul = claim_element(nodes, "UL", { class: true, role: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(ul, "class", "menu-drawer__menu has-submenu list-menu");
			attr(ul, "role", "list");
		},
		m(target, anchor) {
			insert_hydration(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*links, liquid*/ 3) {
				each_value = /*links*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(ul);
			destroy_each(each_blocks, detaching);
		}
	};
}

let index$7 = 0;

function instance$6($$self, $$props, $$invalidate) {
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { links } = $$props;
	console.log('links ', links);

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(2, lec = $$props.lec);
		if ('links' in $$props) $$invalidate(0, links = $$props.links);
	};

	return [links, liquid, lec];
}

class Navigation extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { lec: 2, links: 0 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/sections/header/components/predictive-search.liquivelte generated by Svelte v3.50.0 */

function create_fragment$5(ctx) {
	let div;
	let div_data_loading_text_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true, "data-loading-text": true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "search-modal__form");
			attr(div, "data-loading-text", div_data_loading_text_value = /*liquid*/ ctx[1].t('accessibility.loading'));
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[5](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[5](null);
		}
	};
}

let index$6 = 0;

function onKeydown(event) {
	// Prevent the cursor from moving in the input when using the up and down arrow keys
	if (event.code === 'ArrowUp' || event.code === 'ArrowDown') {
		event.preventDefault();
	}
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let isOpen = false;
	let cachedResults = {};

	let container,
		input,
		statusElement,
		predictiveSearchResults,
		loadingText,
		resultsMaxHeight;

	onMount(() => {
		input = container.querySelector('input[type="search"]');
		predictiveSearchResults = container.querySelector('[data-predictive-search]');
		setupEventListeners();
		console.log('predictive search enabled');
	});

	function setupEventListeners() {
		const form = container.querySelector('form.search');
		form.addEventListener('submit', onFormSubmit);

		input.addEventListener('input', debounce(
			event => {
				onChange(event);
			},
			300
		));

		input.addEventListener('focus', onFocus);
		container.addEventListener('focusout', onFocusOut);
		container.addEventListener('keyup', onKeyup);
		container.addEventListener('keydown', onKeydown);
	}

	function getQuery() {
		return input.value.trim();
	}

	function onChange() {
		const searchTerm = getQuery();

		if (!searchTerm.length) {
			close(true);
			return;
		}

		getSearchResults(searchTerm);
	}

	function onFormSubmit(event) {
		if (!getQuery().length || querySelector('[aria-selected="true"] a')) event.preventDefault();
	}

	function onFocus() {
		const searchTerm = getQuery();
		if (!searchTerm.length) return;

		if (container.getAttribute('results') === 'true') {
			open();
		} else {
			getSearchResults(searchTerm);
		}
	}

	function onFocusOut() {
		setTimeout(() => {
			if (!container.contains(document.activeElement)) close();
		});
	}

	function onKeyup(event) {
		if (!getQuery().length) close(true);
		event.preventDefault();

		switch (event.code) {
			case 'ArrowUp':
				switchOption('up');
				break;
			case 'ArrowDown':
				switchOption('down');
				break;
			case 'Enter':
				selectOption();
				break;
		}
	}

	function switchOption(direction) {
		if (!container.getAttribute('open')) return;
		const moveUp = direction === 'up';
		const selectedElement = container.querySelector('[aria-selected="true"]');
		const allElements = container.querySelectorAll('li');
		let activeElement = container.querySelector('li');
		if (moveUp && !selectedElement) return;
		statusElement.textContent = '';

		if (!moveUp && selectedElement) {
			activeElement = selectedElement.nextElementSibling || allElements[0];
		} else if (moveUp) {
			activeElement = selectedElement.previousElementSibling || allElements[allElements.length - 1];
		}

		if (activeElement === selectedElement) return;
		activeElement.setAttribute('aria-selected', true);
		if (selectedElement) selectedElement.setAttribute('aria-selected', false);
		setLiveRegionText(activeElement.textContent);
		input.setAttribute('aria-activedescendant', activeElement.id);
	}

	function selectOption() {
		const selectedProduct = container.querySelector('[aria-selected="true"] a, [aria-selected="true"] button');
		if (selectedProduct) selectedProduct.click();
	}

	function getSearchResults(searchTerm) {
		const queryKey = searchTerm.replace(" ", "-").toLowerCase();
		setLiveRegionLoadingState();

		if (cachedResults[queryKey]) {
			renderSearchResults(cachedResults[queryKey]);
			return;
		}

		fetch(`${routes.predictive_search_url}?q=${encodeURIComponent(searchTerm)}&${encodeURIComponent('resources[type]')}=product&${encodeURIComponent('resources[limit]')}=4&section_id=predictive-search`).then(response => {
			if (!response.ok) {
				var error = new Error(response.status);
				close();
				throw error;
			}

			return response.text();
		}).then(text => {
			const resultsMarkup = new DOMParser().parseFromString(text, 'text/html').querySelector('#shopify-section-predictive-search').innerHTML;
			cachedResults[queryKey] = resultsMarkup;
			renderSearchResults(resultsMarkup);
		}).catch(error => {
			close();
			throw error;
		});
	}

	function setLiveRegionLoadingState() {
		statusElement = statusElement || container.querySelector('.predictive-search-status');
		loadingText = loadingText || container.getAttribute('data-loading-text');
		setLiveRegionText(loadingText);
		container.setAttribute('loading', true);
	}

	function setLiveRegionText(statusText) {
		statusElement.setAttribute('aria-hidden', 'false');
		statusElement.textContent = statusText;

		setTimeout(
			() => {
				statusElement.setAttribute('aria-hidden', 'true');
			},
			1000
		);
	}

	function renderSearchResults(resultsMarkup) {
		predictiveSearchResults.innerHTML = resultsMarkup;
		container.setAttribute('results', true);
		setLiveRegionResults();
		open();
	}

	function setLiveRegionResults() {
		container.removeAttribute('loading');
		setLiveRegionText(container.querySelector('[data-predictive-search-live-region-count-value]').textContent);
	}

	function getResultsMaxHeight() {
		resultsMaxHeight = window.innerHeight - document.getElementById('shopify-section-header').getBoundingClientRect().bottom;
		return resultsMaxHeight;
	}

	function open() {
		predictiveSearchResults.style.maxHeight = resultsMaxHeight || `${getResultsMaxHeight()}px`;
		container.setAttribute('open', true);
		input.setAttribute('aria-expanded', true);
		isOpen = true;
	}

	function close(clearSearchTerm = false) {
		if (clearSearchTerm) {
			input.value = '';
			container.removeAttribute('results');
		}

		const selected = container.querySelector('[aria-selected="true"]');
		if (selected) selected.setAttribute('aria-selected', false);
		input.setAttribute('aria-activedescendant', '');
		container.removeAttribute('open');
		input.setAttribute('aria-expanded', false);
		resultsMaxHeight = false;
		predictiveSearchResults.removeAttribute('style');
		isOpen = false;
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			container = $$value;
			$$invalidate(0, container);
		});
	}

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(2, lec = $$props.lec);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [container, liquid, lec, $$scope, slots, div_binding];
}

class Predictive_search extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { lec: 2 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/snippets/menu-drawer.liquivelte generated by Svelte v3.50.0 */

function create_fragment$4(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[15](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[15](null);
		}
	};
}

let index$5 = 0;

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { container, mainDetailsToggle, breakpoint } = $$props;

	let { bindEvents = function () {
		_bindEvents.apply(arguments[0], arguments);
	} } = $$props;

	let { onKeyUp = function () {
		_onKeyUp.apply(arguments[0], arguments);
	} } = $$props;

	let { onSummaryClick = function () {
		_onSummaryClick.apply(arguments[0], arguments);
	} } = $$props;

	let { openMenuDrawer = function () {
		_openMenuDrawer.apply(arguments[0], arguments);
	} } = $$props;

	let { closeMenuDrawer = function () {
		_closeMenuDrawer.apply(arguments[0], arguments);
	} } = $$props;

	let { onFocusOut = function () {
		_onFocusOut.apply(arguments[0], arguments);
	} } = $$props;

	let { onCloseButtonClick = function () {
		_onCloseButtonClick.apply(arguments[0], arguments);
	} } = $$props;

	let { closeSubmenu = function () {
		_closeSubmenu.apply(arguments[0], arguments);
	} } = $$props;

	let { closeAnimation = function () {
		_closeAnimation.apply(arguments[0], arguments);
	} } = $$props;

	onMount(() => {
		$$invalidate(1, mainDetailsToggle = container.querySelector('details'));
		if (navigator.platform === 'iPhone') document.documentElement.style.setProperty('--viewport-height', `${window.innerHeight}px`);
		container.addEventListener('keyup', onKeyUp.bind(_onKeyUp));
		container.addEventListener('focusout', onFocusOut.bind(_onFocusOut));
		bindEvents.call(bindEvents.bind(_bindEvents));
	});

	function _bindEvents() {
		container.querySelectorAll('summary').forEach(summary => summary.addEventListener('click', onSummaryClick.bind(_onSummaryClick)));
		container.querySelectorAll('button').forEach(button => button.addEventListener('click', onCloseButtonClick.bind(_onCloseButtonClick)));
	}

	function _onKeyUp(event) {
		if (event.code.toUpperCase() !== 'ESCAPE') return;
		const openDetailsElement = event.target.closest('details[open]');
		if (!openDetailsElement) return;

		openDetailsElement === mainDetailsToggle
		? closeMenuDrawer.call(_closeMenuDrawer, event, mainDetailsToggle.querySelector('summary'))
		: closeSubmenu.call(_closeSubmenu, openDetailsElement);
	}

	function _onSummaryClick(event) {
		const summaryElement = event.currentTarget;
		const detailsElement = summaryElement.parentNode;
		const isOpen = detailsElement.hasAttribute('open');
		const reducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)");

		function addTrapFocus() {
			trapFocus$1(summaryElement.nextElementSibling, detailsElement.querySelector('button'));
			summaryElement.nextElementSibling.removeEventListener('transitionend', addTrapFocus);
		}

		if (detailsElement === mainDetailsToggle) {
			if (isOpen) event.preventDefault();

			isOpen
			? closeMenuDrawer.call(_closeMenuDrawer, event, summaryElement)
			: openMenuDrawer.call(_openMenuDrawer, summaryElement);
		} else {
			setTimeout(
				() => {
					detailsElement.classList.add('menu-opening');
					summaryElement.setAttribute('aria-expanded', true);

					!reducedMotion || reducedMotion.matches
					? addTrapFocus()
					: summaryElement.nextElementSibling.addEventListener('transitionend', addTrapFocus);
				},
				100
			);
		}
	}

	function _openMenuDrawer(summaryElement) {
		setTimeout(() => {
			mainDetailsToggle.classList.add('menu-opening');
		});

		summaryElement.setAttribute('aria-expanded', true);
		trapFocus$1(this.mainDetailsToggle, summaryElement);
		document.body.classList.add(`overflow-hidden-${breakpoint}`);
	}

	function _closeMenuDrawer(event, elementToFocus = false) {
		if (event === undefined) return;
		mainDetailsToggle.classList.remove('menu-opening');

		mainDetailsToggle.querySelectorAll('details').forEach(details => {
			details.removeAttribute('open');
			details.classList.remove('menu-opening');
		});

		document.body.classList.remove(`overflow-hidden-${breakpoint}`);
		removeTrapFocus(elementToFocus);
		closeAnimation.call(_closeAnimation, mainDetailsToggle);
	}

	function _onFocusOut(event) {
		setTimeout(() => {
			if (mainDetailsToggle.hasAttribute('open') && !mainDetailsToggle.contains(document.activeElement)) closeMenuDrawer.call(_closeMenuDrawer);
		});
	}

	function _onCloseButtonClick(event) {
		const detailsElement = event.currentTarget.closest('details');
		closeSubmenu.call(_closeSubmenu, detailsElement);
	}

	function _closeSubmenu(detailsElement) {
		detailsElement.classList.remove('menu-opening');
		detailsElement.querySelector('summary').setAttribute('aria-expanded', false);
		removeTrapFocus(detailsElement.querySelector('summary'));
		closeAnimation.call(_closeAnimation, detailsElement);
	}

	function _closeAnimation(detailsElement) {
		let animationStart;

		const handleAnimation = time => {
			if (animationStart === undefined) {
				animationStart = time;
			}

			const elapsedTime = time - animationStart;

			if (elapsedTime < 400) {
				window.requestAnimationFrame(handleAnimation);
			} else {
				detailsElement.removeAttribute('open');

				if (detailsElement.closest('details[open]')) {
					trapFocus$1(detailsElement.closest('details[open]'), detailsElement.querySelector('summary'));
				}
			}
		};

		window.requestAnimationFrame(handleAnimation);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			container = $$value;
			$$invalidate(0, container);
		});
	}

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(2, lec = $$props.lec);
		if ('container' in $$props) $$invalidate(0, container = $$props.container);
		if ('mainDetailsToggle' in $$props) $$invalidate(1, mainDetailsToggle = $$props.mainDetailsToggle);
		if ('breakpoint' in $$props) $$invalidate(3, breakpoint = $$props.breakpoint);
		if ('bindEvents' in $$props) $$invalidate(4, bindEvents = $$props.bindEvents);
		if ('onKeyUp' in $$props) $$invalidate(5, onKeyUp = $$props.onKeyUp);
		if ('onSummaryClick' in $$props) $$invalidate(6, onSummaryClick = $$props.onSummaryClick);
		if ('openMenuDrawer' in $$props) $$invalidate(7, openMenuDrawer = $$props.openMenuDrawer);
		if ('closeMenuDrawer' in $$props) $$invalidate(8, closeMenuDrawer = $$props.closeMenuDrawer);
		if ('onFocusOut' in $$props) $$invalidate(9, onFocusOut = $$props.onFocusOut);
		if ('onCloseButtonClick' in $$props) $$invalidate(10, onCloseButtonClick = $$props.onCloseButtonClick);
		if ('closeSubmenu' in $$props) $$invalidate(11, closeSubmenu = $$props.closeSubmenu);
		if ('closeAnimation' in $$props) $$invalidate(12, closeAnimation = $$props.closeAnimation);
		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
	};

	return [
		container,
		mainDetailsToggle,
		lec,
		breakpoint,
		bindEvents,
		onKeyUp,
		onSummaryClick,
		openMenuDrawer,
		closeMenuDrawer,
		onFocusOut,
		onCloseButtonClick,
		closeSubmenu,
		closeAnimation,
		$$scope,
		slots,
		div_binding
	];
}

class Menu_drawer extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			lec: 2,
			container: 0,
			mainDetailsToggle: 1,
			breakpoint: 3,
			bindEvents: 4,
			onKeyUp: 5,
			onSummaryClick: 6,
			openMenuDrawer: 7,
			closeMenuDrawer: 8,
			onFocusOut: 9,
			onCloseButtonClick: 10,
			closeSubmenu: 11,
			closeAnimation: 12
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/sections/header/components/header-drawer.liquivelte generated by Svelte v3.50.0 */

function create_default_slot$1(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$3(ctx) {
	let menudrawer;
	let updating_closeMenuDrawer;
	let updating_openMenuDrawer;
	let updating_mainDetailsToggle;
	let current;
	const menudrawer_spread_levels = [/*$$props*/ ctx[4], { lec: /*lec*/ ctx[1] }];

	function menudrawer_closeMenuDrawer_binding(value) {
		/*menudrawer_closeMenuDrawer_binding*/ ctx[9](value);
	}

	function menudrawer_openMenuDrawer_binding(value) {
		/*menudrawer_openMenuDrawer_binding*/ ctx[10](value);
	}

	function menudrawer_mainDetailsToggle_binding(value) {
		/*menudrawer_mainDetailsToggle_binding*/ ctx[11](value);
	}

	let menudrawer_props = {
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	};

	for (let i = 0; i < menudrawer_spread_levels.length; i += 1) {
		menudrawer_props = assign(menudrawer_props, menudrawer_spread_levels[i]);
	}

	if (/*closeMenuDrawer*/ ctx[3] !== void 0) {
		menudrawer_props.closeMenuDrawer = /*closeMenuDrawer*/ ctx[3];
	}

	if (/*openMenuDrawer*/ ctx[2] !== void 0) {
		menudrawer_props.openMenuDrawer = /*openMenuDrawer*/ ctx[2];
	}

	if (/*mainDetailsToggle*/ ctx[0] !== void 0) {
		menudrawer_props.mainDetailsToggle = /*mainDetailsToggle*/ ctx[0];
	}

	menudrawer = new Menu_drawer({ props: menudrawer_props });
	binding_callbacks.push(() => bind(menudrawer, 'closeMenuDrawer', menudrawer_closeMenuDrawer_binding));
	binding_callbacks.push(() => bind(menudrawer, 'openMenuDrawer', menudrawer_openMenuDrawer_binding));
	binding_callbacks.push(() => bind(menudrawer, 'mainDetailsToggle', menudrawer_mainDetailsToggle_binding));

	return {
		c() {
			create_component(menudrawer.$$.fragment);
		},
		l(nodes) {
			claim_component(menudrawer.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(menudrawer, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const menudrawer_changes = (dirty & /*$$props, lec*/ 18)
			? get_spread_update(menudrawer_spread_levels, [
					dirty & /*$$props*/ 16 && get_spread_object(/*$$props*/ ctx[4]),
					dirty & /*lec*/ 2 && { lec: /*lec*/ ctx[1] }
				])
			: {};

			if (dirty & /*$$scope*/ 4096) {
				menudrawer_changes.$$scope = { dirty, ctx };
			}

			if (!updating_closeMenuDrawer && dirty & /*closeMenuDrawer*/ 8) {
				updating_closeMenuDrawer = true;
				menudrawer_changes.closeMenuDrawer = /*closeMenuDrawer*/ ctx[3];
				add_flush_callback(() => updating_closeMenuDrawer = false);
			}

			if (!updating_openMenuDrawer && dirty & /*openMenuDrawer*/ 4) {
				updating_openMenuDrawer = true;
				menudrawer_changes.openMenuDrawer = /*openMenuDrawer*/ ctx[2];
				add_flush_callback(() => updating_openMenuDrawer = false);
			}

			if (!updating_mainDetailsToggle && dirty & /*mainDetailsToggle*/ 1) {
				updating_mainDetailsToggle = true;
				menudrawer_changes.mainDetailsToggle = /*mainDetailsToggle*/ ctx[0];
				add_flush_callback(() => updating_mainDetailsToggle = false);
			}

			menudrawer.$set(menudrawer_changes);
		},
		i(local) {
			if (current) return;
			transition_in(menudrawer.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(menudrawer.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(menudrawer, detaching);
		}
	};
}

let index$4 = 0;

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { header, mainDetailsToggle, borderOffset, breakpoint } = $$props;

	let openMenuDrawer = function (summaryElement) {
		$$invalidate(5, header = header || document.getElementById('shopify-section-header'));

		$$invalidate(6, borderOffset = borderOffset || header.querySelector('.header-wrapper').classList.contains('header-wrapper--border-bottom')
		? 1
		: 0);

		document.documentElement.style.setProperty('--header-bottom-position', `${parseInt(header.getBoundingClientRect().bottom - borderOffset)}px`);
		header.classList.add('menu-open');

		setTimeout(() => {
			mainDetailsToggle.classList.add('menu-opening');
		});

		summaryElement.setAttribute('aria-expanded', true);
		trapFocus(mainDetailsToggle, summaryElement);
		document.body.classList.add(`overflow-hidden-${breakpoint}`);
	};

	let closeMenuDrawer = function (event, elementToFocus) {
		this(event, elementToFocus);
		header.classList.remove('menu-open');
	};

	function menudrawer_closeMenuDrawer_binding(value) {
		closeMenuDrawer = value;
		$$invalidate(3, closeMenuDrawer);
	}

	function menudrawer_openMenuDrawer_binding(value) {
		openMenuDrawer = value;
		$$invalidate(2, openMenuDrawer);
	}

	function menudrawer_mainDetailsToggle_binding(value) {
		mainDetailsToggle = value;
		$$invalidate(0, mainDetailsToggle);
	}

	$$self.$$set = $$new_props => {
		$$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('lec' in $$new_props) $$invalidate(1, lec = $$new_props.lec);
		if ('header' in $$new_props) $$invalidate(5, header = $$new_props.header);
		if ('mainDetailsToggle' in $$new_props) $$invalidate(0, mainDetailsToggle = $$new_props.mainDetailsToggle);
		if ('borderOffset' in $$new_props) $$invalidate(6, borderOffset = $$new_props.borderOffset);
		if ('breakpoint' in $$new_props) $$invalidate(7, breakpoint = $$new_props.breakpoint);
		if ('$$scope' in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$props = exclude_internal_props($$props);

	return [
		mainDetailsToggle,
		lec,
		openMenuDrawer,
		closeMenuDrawer,
		$$props,
		header,
		borderOffset,
		breakpoint,
		slots,
		menudrawer_closeMenuDrawer_binding,
		menudrawer_openMenuDrawer_binding,
		menudrawer_mainDetailsToggle_binding,
		$$scope
	];
}

class Header_drawer extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
			lec: 1,
			header: 5,
			mainDetailsToggle: 0,
			borderOffset: 6,
			breakpoint: 7
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/sections/header/components/logo.liquivelte generated by Svelte v3.50.0 */

function create_else_block(ctx) {
	let span;
	let t_value = /*shop*/ ctx[0].name + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(span, "class", "h2");
		},
		m(target, anchor) {
			insert_hydration(target, span, anchor);
			append_hydration(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*shop*/ 1 && t_value !== (t_value = /*shop*/ ctx[0].name + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (18:0) {#if section.settings.logo != undefined }
function create_if_block$1(ctx) {
	let img;
	let img_src_value;
	let img_width_value;

	return {
		c() {
			img = element("img");
			this.h();
		},
		l(nodes) {
			img = claim_element(nodes, "IMG", {
				src: true,
				class: true,
				widths: true,
				height: true,
				width: true,
				alt: true
			});

			this.h();
		},
		h() {
			if (!src_url_equal(img.src, img_src_value = /*liquid*/ ctx[4].img_url(/*section*/ ctx[3].settings.logo, '500x'))) attr(img, "src", img_src_value);
			attr(img, "class", "header__heading-logo");
			attr(img, "widths", "50, 100, 150, 200, 250, 300, 400, 500");
			attr(img, "height", /*logo_height*/ ctx[1]);
			attr(img, "width", img_width_value = /*section*/ ctx[3].settings.logo_width);
			attr(img, "alt", /*logo_alt*/ ctx[2]);
		},
		m(target, anchor) {
			insert_hydration(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*section*/ 8 && !src_url_equal(img.src, img_src_value = /*liquid*/ ctx[4].img_url(/*section*/ ctx[3].settings.logo, '500x'))) {
				attr(img, "src", img_src_value);
			}

			if (dirty & /*logo_height*/ 2) {
				attr(img, "height", /*logo_height*/ ctx[1]);
			}

			if (dirty & /*section*/ 8 && img_width_value !== (img_width_value = /*section*/ ctx[3].settings.logo_width)) {
				attr(img, "width", img_width_value);
			}

			if (dirty & /*logo_alt*/ 4) {
				attr(img, "alt", /*logo_alt*/ ctx[2]);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

function create_fragment$2(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*section*/ ctx[3].settings.logo != undefined) return create_if_block$1;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert_hydration(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

let index$3 = 0;

function instance$2($$self, $$props, $$invalidate) {
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	const section = {};
	let { section$settings } = $$props;
	section.settings = section$settings;
	let { shop } = $$props;
	let { logo_height } = $$props;
	let { logo_alt } = $$props;
	console.log('??? section settings ', section.settings, section.settings.logo != '');

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(5, lec = $$props.lec);
		if ('section$settings' in $$props) $$invalidate(6, section$settings = $$props.section$settings);
		if ('shop' in $$props) $$invalidate(0, shop = $$props.shop);
		if ('logo_height' in $$props) $$invalidate(1, logo_height = $$props.logo_height);
		if ('logo_alt' in $$props) $$invalidate(2, logo_alt = $$props.logo_alt);
	};

	return [shop, logo_height, logo_alt, section, liquid, lec, section$settings];
}

class Logo extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			lec: 5,
			section$settings: 6,
			shop: 0,
			logo_height: 1,
			logo_alt: 2
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/snippets/details-modal.liquivelte generated by Svelte v3.50.0 */

function create_fragment$1(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", /*classes*/ ctx[0]);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[5](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*classes*/ 1) {
				attr(div, "class", /*classes*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[5](null);
		}
	};
}

let index$2 = 0;

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { classes = '' } = $$props;
	let container, detailsContainer, summaryToggle;

	onMount(() => {
		detailsContainer = container.querySelector('details');
		summaryToggle = container.querySelector('summary');
		detailsContainer.addEventListener('keyup', event => event.code.toUpperCase() === 'ESCAPE' && close());
		summaryToggle.addEventListener('click', onSummaryClick.bind(this));
		container.querySelector('button[type="button"]').addEventListener('click', close.bind(this));
		summaryToggle.setAttribute('role', 'button');
	});

	function isOpen() {
		return detailsContainer.hasAttribute('open');
	}

	function onSummaryClick(event) {
		event.preventDefault();

		event.target.closest('details').hasAttribute('open')
		? close()
		: open(event);
	}

	function onBodyClick(event) {
		if (!container.contains(event.target) || event.target.classList.contains('modal-overlay')) close(false);
	}

	function open(event) {
		onBodyClickEvent = onBodyClickEvent || onBodyClick.bind(this);
		event.target.closest('details').setAttribute('open', true);
		document.body.addEventListener('click', onBodyClickEvent);
		document.body.classList.add('overflow-hidden');
		trapFocus(detailsContainer.querySelector('[tabindex="-1"]'), detailsContainer.querySelector('input:not([type="hidden"])'));
	}

	function close(focusToggle = true) {
		removeTrapFocus(focusToggle ? summaryToggle : null);
		detailsContainer.removeAttribute('open');
		document.body.removeEventListener('click', onBodyClickEvent);
		document.body.classList.remove('overflow-hidden');
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			container = $$value;
			$$invalidate(1, container);
		});
	}

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(2, lec = $$props.lec);
		if ('classes' in $$props) $$invalidate(0, classes = $$props.classes);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [classes, container, lec, $$scope, slots, div_binding];
}

class Details_modal extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { lec: 2, classes: 0 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/sections/header/index.liquivelte generated by Svelte v3.50.0 */

function create_default_slot_10(ctx) {
	let t;

	return {
		c() {
			t = text("Left panel content");
		},
		l(nodes) {
			t = claim_text(nodes, "Left panel content");
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (7731:6) <Page>
function create_default_slot_9(ctx) {
	let block;
	let current;

	block = new Block({
			props: {
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(block.$$.fragment);
		},
		l(nodes) {
			claim_component(block.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(block, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const block_changes = {};

			if (dirty & /*$$scope*/ 2097152) {
				block_changes.$$scope = { dirty, ctx };
			}

			block.$set(block_changes);
		},
		i(local) {
			if (current) return;
			transition_in(block.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(block.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(block, detaching);
		}
	};
}

// (7730:4) <View>
function create_default_slot_8(ctx) {
	let page;
	let current;

	page = new Page({
			props: {
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(page.$$.fragment);
		},
		l(nodes) {
			claim_component(page.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(page, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const page_changes = {};

			if (dirty & /*$$scope*/ 2097152) {
				page_changes.$$scope = { dirty, ctx };
			}

			page.$set(page_changes);
		},
		i(local) {
			if (current) return;
			transition_in(page.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(page.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(page, detaching);
		}
	};
}

// (7729:2) <Panel resizable left reveal swipeOnlyClose="{true}"  >
function create_default_slot_7(ctx) {
	let view;
	let current;

	view = new View({
			props: {
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(view.$$.fragment);
		},
		l(nodes) {
			claim_component(view.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(view, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const view_changes = {};

			if (dirty & /*$$scope*/ 2097152) {
				view_changes.$$scope = { dirty, ctx };
			}

			view.$set(view_changes);
		},
		i(local) {
			if (current) return;
			transition_in(view.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(view.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(view, detaching);
		}
	};
}

// (7739:8) <Block>
function create_default_slot_6(ctx) {
	let t;

	return {
		c() {
			t = text("Right panel content");
		},
		l(nodes) {
			t = claim_text(nodes, "Right panel content");
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (7738:6) <Page>
function create_default_slot_5(ctx) {
	let block;
	let current;

	block = new Block({
			props: {
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(block.$$.fragment);
		},
		l(nodes) {
			claim_component(block.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(block, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const block_changes = {};

			if (dirty & /*$$scope*/ 2097152) {
				block_changes.$$scope = { dirty, ctx };
			}

			block.$set(block_changes);
		},
		i(local) {
			if (current) return;
			transition_in(block.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(block.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(block, detaching);
		}
	};
}

// (7737:4) <View>
function create_default_slot_4(ctx) {
	let page;
	let current;

	page = new Page({
			props: {
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(page.$$.fragment);
		},
		l(nodes) {
			claim_component(page.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(page, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const page_changes = {};

			if (dirty & /*$$scope*/ 2097152) {
				page_changes.$$scope = { dirty, ctx };
			}

			page.$set(page_changes);
		},
		i(local) {
			if (current) return;
			transition_in(page.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(page.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(page, detaching);
		}
	};
}

// (7736:2) <Panel resizable right reveal swipeOnlyClose="{true}"  >
function create_default_slot_3(ctx) {
	let view;
	let current;

	view = new View({
			props: {
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(view.$$.fragment);
		},
		l(nodes) {
			claim_component(view.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(view, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const view_changes = {};

			if (dirty & /*$$scope*/ 2097152) {
				view_changes.$$scope = { dirty, ctx };
			}

			view.$set(view_changes);
		},
		i(local) {
			if (current) return;
			transition_in(view.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(view.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(view, detaching);
		}
	};
}

// (7746:8) <Button small panelToggle="left" class="display-flex" >
function create_default_slot_2(ctx) {
	let html_tag;
	let raw_value = /*rawinclude_05cf2ddf*/ ctx[2][index || 0] + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTagHydration(false);
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_tag = claim_html_tag(nodes, false);
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_hydration(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*rawinclude_05cf2ddf*/ 4 && raw_value !== (raw_value = /*rawinclude_05cf2ddf*/ ctx[2][index || 0] + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (7754:8) <Button small panelToggle="right" class="display-flex" >
function create_default_slot_1(ctx) {
	let html_tag;
	let raw_value = /*rawinclude_5577f5b4*/ ctx[3][index || 0] + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTagHydration(false);
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_tag = claim_html_tag(nodes, false);
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_hydration(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*rawinclude_5577f5b4*/ 8 && raw_value !== (raw_value = /*rawinclude_5577f5b4*/ ctx[3][index || 0] + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (7744:4) <Appbar>
function create_default_slot(ctx) {
	let div0;
	let button0;
	let t0;
	let div1;
	let logo;
	let t1;
	let div2;
	let button1;
	let current;

	button0 = new Button({
			props: {
				small: true,
				panelToggle: "left",
				class: "display-flex",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	logo = new Logo({
			props: {
				shop: /*shop*/ ctx[0],
				logo_height: /*logo_height*/ ctx[8],
				logo_alt: /*logo_alt*/ ctx[7],
				cart: /*cart*/ ctx[9],
				menu_json: /*menu_json*/ ctx[12],
				settings: /*settings*/ ctx[13],
				logo_html: /*logo_html*/ ctx[14],
				routes: /*routes*/ ctx[15],
				request: /*request*/ ctx[16],
				account_url: /*account_url*/ ctx[17],
				account_text: /*account_text*/ ctx[18],
				section$settings: /*section$settings*/ ctx[11],
				shop$name: /*shop$name*/ ctx[10],
				rawinclude_05cf2ddf: /*rawinclude_05cf2ddf*/ ctx[2],
				rawinclude_5577f5b4: /*rawinclude_5577f5b4*/ ctx[3],
				rawinclude_679e0e24: /*rawinclude_679e0e24*/ ctx[4],
				rawinclude_3be65912: /*rawinclude_3be65912*/ ctx[5],
				rawinclude_602baf9d: /*rawinclude_602baf9d*/ ctx[6],
				lec: /*lec*/ ctx[1]
			}
		});

	button1 = new Button({
			props: {
				small: true,
				panelToggle: "right",
				class: "display-flex",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div0 = element("div");
			create_component(button0.$$.fragment);
			t0 = space();
			div1 = element("div");
			create_component(logo.$$.fragment);
			t1 = space();
			div2 = element("div");
			create_component(button1.$$.fragment);
			this.h();
		},
		l(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(button0.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach);
			t0 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(logo.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach);
			t1 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			claim_component(button1.$$.fragment, div2_nodes);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "left");
			attr(div1, "class", "center");
			attr(div2, "class", "left");
		},
		m(target, anchor) {
			insert_hydration(target, div0, anchor);
			mount_component(button0, div0, null);
			insert_hydration(target, t0, anchor);
			insert_hydration(target, div1, anchor);
			mount_component(logo, div1, null);
			insert_hydration(target, t1, anchor);
			insert_hydration(target, div2, anchor);
			mount_component(button1, div2, null);
			current = true;
		},
		p(ctx, dirty) {
			const button0_changes = {};

			if (dirty & /*$$scope, rawinclude_05cf2ddf*/ 2097156) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const logo_changes = {};
			if (dirty & /*shop*/ 1) logo_changes.shop = /*shop*/ ctx[0];
			if (dirty & /*logo_height*/ 256) logo_changes.logo_height = /*logo_height*/ ctx[8];
			if (dirty & /*logo_alt*/ 128) logo_changes.logo_alt = /*logo_alt*/ ctx[7];
			if (dirty & /*cart*/ 512) logo_changes.cart = /*cart*/ ctx[9];
			if (dirty & /*menu_json*/ 4096) logo_changes.menu_json = /*menu_json*/ ctx[12];
			if (dirty & /*settings*/ 8192) logo_changes.settings = /*settings*/ ctx[13];
			if (dirty & /*logo_html*/ 16384) logo_changes.logo_html = /*logo_html*/ ctx[14];
			if (dirty & /*routes*/ 32768) logo_changes.routes = /*routes*/ ctx[15];
			if (dirty & /*request*/ 65536) logo_changes.request = /*request*/ ctx[16];
			if (dirty & /*account_url*/ 131072) logo_changes.account_url = /*account_url*/ ctx[17];
			if (dirty & /*account_text*/ 262144) logo_changes.account_text = /*account_text*/ ctx[18];
			if (dirty & /*section$settings*/ 2048) logo_changes.section$settings = /*section$settings*/ ctx[11];
			if (dirty & /*shop$name*/ 1024) logo_changes.shop$name = /*shop$name*/ ctx[10];
			if (dirty & /*rawinclude_05cf2ddf*/ 4) logo_changes.rawinclude_05cf2ddf = /*rawinclude_05cf2ddf*/ ctx[2];
			if (dirty & /*rawinclude_5577f5b4*/ 8) logo_changes.rawinclude_5577f5b4 = /*rawinclude_5577f5b4*/ ctx[3];
			if (dirty & /*rawinclude_679e0e24*/ 16) logo_changes.rawinclude_679e0e24 = /*rawinclude_679e0e24*/ ctx[4];
			if (dirty & /*rawinclude_3be65912*/ 32) logo_changes.rawinclude_3be65912 = /*rawinclude_3be65912*/ ctx[5];
			if (dirty & /*rawinclude_602baf9d*/ 64) logo_changes.rawinclude_602baf9d = /*rawinclude_602baf9d*/ ctx[6];
			if (dirty & /*lec*/ 2) logo_changes.lec = /*lec*/ ctx[1];
			logo.$set(logo_changes);
			const button1_changes = {};

			if (dirty & /*$$scope, rawinclude_5577f5b4*/ 2097160) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(logo.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(logo.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			destroy_component(button0);
			if (detaching) detach(t0);
			if (detaching) detach(div1);
			destroy_component(logo);
			if (detaching) detach(t1);
			if (detaching) detach(div2);
			destroy_component(button1);
		}
	};
}

// (7761:0) {#if settings.cart_type == "notification" }
function create_if_block_1(ctx) {
	let html_tag;
	let raw_value = /*rawinclude_679e0e24*/ ctx[4][index || 0] + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTagHydration(false);
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_tag = claim_html_tag(nodes, false);
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_hydration(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*rawinclude_679e0e24*/ 16 && raw_value !== (raw_value = /*rawinclude_679e0e24*/ ctx[4][index || 0] + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (7767:0) {#if request.page_type == 'index' }
function create_if_block(ctx) {
	let html_tag;
	let raw_value = /*rawinclude_602baf9d*/ ctx[6][index || 0] + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTagHydration(false);
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_tag = claim_html_tag(nodes, false);
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_hydration(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*rawinclude_602baf9d*/ 64 && raw_value !== (raw_value = /*rawinclude_602baf9d*/ ctx[6][index || 0] + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

function create_fragment(ctx) {
	let svg;
	let symbol0;
	let path0;
	let symbol1;
	let path1;
	let t0;
	let panel0;
	let t1;
	let panel1;
	let t2;
	let header;
	let appbar;
	let t3;
	let t4;
	let html_tag;
	let raw_value = /*rawinclude_3be65912*/ ctx[5][index || 0] + "";
	let t5;
	let if_block1_anchor;
	let current;

	panel0 = new Panel({
			props: {
				resizable: true,
				left: true,
				reveal: true,
				swipeOnlyClose: true,
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			}
		});

	panel1 = new Panel({
			props: {
				resizable: true,
				right: true,
				reveal: true,
				swipeOnlyClose: true,
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	appbar = new Appbar({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	let if_block0 = /*settings*/ ctx[13].cart_type == "notification" && create_if_block_1(ctx);
	let if_block1 = /*request*/ ctx[16].page_type == 'index' && create_if_block(ctx);

	return {
		c() {
			svg = svg_element("svg");
			symbol0 = svg_element("symbol");
			path0 = svg_element("path");
			symbol1 = svg_element("symbol");
			path1 = svg_element("path");
			t0 = space();
			create_component(panel0.$$.fragment);
			t1 = space();
			create_component(panel1.$$.fragment);
			t2 = space();
			header = element("header");
			create_component(appbar.$$.fragment);
			t3 = space();
			if (if_block0) if_block0.c();
			t4 = space();
			html_tag = new HtmlTagHydration(false);
			t5 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			this.h();
		},
		l(nodes) {
			svg = claim_svg_element(nodes, "svg", { xmlns: true, class: true });
			var svg_nodes = children(svg);
			symbol0 = claim_svg_element(svg_nodes, "symbol", { id: true, viewBox: true, fill: true });
			var symbol0_nodes = children(symbol0);

			path0 = claim_svg_element(symbol0_nodes, "path", {
				"fill-rule": true,
				"clip-rule": true,
				d: true,
				fill: true
			});

			children(path0).forEach(detach);
			symbol0_nodes.forEach(detach);

			symbol1 = claim_svg_element(svg_nodes, "symbol", {
				id: true,
				class: true,
				fill: true,
				viewBox: true
			});

			var symbol1_nodes = children(symbol1);
			path1 = claim_svg_element(symbol1_nodes, "path", { d: true, fill: true });
			var path1_nodes = children(path1);
			path1_nodes.forEach(detach);
			symbol1_nodes.forEach(detach);
			svg_nodes.forEach(detach);
			t0 = claim_space(nodes);
			claim_component(panel0.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(panel1.$$.fragment, nodes);
			t2 = claim_space(nodes);
			header = claim_element(nodes, "HEADER", {});
			var header_nodes = children(header);
			claim_component(appbar.$$.fragment, header_nodes);
			header_nodes.forEach(detach);
			t3 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t4 = claim_space(nodes);
			html_tag = claim_html_tag(nodes, false);
			t5 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
			this.h();
		},
		h() {
			attr(path0, "fill-rule", "evenodd");
			attr(path0, "clip-rule", "evenodd");
			attr(path0, "d", "M11.03 11.68A5.784 5.784 0 112.85 3.5a5.784 5.784 0 018.18 8.18zm.26 1.12a6.78 6.78 0 11.72-.7l5.4 5.4a.5.5 0 11-.71.7l-5.41-5.4z");
			attr(path0, "fill", "currentColor");
			attr(symbol0, "id", "icon-search");
			attr(symbol0, "viewBox", "0 0 18 19");
			attr(symbol0, "fill", "none");
			attr(path1, "d", "M.865 15.978a.5.5 0 00.707.707l7.433-7.431 7.579 7.282a.501.501 0 00.846-.37.5.5 0 00-.153-.351L9.712 8.546l7.417-7.416a.5.5 0 10-.707-.708L8.991 7.853 1.413.573a.5.5 0 10-.693.72l7.563 7.268-7.418 7.417z");
			attr(path1, "fill", "currentColor");
			attr(symbol1, "id", "icon-close");
			attr(symbol1, "class", "icon icon-close");
			attr(symbol1, "fill", "none");
			attr(symbol1, "viewBox", "0 0 18 17");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "hidden");
			html_tag.a = t5;
		},
		m(target, anchor) {
			insert_hydration(target, svg, anchor);
			append_hydration(svg, symbol0);
			append_hydration(symbol0, path0);
			append_hydration(svg, symbol1);
			append_hydration(symbol1, path1);
			insert_hydration(target, t0, anchor);
			mount_component(panel0, target, anchor);
			insert_hydration(target, t1, anchor);
			mount_component(panel1, target, anchor);
			insert_hydration(target, t2, anchor);
			insert_hydration(target, header, anchor);
			mount_component(appbar, header, null);
			insert_hydration(target, t3, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration(target, t4, anchor);
			html_tag.m(raw_value, target, anchor);
			insert_hydration(target, t5, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const panel0_changes = {};

			if (dirty & /*$$scope*/ 2097152) {
				panel0_changes.$$scope = { dirty, ctx };
			}

			panel0.$set(panel0_changes);
			const panel1_changes = {};

			if (dirty & /*$$scope*/ 2097152) {
				panel1_changes.$$scope = { dirty, ctx };
			}

			panel1.$set(panel1_changes);
			const appbar_changes = {};

			if (dirty & /*$$scope, rawinclude_5577f5b4, shop, logo_height, logo_alt, cart, menu_json, settings, logo_html, routes, request, account_url, account_text, section$settings, shop$name, rawinclude_05cf2ddf, rawinclude_679e0e24, rawinclude_3be65912, rawinclude_602baf9d, lec*/ 2621439) {
				appbar_changes.$$scope = { dirty, ctx };
			}

			appbar.$set(appbar_changes);

			if (/*settings*/ ctx[13].cart_type == "notification") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(t4.parentNode, t4);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if ((!current || dirty & /*rawinclude_3be65912*/ 32) && raw_value !== (raw_value = /*rawinclude_3be65912*/ ctx[5][index || 0] + "")) html_tag.p(raw_value);

			if (/*request*/ ctx[16].page_type == 'index') {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(panel0.$$.fragment, local);
			transition_in(panel1.$$.fragment, local);
			transition_in(appbar.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(panel0.$$.fragment, local);
			transition_out(panel1.$$.fragment, local);
			transition_out(appbar.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svg);
			if (detaching) detach(t0);
			destroy_component(panel0, detaching);
			if (detaching) detach(t1);
			destroy_component(panel1, detaching);
			if (detaching) detach(t2);
			if (detaching) detach(header);
			destroy_component(appbar);
			if (detaching) detach(t3);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t4);
			if (detaching) html_tag.d();
			if (detaching) detach(t5);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

let index = 0;

function instance($$self, $$props, $$invalidate) {
	let { lec } = $$props;
	const liquid = cachedLiquid(lec);
	let { rawinclude_05cf2ddf } = $$props;
	let { rawinclude_5577f5b4 } = $$props;
	let { rawinclude_679e0e24 } = $$props;
	let { rawinclude_3be65912 } = $$props;
	let { rawinclude_602baf9d } = $$props;
	let { logo_alt } = $$props;
	let { logo_height } = $$props;
	let { cart } = $$props;
	let { shop } = $$props;
	let { shop$name } = $$props;
	shop.name = shop$name;
	const section = {};
	let { section$settings } = $$props;
	section.settings = section$settings;
	let { menu_json } = $$props;
	section.settings.menu = JSON.parse(menu_json);
	let { settings } = $$props;
	let { logo_html } = $$props;
	console.log('settings ', settings);
	let { routes } = $$props;
	let { request } = $$props;
	let { account_url } = $$props;
	let { account_text } = $$props;
	console.log('section header ', section);
	console.log('section.settings.menu ', section.settings.menu);

	$$self.$$set = $$props => {
		if ('lec' in $$props) $$invalidate(1, lec = $$props.lec);
		if ('rawinclude_05cf2ddf' in $$props) $$invalidate(2, rawinclude_05cf2ddf = $$props.rawinclude_05cf2ddf);
		if ('rawinclude_5577f5b4' in $$props) $$invalidate(3, rawinclude_5577f5b4 = $$props.rawinclude_5577f5b4);
		if ('rawinclude_679e0e24' in $$props) $$invalidate(4, rawinclude_679e0e24 = $$props.rawinclude_679e0e24);
		if ('rawinclude_3be65912' in $$props) $$invalidate(5, rawinclude_3be65912 = $$props.rawinclude_3be65912);
		if ('rawinclude_602baf9d' in $$props) $$invalidate(6, rawinclude_602baf9d = $$props.rawinclude_602baf9d);
		if ('logo_alt' in $$props) $$invalidate(7, logo_alt = $$props.logo_alt);
		if ('logo_height' in $$props) $$invalidate(8, logo_height = $$props.logo_height);
		if ('cart' in $$props) $$invalidate(9, cart = $$props.cart);
		if ('shop' in $$props) $$invalidate(0, shop = $$props.shop);
		if ('shop$name' in $$props) $$invalidate(10, shop$name = $$props.shop$name);
		if ('section$settings' in $$props) $$invalidate(11, section$settings = $$props.section$settings);
		if ('menu_json' in $$props) $$invalidate(12, menu_json = $$props.menu_json);
		if ('settings' in $$props) $$invalidate(13, settings = $$props.settings);
		if ('logo_html' in $$props) $$invalidate(14, logo_html = $$props.logo_html);
		if ('routes' in $$props) $$invalidate(15, routes = $$props.routes);
		if ('request' in $$props) $$invalidate(16, request = $$props.request);
		if ('account_url' in $$props) $$invalidate(17, account_url = $$props.account_url);
		if ('account_text' in $$props) $$invalidate(18, account_text = $$props.account_text);
	};

	return [
		shop,
		lec,
		rawinclude_05cf2ddf,
		rawinclude_5577f5b4,
		rawinclude_679e0e24,
		rawinclude_3be65912,
		rawinclude_602baf9d,
		logo_alt,
		logo_height,
		cart,
		shop$name,
		section$settings,
		menu_json,
		settings,
		logo_html,
		routes,
		request,
		account_url,
		account_text
	];
}

class Header extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			lec: 1,
			rawinclude_05cf2ddf: 2,
			rawinclude_5577f5b4: 3,
			rawinclude_679e0e24: 4,
			rawinclude_3be65912: 5,
			rawinclude_602baf9d: 6,
			logo_alt: 7,
			logo_height: 8,
			cart: 9,
			shop: 0,
			shop$name: 10,
			section$settings: 11,
			menu_json: 12,
			settings: 13,
			logo_html: 14,
			routes: 15,
			request: 16,
			account_url: 17,
			account_text: 18
		});
	}
}

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': Header
});

export { App, Framework7Svelte, Header, Page, View, addToCart, disableScrollOnBody, enableScrollOnBody, f7, f7ready, index$1 as index };
