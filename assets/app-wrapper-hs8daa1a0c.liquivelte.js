import { SvelteComponent, init, safe_not_equal, create_component, claim_component, mount_component, transition_in, transition_out, destroy_component, getContext, beforeUpdate, create_slot, element, space, claim_element, children, detach, claim_space, attr, insert_hydration, append_hydration, action_destroyer, update_slot_base, get_all_dirty_from_scope, get_slot_changes, run_all } from './liquivelte-svelte-hs532e1aa9.liquivelte.js';
import './framework7-liquivelte-hsa0091f48.liquivelte.js';
import { View } from './framework7-liquivelte-view-hs8daa1a0c.liquivelte.js';
import { App } from './framework7-liquivelte-app-hs8daa1a0c.liquivelte.js';
import { Page } from './framework7-liquivelte-page-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-get-params-hs6b273664.liquivelte.js';
import './framework7-liquivelte-popup-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-login-screen-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-sheet-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-popover-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-panel-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-router-context-provider-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-routable-modals-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-page-content-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-preloader-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-utils-hs8daa1a0c.liquivelte.js';
import './framework7-liquivelte-params-list-hs8daa1a0c.liquivelte.js';

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/snippets/app-wrapper.liquivelte generated by Svelte v3.50.0 */
const get_footer_slot_changes = dirty => ({});
const get_footer_slot_context = ctx => ({});
const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});

// (7763:4) <Page  name="main" >
function create_default_slot_2(ctx) {
	let div1;
	let div0;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", {});
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { liveslot: true });
			var div0_nodes = children(div0);
			if (default_slot) default_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "liveslot", "main");
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);
			append_hydration(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;

			if (!mounted) {
				dispose = action_destroyer(/*persistingchild*/ ctx[1].call(null, div1, "main"));
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

// (7762:2) <View  main classes="mainview" browserHistoryInitialMatch="{true}" loadInitialPage="{false}" data-url="{ request.path }" browserHistory="{true}" browserHistorySeparator="{""}" >
function create_default_slot_1(ctx) {
	let page;
	let current;

	page = new Page({
			props: {
				name: "main",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(page.$$.fragment);
		},
		l(nodes) {
			claim_component(page.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(page, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const page_changes = {};

			if (dirty & /*$$scope*/ 16) {
				page_changes.$$scope = { dirty, ctx };
			}

			page.$set(page_changes);
		},
		i(local) {
			if (current) return;
			transition_in(page.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(page.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(page, detaching);
		}
	};
}

// (7756:0) <App  theme="ios" name="My App" id="com.demoapp.test" routes="{routes}" viewMainClass="mainview" >
function create_default_slot(ctx) {
	let div1;
	let div0;
	let t0;
	let view;
	let t1;
	let div3;
	let div2;
	let current;
	let mounted;
	let dispose;
	const header_slot_template = /*#slots*/ ctx[3].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[4], get_header_slot_context);

	view = new View({
			props: {
				main: true,
				classes: "mainview",
				browserHistoryInitialMatch: true,
				loadInitialPage: false,
				"data-url": /*request*/ ctx[0].path,
				browserHistory: true,
				browserHistorySeparator: "",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	const footer_slot_template = /*#slots*/ ctx[3].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[4], get_footer_slot_context);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (header_slot) header_slot.c();
			t0 = space();
			create_component(view.$$.fragment);
			t1 = space();
			div3 = element("div");
			div2 = element("div");
			if (footer_slot) footer_slot.c();
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", {});
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { liveslot: true });
			var div0_nodes = children(div0);
			if (header_slot) header_slot.l(div0_nodes);
			div0_nodes.forEach(detach);
			div1_nodes.forEach(detach);
			t0 = claim_space(nodes);
			claim_component(view.$$.fragment, nodes);
			t1 = claim_space(nodes);
			div3 = claim_element(nodes, "DIV", {});
			var div3_nodes = children(div3);
			div2 = claim_element(div3_nodes, "DIV", { liveslot: true });
			var div2_nodes = children(div2);
			if (footer_slot) footer_slot.l(div2_nodes);
			div2_nodes.forEach(detach);
			div3_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "liveslot", "header");
			attr(div2, "liveslot", "footer");
		},
		m(target, anchor) {
			insert_hydration(target, div1, anchor);
			append_hydration(div1, div0);

			if (header_slot) {
				header_slot.m(div0, null);
			}

			insert_hydration(target, t0, anchor);
			mount_component(view, target, anchor);
			insert_hydration(target, t1, anchor);
			insert_hydration(target, div3, anchor);
			append_hydration(div3, div2);

			if (footer_slot) {
				footer_slot.m(div2, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(/*persistingchild*/ ctx[1].call(null, div1, "header")),
					action_destroyer(/*persistingchild*/ ctx[1].call(null, div3, "footer"))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[4], dirty, get_header_slot_changes),
						get_header_slot_context
					);
				}
			}

			const view_changes = {};
			if (dirty & /*request*/ 1) view_changes["data-url"] = /*request*/ ctx[0].path;

			if (dirty & /*$$scope*/ 16) {
				view_changes.$$scope = { dirty, ctx };
			}

			view.$set(view_changes);

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[4], dirty, get_footer_slot_changes),
						get_footer_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot, local);
			transition_in(view.$$.fragment, local);
			transition_in(footer_slot, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot, local);
			transition_out(view.$$.fragment, local);
			transition_out(footer_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (header_slot) header_slot.d(detaching);
			if (detaching) detach(t0);
			destroy_component(view, detaching);
			if (detaching) detach(t1);
			if (detaching) detach(div3);
			if (footer_slot) footer_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment(ctx) {
	let app;
	let current;

	app = new App({
			props: {
				theme: "ios",
				name: "My App",
				id: "com.demoapp.test",
				routes: /*routes*/ ctx[2],
				viewMainClass: "mainview",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(app.$$.fragment);
		},
		l(nodes) {
			claim_component(app.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(app, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const app_changes = {};

			if (dirty & /*$$scope, request*/ 17) {
				app_changes.$$scope = { dirty, ctx };
			}

			app.$set(app_changes);
		},
		i(local) {
			if (current) return;
			transition_in(app.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(app.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(app, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let themeImports = getContext('svelteProps') || {};
	getContext('lec') || {};

	// import { Workbox } from 'workbox-window';
	const request = {};

	request.path = themeImports['requestƒƒpath'];
	console.log('request ', request);
	let live_slot_cache = new Map();
	let firstRun = true;

	beforeUpdate(() => {
		if (firstRun) {
			firstRun = false;

			[...document.querySelectorAll('[liveslot]')].forEach(element => {
				if (!live_slot_cache.has(element.getAttribute('liveslot'))) {
					live_slot_cache.set(element.getAttribute('liveslot'), element);

					if (element.isConnected) {
						element.parentNode.removeChild(element);
					}
				}
			});
		}

		// if(!live_slot_cache.has('[liveslot]')) {
		//   ls_cache = document.querySelector('.liveslot');
		// if(ls_cache.isConnected) { ls_cache.parentNode.removeChild(ls_cache); }
		// }
		console.log('oh shit, the wrapper component is about to update');

		return false;
	});

	function persistingchild(node, slotname) {
		if (node.children[0] !== live_slot_cache.get(slotname)) {
			node.replaceChild(live_slot_cache.get(slotname), node.children[0]);
		}
	}

	// onMount(() => {
	//   if ('serviceWorker' in navigator) {    
	//     const wb = new Workbox('/a/sw/Development%20(e34f7f-muhammets-air)/sw.js', {
	//       scope: '/'
	//     });
	//     wb.register();
	//   }
	// })
	const clientSideRouter = ({ app, to, resolve }, ...rest) => {
		const { path } = to;

		app.views.main.on('pageMounted', ({ pageEl }) => {
			Shopify.designMode = true;

			[...pageEl.querySelectorAll('[liquivelte-eval], .liquivelte-prop-script')].forEach(element => {
				window.propScriptForDesignMode = element;
				eval(element.textContent);
			});

			Shopify.designMode = false;
			document.dispatchEvent(new CustomEvent('view-loaded', { detail: { document: pageEl } }));
			app.views.main.router.updateCurrentUrl(path);
		}); // console.log('page mounted ', pageData);

		fetch(path).then(res => res.text()).then(async content => {
			const template = document.createElement('template');
			template.innerHTML = content;
			const fragment = template.content;
			const pageJS = fragment.querySelector('script[src*="liquivelte.js"]');
			const pageCSS = fragment.querySelector('link[href*="liquivelte.css"]');
			const JSsrc = new URL(pageJS.src).pathname;
			await import(JSsrc);
			document.head.appendChild(pageCSS);
			resolve({ content });
		});
	};

	const routes = [
		{
			path: '/(products|collections|pages)/:handle',
			async: clientSideRouter,
			options: { transition: 'f7-circle' }
		}
	];

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	return [request, persistingchild, routes, slots, $$scope];
}

class App_wrapper extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export { App_wrapper as default };
