import { SvelteComponent, init, safe_not_equal, assign, element, space, claim_element, children, detach, claim_space, attr, set_attributes, insert_hydration, append_hydration, listen, get_spread_update, noop, run_all, compute_rest_props, getContext, createEventDispatcher, onMount, onDestroy, exclude_internal_props, text, claim_text, set_data, binding_callbacks } from './liquivelte-svelte-hs532e1aa9.liquivelte.js';
import { cachedLiquid } from './liquivelte-liquid-hs8daa1a0c.liquivelte.js';
import { restProps, createEmitter, f7ready, app, noUndefinedProps, classNames, colorClasses } from './framework7-liquivelte-hsa0091f48.liquivelte.js';

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/node_modules/framework7-liquivelte/components/stepper.liquivelte generated by Svelte v3.50.0 */

function create_if_block_1(ctx) {
	let div;
	let input_1;
	let input_1_min_value;
	let input_1_max_value;
	let input_1_step_value;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			input_1 = element("input");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			input_1 = claim_element(div_nodes, "INPUT", {
				name: true,
				id: true,
				type: true,
				min: true,
				max: true,
				step: true
			});

			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(input_1, "name", /*name*/ ctx[5]);
			attr(input_1, "id", /*inputId*/ ctx[6]);
			attr(input_1, "type", /*inputType*/ ctx[8]);

			attr(input_1, "min", input_1_min_value = /*inputType*/ ctx[8] === 'number'
			? /*min*/ ctx[2]
			: undefined);

			attr(input_1, "max", input_1_max_value = /*inputType*/ ctx[8] === 'number'
			? /*max*/ ctx[3]
			: undefined);

			attr(input_1, "step", input_1_step_value = /*inputType*/ ctx[8] === 'number'
			? /*step*/ ctx[4]
			: undefined);

			input_1.value = /*value*/ ctx[0];
			input_1.readOnly = /*inputReadonly*/ ctx[9];
			attr(div, "class", "stepper-input-wrap");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, input_1);

			if (!mounted) {
				dispose = [
					listen(input_1, "input", /*onInput*/ ctx[14]),
					listen(input_1, "change", /*onChange*/ ctx[15])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*name*/ 32) {
				attr(input_1, "name", /*name*/ ctx[5]);
			}

			if (dirty[0] & /*inputId*/ 64) {
				attr(input_1, "id", /*inputId*/ ctx[6]);
			}

			if (dirty[0] & /*inputType*/ 256) {
				attr(input_1, "type", /*inputType*/ ctx[8]);
			}

			if (dirty[0] & /*inputType, min*/ 260 && input_1_min_value !== (input_1_min_value = /*inputType*/ ctx[8] === 'number'
			? /*min*/ ctx[2]
			: undefined)) {
				attr(input_1, "min", input_1_min_value);
			}

			if (dirty[0] & /*inputType, max*/ 264 && input_1_max_value !== (input_1_max_value = /*inputType*/ ctx[8] === 'number'
			? /*max*/ ctx[3]
			: undefined)) {
				attr(input_1, "max", input_1_max_value);
			}

			if (dirty[0] & /*inputType, step*/ 272 && input_1_step_value !== (input_1_step_value = /*inputType*/ ctx[8] === 'number'
			? /*step*/ ctx[4]
			: undefined)) {
				attr(input_1, "step", input_1_step_value);
			}

			if (dirty[0] & /*value*/ 1 && input_1.value !== /*value*/ ctx[0]) {
				input_1.value = /*value*/ ctx[0];
			}

			if (dirty[0] & /*inputReadonly*/ 512) {
				input_1.readOnly = /*inputReadonly*/ ctx[9];
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (175:2) {#if !(input || buttonsOnly )}
function create_if_block(ctx) {
	let div;
	let t_value = /*liquid*/ ctx[13].default(/*value*/ ctx[0], '') + "";
	let t;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "stepper-value");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			append_hydration(div, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*value*/ 1 && t_value !== (t_value = /*liquid*/ ctx[13].default(/*value*/ ctx[0], '') + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment(ctx) {
	let div2;
	let div0;
	let t0;
	let t1;
	let t2;
	let div1;
	let div2_class_value;
	let mounted;
	let dispose;
	let if_block0 = /*input*/ ctx[7] && /*buttonsOnly*/ ctx[10] != true && create_if_block_1(ctx);
	let if_block1 = !(/*input*/ ctx[7] || /*buttonsOnly*/ ctx[10]) && create_if_block(ctx);

	let div2_levels = [
		{
			class: div2_class_value = "stepper " + /*classes*/ ctx[1] + " " + /*computedClasses*/ ctx[11]
		},
		restProps(/*$$restProps*/ ctx[18])
	];

	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div1 = element("div");
			this.h();
		},
		l(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			children(div0).forEach(detach);
			t0 = claim_space(div2_nodes);
			if (if_block0) if_block0.l(div2_nodes);
			t1 = claim_space(div2_nodes);
			if (if_block1) if_block1.l(div2_nodes);
			t2 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			children(div1).forEach(detach);
			div2_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div0, "class", "stepper-button-minus");
			attr(div1, "class", "stepper-button-plus");
			set_attributes(div2, div2_data);
		},
		m(target, anchor) {
			insert_hydration(target, div2, anchor);
			append_hydration(div2, div0);
			append_hydration(div2, t0);
			if (if_block0) if_block0.m(div2, null);
			append_hydration(div2, t1);
			if (if_block1) if_block1.m(div2, null);
			append_hydration(div2, t2);
			append_hydration(div2, div1);
			/*div2_binding*/ ctx[49](div2);

			if (!mounted) {
				dispose = [
					listen(div0, "click", /*onMinusClick*/ ctx[16]),
					listen(div1, "click", /*onPlusClick*/ ctx[17])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*input*/ ctx[7] && /*buttonsOnly*/ ctx[10] != true) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(div2, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!(/*input*/ ctx[7] || /*buttonsOnly*/ ctx[10])) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(div2, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				dirty[0] & /*classes, computedClasses*/ 2050 && div2_class_value !== (div2_class_value = "stepper " + /*classes*/ ctx[1] + " " + /*computedClasses*/ ctx[11]) && { class: div2_class_value },
				dirty[0] & /*$$restProps*/ 262144 && restProps(/*$$restProps*/ ctx[18])
			]));
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			/*div2_binding*/ ctx[49](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance_1($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"classes","init","value","min","max","step","formatValue","name","inputId","input","inputType","inputReadonly","autorepeat","autorepeatDynamic","wraps","manualInputMode","decimalPoint","buttonsEndInputMode","disabled","buttonsOnly","round","roundMd","roundIos","roundAurora","fill","fillMd","fillIos","fillAurora","large","largeMd","largeIos","largeAurora","small","smallMd","smallIos","smallAurora","raised","raisedMd","raisedIos","raisedAurora","instance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	getContext('svelteProps') || {};
	let lec = getContext('lec') || {};
	const liquid = cachedLiquid(lec);
	const emit = createEmitter(createEventDispatcher, $$props);
	let computedClasses = undefined;
	let { classes = '' } = $$props;
	let { init = true } = $$props;
	let { value = 0 } = $$props;
	let { min = 0 } = $$props;
	let { max = 100 } = $$props;
	let { step = 1 } = $$props;
	let { formatValue = undefined } = $$props;
	let { name = undefined } = $$props;
	let { inputId = undefined } = $$props;
	let { input = true } = $$props;
	let { inputType = 'text' } = $$props;
	let { inputReadonly = false } = $$props;
	let { autorepeat = false } = $$props;
	let { autorepeatDynamic = false } = $$props;
	let { wraps = false } = $$props;
	let { manualInputMode = false } = $$props;
	let { decimalPoint = 4 } = $$props;
	let { buttonsEndInputMode = true } = $$props;
	let { disabled = undefined } = $$props;
	let { buttonsOnly = undefined } = $$props;
	let { round = false } = $$props;
	let { roundMd = false } = $$props;
	let { roundIos = false } = $$props;
	let { roundAurora = false } = $$props;
	let { fill = false } = $$props;
	let { fillMd = false } = $$props;
	let { fillIos = false } = $$props;
	let { fillAurora = false } = $$props;
	let { large = false } = $$props;
	let { largeMd = false } = $$props;
	let { largeIos = false } = $$props;
	let { largeAurora = false } = $$props;
	let { small = false } = $$props;
	let { smallMd = false } = $$props;
	let { smallIos = false } = $$props;
	let { smallAurora = false } = $$props;
	let { raised = false } = $$props;
	let { raisedMd = false } = $$props;
	let { raisedIos = false } = $$props;
	let { raisedAurora = false } = $$props;
	let el;
	let f7Stepper;

	function instance() {
		return f7Stepper;
	}

	function watchValue(newValue) {
		if (!f7Stepper) return;
		f7Stepper.setValue(newValue);
	}

	function onInput(event) {
		emit('input', [event, f7Stepper]);
	}

	function onChange(event) {
		emit('change', [event, f7Stepper]);
	}

	function onMinusClick(event) {
		emit('stepperMinusClick', [event, f7Stepper]);
	}

	function onPlusClick(event) {
		emit('stepperPlusClick', [event, f7Stepper]);
	}

	onMount(() => {
		if (!init) return;

		f7ready(() => {
			f7Stepper = app.f7.stepper.create(noUndefinedProps({
				el,
				min,
				max,
				value,
				step,
				formatValue,
				autorepeat,
				autorepeatDynamic,
				wraps,
				manualInputMode,
				decimalPoint,
				buttonsEndInputMode,
				on: {
					change(stepper, newValue) {
						emit('stepperChange', [newValue]);
						$$invalidate(0, value = newValue);
					}
				}
			}));
		});
	});

	onDestroy(() => {
		if (f7Stepper && f7Stepper.destroy) {
			f7Stepper.destroy();
			f7Stepper = null;
		}
	});

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(12, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(55, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('classes' in $$new_props) $$invalidate(1, classes = $$new_props.classes);
		if ('init' in $$new_props) $$invalidate(19, init = $$new_props.init);
		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ('min' in $$new_props) $$invalidate(2, min = $$new_props.min);
		if ('max' in $$new_props) $$invalidate(3, max = $$new_props.max);
		if ('step' in $$new_props) $$invalidate(4, step = $$new_props.step);
		if ('formatValue' in $$new_props) $$invalidate(20, formatValue = $$new_props.formatValue);
		if ('name' in $$new_props) $$invalidate(5, name = $$new_props.name);
		if ('inputId' in $$new_props) $$invalidate(6, inputId = $$new_props.inputId);
		if ('input' in $$new_props) $$invalidate(7, input = $$new_props.input);
		if ('inputType' in $$new_props) $$invalidate(8, inputType = $$new_props.inputType);
		if ('inputReadonly' in $$new_props) $$invalidate(9, inputReadonly = $$new_props.inputReadonly);
		if ('autorepeat' in $$new_props) $$invalidate(21, autorepeat = $$new_props.autorepeat);
		if ('autorepeatDynamic' in $$new_props) $$invalidate(22, autorepeatDynamic = $$new_props.autorepeatDynamic);
		if ('wraps' in $$new_props) $$invalidate(23, wraps = $$new_props.wraps);
		if ('manualInputMode' in $$new_props) $$invalidate(24, manualInputMode = $$new_props.manualInputMode);
		if ('decimalPoint' in $$new_props) $$invalidate(25, decimalPoint = $$new_props.decimalPoint);
		if ('buttonsEndInputMode' in $$new_props) $$invalidate(26, buttonsEndInputMode = $$new_props.buttonsEndInputMode);
		if ('disabled' in $$new_props) $$invalidate(27, disabled = $$new_props.disabled);
		if ('buttonsOnly' in $$new_props) $$invalidate(10, buttonsOnly = $$new_props.buttonsOnly);
		if ('round' in $$new_props) $$invalidate(28, round = $$new_props.round);
		if ('roundMd' in $$new_props) $$invalidate(29, roundMd = $$new_props.roundMd);
		if ('roundIos' in $$new_props) $$invalidate(30, roundIos = $$new_props.roundIos);
		if ('roundAurora' in $$new_props) $$invalidate(31, roundAurora = $$new_props.roundAurora);
		if ('fill' in $$new_props) $$invalidate(32, fill = $$new_props.fill);
		if ('fillMd' in $$new_props) $$invalidate(33, fillMd = $$new_props.fillMd);
		if ('fillIos' in $$new_props) $$invalidate(34, fillIos = $$new_props.fillIos);
		if ('fillAurora' in $$new_props) $$invalidate(35, fillAurora = $$new_props.fillAurora);
		if ('large' in $$new_props) $$invalidate(36, large = $$new_props.large);
		if ('largeMd' in $$new_props) $$invalidate(37, largeMd = $$new_props.largeMd);
		if ('largeIos' in $$new_props) $$invalidate(38, largeIos = $$new_props.largeIos);
		if ('largeAurora' in $$new_props) $$invalidate(39, largeAurora = $$new_props.largeAurora);
		if ('small' in $$new_props) $$invalidate(40, small = $$new_props.small);
		if ('smallMd' in $$new_props) $$invalidate(41, smallMd = $$new_props.smallMd);
		if ('smallIos' in $$new_props) $$invalidate(42, smallIos = $$new_props.smallIos);
		if ('smallAurora' in $$new_props) $$invalidate(43, smallAurora = $$new_props.smallAurora);
		if ('raised' in $$new_props) $$invalidate(44, raised = $$new_props.raised);
		if ('raisedMd' in $$new_props) $$invalidate(45, raisedMd = $$new_props.raisedMd);
		if ('raisedIos' in $$new_props) $$invalidate(46, raisedIos = $$new_props.raisedIos);
		if ('raisedAurora' in $$new_props) $$invalidate(47, raisedAurora = $$new_props.raisedAurora);
	};

	$$self.$$.update = () => {
		$$invalidate(11, computedClasses = classNames(
			classes,
			{
				disabled,
				'stepper-round': round,
				'stepper-round-ios': roundIos,
				'stepper-round-md': roundMd,
				'stepper-round-aurora': roundAurora,
				'stepper-fill': fill,
				'stepper-fill-ios': fillIos,
				'stepper-fill-md': fillMd,
				'stepper-fill-aurora': fillAurora,
				'stepper-large': large,
				'stepper-large-ios': largeIos,
				'stepper-large-md': largeMd,
				'stepper-large-aurora': largeAurora,
				'stepper-small': small,
				'stepper-small-ios': smallIos,
				'stepper-small-md': smallMd,
				'stepper-small-aurora': smallAurora,
				'stepper-raised': raised,
				'stepper-raised-ios': raisedIos,
				'stepper-raised-md': raisedMd,
				'stepper-raised-aurora': raisedAurora
			},
			colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*value*/ 1) {
			watchValue(value);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		value,
		classes,
		min,
		max,
		step,
		name,
		inputId,
		input,
		inputType,
		inputReadonly,
		buttonsOnly,
		computedClasses,
		el,
		liquid,
		onInput,
		onChange,
		onMinusClick,
		onPlusClick,
		$$restProps,
		init,
		formatValue,
		autorepeat,
		autorepeatDynamic,
		wraps,
		manualInputMode,
		decimalPoint,
		buttonsEndInputMode,
		disabled,
		round,
		roundMd,
		roundIos,
		roundAurora,
		fill,
		fillMd,
		fillIos,
		fillAurora,
		large,
		largeMd,
		largeIos,
		largeAurora,
		small,
		smallMd,
		smallIos,
		smallAurora,
		raised,
		raisedMd,
		raisedIos,
		raisedAurora,
		instance,
		div2_binding
	];
}

class Stepper extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance_1,
			create_fragment,
			safe_not_equal,
			{
				classes: 1,
				init: 19,
				value: 0,
				min: 2,
				max: 3,
				step: 4,
				formatValue: 20,
				name: 5,
				inputId: 6,
				input: 7,
				inputType: 8,
				inputReadonly: 9,
				autorepeat: 21,
				autorepeatDynamic: 22,
				wraps: 23,
				manualInputMode: 24,
				decimalPoint: 25,
				buttonsEndInputMode: 26,
				disabled: 27,
				buttonsOnly: 10,
				round: 28,
				roundMd: 29,
				roundIos: 30,
				roundAurora: 31,
				fill: 32,
				fillMd: 33,
				fillIos: 34,
				fillAurora: 35,
				large: 36,
				largeMd: 37,
				largeIos: 38,
				largeAurora: 39,
				small: 40,
				smallMd: 41,
				smallIos: 42,
				smallAurora: 43,
				raised: 44,
				raisedMd: 45,
				raisedIos: 46,
				raisedAurora: 47,
				instance: 48
			},
			null,
			[-1, -1]
		);
	}

	get instance() {
		return this.$$.ctx[48];
	}
}

export { Stepper };
