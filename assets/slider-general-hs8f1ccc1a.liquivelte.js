import { SvelteComponent, init, safe_not_equal, create_slot, element, claim_element, children, detach, attr, set_style, insert_hydration, update_slot_base, get_all_dirty_from_scope, get_slot_changes, transition_in, transition_out, getContext, assign, exclude_internal_props, empty, group_outros, check_outros, space, claim_space, append_hydration, HtmlTagHydration, claim_html_tag, create_component, claim_component, mount_component, destroy_component, onMount, tick, text, claim_text, set_data, destroy_each, binding_callbacks } from './liquivelte-svelte-hsa803e515.liquivelte.js';
import './framework7-liquivelte-hs2475aa90.liquivelte.js';
import { Swiper_slide } from './framework7-liquivelte-swiper-slide-hsed743795.liquivelte.js';
import { Swiper_1 } from './framework7-liquivelte-swiper-hs9f4b5caa.liquivelte.js';
import { freeMode, Mousewheel } from './framework7-liquivelte-get-params-hs5b727abe.liquivelte.js';
import { Image } from './header-hs920e1f04.liquivelte.js';
import { cachedLiquid } from './liquivelte-liquid-hs6b49bbd7.liquivelte.js';
import { Button } from './framework7-liquivelte-button-hs35eecf3c.liquivelte.js';
import './framework7-liquivelte-popup-hsc2bb4ca9.liquivelte.js';
import './framework7-liquivelte-view-hs5879c99b.liquivelte.js';
import './framework7-liquivelte-router-context-provider-hse7089cdf.liquivelte.js';
import './framework7-liquivelte-login-screen-hs3e3c04a8.liquivelte.js';
import './framework7-liquivelte-sheet-hse1bd4eb5.liquivelte.js';
import './framework7-liquivelte-popover-hs31a1f66d.liquivelte.js';
import './framework7-liquivelte-panel-hs11af60cd.liquivelte.js';
import './framework7-liquivelte-mount-swiper-hs7509aba6.liquivelte.js';
import './framework7-liquivelte-utils-hs3552a7bb.liquivelte.js';
import './framework7-liquivelte-get-changed-params-hs61b47237.liquivelte.js';
import './framework7-liquivelte-params-list-hs7a0c8b0f.liquivelte.js';
import './framework7-liquivelte-update-swiper-hs8334de75.liquivelte.js';
import './store.js-hs835be35c.liquivelte.js';
import './product-carousel-hs5c185ce0.liquivelte.js';
import './framework7-liquivelte-block-title-hseade2115.liquivelte.js';
import './framework7-liquivelte-block-hs5e315b27.liquivelte.js';
import './framework7-liquivelte-card-content-hsa8fd4207.liquivelte.js';
import './framework7-liquivelte-card-footer-hs8b83f989.liquivelte.js';
import './framework7-liquivelte-card-header-hs7c861f63.liquivelte.js';
import './framework7-liquivelte-card-hs0c527230.liquivelte.js';
import './framework7-liquivelte-link-hsde51db87.liquivelte.js';
import './framework7-liquivelte-use-icon-hs690d3699.liquivelte.js';
import './framework7-liquivelte-icon-hs0905ea3c.liquivelte.js';
import './framework7-liquivelte-badge-hs29eee0fd.liquivelte.js';
import './framework7-liquivelte-stepper-hs8c19d8b3.liquivelte.js';
import './framework7-liquivelte-list-item-hs0dea3f6d.liquivelte.js';
import './framework7-liquivelte-list-hs34089a55.liquivelte.js';
import './framework7-liquivelte-accordion-content-hs3c8000fa.liquivelte.js';
import './framework7-liquivelte-col-hscf6c9c08.liquivelte.js';
import './framework7-liquivelte-row-hs4ac9eb7d.liquivelte.js';
import './framework7-liquivelte-appbar-hs853a9416.liquivelte.js';
import './framework7-liquivelte-page-hs77d100c4.liquivelte.js';
import './framework7-liquivelte-page-content-hs12d7c72d.liquivelte.js';
import './framework7-liquivelte-preloader-hsea2205df.liquivelte.js';

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/snippets/blocks/card.liquivelte generated by Svelte v3.50.0 */

function create_fragment$6(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", div_class_value = "card " + /*card_classes*/ ctx[1] + " svelte-1wgxx4s");
			set_style(div, "--left", /*settings*/ ctx[0].card_left + "%");
			set_style(div, "--top", /*settings*/ ctx[0].card_top + "%");
			set_style(div, "--width", /*settings*/ ctx[0].card_width + "%");
			set_style(div, "--height", /*settings*/ ctx[0].card_height + "%");
			set_style(div, "--left_mobile", /*settings*/ ctx[0].card_left_mobile + "%");
			set_style(div, "--top_mobile", /*settings*/ ctx[0].card_top_mobile + "%");
			set_style(div, "--width_mobile", /*settings*/ ctx[0].card_width_mobile + "%");
			set_style(div, "--height_mobile", /*settings*/ ctx[0].card_height_mobile + "%");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*card_classes*/ 2 && div_class_value !== (div_class_value = "card " + /*card_classes*/ ctx[1] + " svelte-1wgxx4s")) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty & /*settings*/ 1) {
				set_style(div, "--left", /*settings*/ ctx[0].card_left + "%");
			}

			if (!current || dirty & /*settings*/ 1) {
				set_style(div, "--top", /*settings*/ ctx[0].card_top + "%");
			}

			if (!current || dirty & /*settings*/ 1) {
				set_style(div, "--width", /*settings*/ ctx[0].card_width + "%");
			}

			if (!current || dirty & /*settings*/ 1) {
				set_style(div, "--height", /*settings*/ ctx[0].card_height + "%");
			}

			if (!current || dirty & /*settings*/ 1) {
				set_style(div, "--left_mobile", /*settings*/ ctx[0].card_left_mobile + "%");
			}

			if (!current || dirty & /*settings*/ 1) {
				set_style(div, "--top_mobile", /*settings*/ ctx[0].card_top_mobile + "%");
			}

			if (!current || dirty & /*settings*/ 1) {
				set_style(div, "--width_mobile", /*settings*/ ctx[0].card_width_mobile + "%");
			}

			if (!current || dirty & /*settings*/ 1) {
				set_style(div, "--height_mobile", /*settings*/ ctx[0].card_height_mobile + "%");
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function fc$5(e, t, r) {
	const n = e.find(e => e === t);

	return n || e.reduce((e, n) => {
		let o = Math.abs(e - t), i = Math.abs(n - t);

		return "higher" === r
		? n > t && i <= o ? n : e
		: "lower" === r ? n < t && i <= o ? n : e : void 0;
	});
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { importsSeek = 'lower' } = $$props;
	let themeImports = getContext('svelteProps') || {};
	getContext('lec') || {};
	(() => window.cicR = $$props.resetCicR ? 1 : window.cicR + 1)();
	const cic = window.cicR;
	let { settings = themeImports['settings'].find(e => e.component_index == fc$5(themeImports['settings'].map(e => e.component_index), cic, importsSeek)).value } = $$props;
	console.log('settings card ', settings);
	let { left } = $$props;
	let { top } = $$props;
	let { width } = $$props;
	let { height } = $$props;
	let { card_classes = themeImports['card_classes'].find(e => e.component_index == fc$5(themeImports['card_classes'].map(e => e.component_index), cic, importsSeek)).value } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('importsSeek' in $$new_props) $$invalidate(2, importsSeek = $$new_props.importsSeek);
		if ('settings' in $$new_props) $$invalidate(0, settings = $$new_props.settings);
		if ('left' in $$new_props) $$invalidate(3, left = $$new_props.left);
		if ('top' in $$new_props) $$invalidate(4, top = $$new_props.top);
		if ('width' in $$new_props) $$invalidate(5, width = $$new_props.width);
		if ('height' in $$new_props) $$invalidate(6, height = $$new_props.height);
		if ('card_classes' in $$new_props) $$invalidate(1, card_classes = $$new_props.card_classes);
		if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$props = exclude_internal_props($$props);
	return [settings, card_classes, importsSeek, left, top, width, height, $$scope, slots];
}

class Card extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
			importsSeek: 2,
			settings: 0,
			left: 3,
			top: 4,
			width: 5,
			height: 6,
			card_classes: 1
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/snippets/blocks/button-group.liquivelte generated by Svelte v3.50.0 */

function create_fragment$5(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", div_class_value = "flex " + /*button_group_classes*/ ctx[0] + " svelte-1ry32kp");
			set_style(div, "--button-spacing", /*settings*/ ctx[1].button_spacing + "px");
			set_style(div, "--buttons-margin-bottom", /*settings*/ ctx[1].button_group_margin_bottom + "px");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*button_group_classes*/ 1 && div_class_value !== (div_class_value = "flex " + /*button_group_classes*/ ctx[0] + " svelte-1ry32kp")) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty & /*settings*/ 2) {
				set_style(div, "--button-spacing", /*settings*/ ctx[1].button_spacing + "px");
			}

			if (!current || dirty & /*settings*/ 2) {
				set_style(div, "--buttons-margin-bottom", /*settings*/ ctx[1].button_group_margin_bottom + "px");
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function fc$4(e, t, r) {
	const n = e.find(e => e === t);

	return n || e.reduce((e, n) => {
		let o = Math.abs(e - t), i = Math.abs(n - t);

		return "higher" === r
		? n > t && i <= o ? n : e
		: "lower" === r ? n < t && i <= o ? n : e : void 0;
	});
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { importsSeek = 'lower' } = $$props;
	let themeImports = getContext('svelteProps') || {};
	getContext('lec') || {};
	(() => window.cicR = $$props.resetCicR ? 1 : window.cicR + 1)();
	const cic = window.cicR;
	let { button_group_classes = themeImports['button_group_classes'].find(e => e.component_index == fc$4(themeImports['button_group_classes'].map(e => e.component_index), cic, importsSeek)).value } = $$props;
	let { settings = themeImports['settings'].find(e => e.component_index == fc$4(themeImports['settings'].map(e => e.component_index), cic, importsSeek)).value } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('importsSeek' in $$new_props) $$invalidate(2, importsSeek = $$new_props.importsSeek);
		if ('button_group_classes' in $$new_props) $$invalidate(0, button_group_classes = $$new_props.button_group_classes);
		if ('settings' in $$new_props) $$invalidate(1, settings = $$new_props.settings);
		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$props = exclude_internal_props($$props);
	return [button_group_classes, settings, importsSeek, $$scope, slots];
}

class Button_group extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			importsSeek: 2,
			button_group_classes: 0,
			settings: 1
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/snippets/essential-components/H.liquivelte generated by Svelte v3.50.0 */

function create_if_block_10(ctx) {
	let h6;
	let t;
	let current;
	let if_block = /*text*/ ctx[0] != undefined && create_if_block_11(ctx);
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	return {
		c() {
			h6 = element("h6");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			h6 = claim_element(nodes, "H6", { class: true, style: true });
			var h6_nodes = children(h6);
			if (if_block) if_block.l(h6_nodes);
			t = claim_space(h6_nodes);
			if (default_slot) default_slot.l(h6_nodes);
			h6_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(h6, "class", " svelte-182aib");
			set_style(h6, "--font-size", /*settings*/ ctx[2].font_size + /*settings*/ ctx[2].font_unit);
			set_style(h6, "--font-size-mobile", /*settings*/ ctx[2].font_size_mobile + /*settings*/ ctx[2].font_unit);
			set_style(h6, "--color", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color), '(')), ')')));
			set_style(h6, "--color-dark", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color_dark), '(')), ')')));
			set_style(h6, "--text-align", /*settings*/ ctx[2].text_align);
		},
		m(target, anchor) {
			insert_hydration(target, h6, anchor);
			if (if_block) if_block.m(h6, null);
			append_hydration(h6, t);

			if (default_slot) {
				default_slot.m(h6, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*text*/ ctx[0] != undefined) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_11(ctx);
					if_block.c();
					if_block.m(h6, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h6, "--font-size", /*settings*/ ctx[2].font_size + /*settings*/ ctx[2].font_unit);
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h6, "--font-size-mobile", /*settings*/ ctx[2].font_size_mobile + /*settings*/ ctx[2].font_unit);
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h6, "--color", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color), '(')), ')')));
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h6, "--color-dark", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color_dark), '(')), ')')));
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h6, "--text-align", /*settings*/ ctx[2].text_align);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h6);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (117:23) 
function create_if_block_8(ctx) {
	let h5;
	let t;
	let current;
	let if_block = /*text*/ ctx[0] != undefined && create_if_block_9(ctx);
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	return {
		c() {
			h5 = element("h5");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			h5 = claim_element(nodes, "H5", { class: true, style: true });
			var h5_nodes = children(h5);
			if (if_block) if_block.l(h5_nodes);
			t = claim_space(h5_nodes);
			if (default_slot) default_slot.l(h5_nodes);
			h5_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(h5, "class", " svelte-182aib");
			set_style(h5, "--font-size", /*settings*/ ctx[2].font_size + /*settings*/ ctx[2].font_unit);
			set_style(h5, "--font-size-mobile", /*settings*/ ctx[2].font_size_mobile + /*settings*/ ctx[2].font_unit);
			set_style(h5, "--color", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color), '(')), ')')));
			set_style(h5, "--color-dark", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color_dark), '(')), ')')));
			set_style(h5, "--text-align", /*settings*/ ctx[2].text_align);
		},
		m(target, anchor) {
			insert_hydration(target, h5, anchor);
			if (if_block) if_block.m(h5, null);
			append_hydration(h5, t);

			if (default_slot) {
				default_slot.m(h5, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*text*/ ctx[0] != undefined) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_9(ctx);
					if_block.c();
					if_block.m(h5, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h5, "--font-size", /*settings*/ ctx[2].font_size + /*settings*/ ctx[2].font_unit);
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h5, "--font-size-mobile", /*settings*/ ctx[2].font_size_mobile + /*settings*/ ctx[2].font_unit);
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h5, "--color", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color), '(')), ')')));
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h5, "--color-dark", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color_dark), '(')), ')')));
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h5, "--text-align", /*settings*/ ctx[2].text_align);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h5);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (106:23) 
function create_if_block_6(ctx) {
	let h4;
	let t;
	let current;
	let if_block = /*text*/ ctx[0] != undefined && create_if_block_7(ctx);
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	return {
		c() {
			h4 = element("h4");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			h4 = claim_element(nodes, "H4", { class: true, style: true });
			var h4_nodes = children(h4);
			if (if_block) if_block.l(h4_nodes);
			t = claim_space(h4_nodes);
			if (default_slot) default_slot.l(h4_nodes);
			h4_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(h4, "class", " svelte-182aib");
			set_style(h4, "--font-size", /*settings*/ ctx[2].font_size + /*settings*/ ctx[2].font_unit);
			set_style(h4, "--font-size-mobile", /*settings*/ ctx[2].font_size_mobile + /*settings*/ ctx[2].font_unit);
			set_style(h4, "--color", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color), '(')), ')')));
			set_style(h4, "--color-dark", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color_dark), '(')), ')')));
			set_style(h4, "--text-align", /*settings*/ ctx[2].text_align);
		},
		m(target, anchor) {
			insert_hydration(target, h4, anchor);
			if (if_block) if_block.m(h4, null);
			append_hydration(h4, t);

			if (default_slot) {
				default_slot.m(h4, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*text*/ ctx[0] != undefined) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_7(ctx);
					if_block.c();
					if_block.m(h4, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h4, "--font-size", /*settings*/ ctx[2].font_size + /*settings*/ ctx[2].font_unit);
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h4, "--font-size-mobile", /*settings*/ ctx[2].font_size_mobile + /*settings*/ ctx[2].font_unit);
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h4, "--color", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color), '(')), ')')));
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h4, "--color-dark", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color_dark), '(')), ')')));
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h4, "--text-align", /*settings*/ ctx[2].text_align);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h4);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (95:23) 
function create_if_block_4(ctx) {
	let h3;
	let t;
	let current;
	let if_block = /*text*/ ctx[0] != undefined && create_if_block_5(ctx);
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	return {
		c() {
			h3 = element("h3");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			h3 = claim_element(nodes, "H3", { class: true, style: true });
			var h3_nodes = children(h3);
			if (if_block) if_block.l(h3_nodes);
			t = claim_space(h3_nodes);
			if (default_slot) default_slot.l(h3_nodes);
			h3_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(h3, "class", " svelte-182aib");
			set_style(h3, "--font-size", /*settings*/ ctx[2].font_size + /*settings*/ ctx[2].font_unit);
			set_style(h3, "--font-size-mobile", /*settings*/ ctx[2].font_size_mobile + /*settings*/ ctx[2].font_unit);
			set_style(h3, "--color", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color), '(')), ')')));
			set_style(h3, "--color-dark", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color_dark), '(')), ')')));
			set_style(h3, "--text-align", /*settings*/ ctx[2].text_align);
		},
		m(target, anchor) {
			insert_hydration(target, h3, anchor);
			if (if_block) if_block.m(h3, null);
			append_hydration(h3, t);

			if (default_slot) {
				default_slot.m(h3, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*text*/ ctx[0] != undefined) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_5(ctx);
					if_block.c();
					if_block.m(h3, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h3, "--font-size", /*settings*/ ctx[2].font_size + /*settings*/ ctx[2].font_unit);
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h3, "--font-size-mobile", /*settings*/ ctx[2].font_size_mobile + /*settings*/ ctx[2].font_unit);
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h3, "--color", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color), '(')), ')')));
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h3, "--color-dark", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color_dark), '(')), ')')));
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h3, "--text-align", /*settings*/ ctx[2].text_align);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h3);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (84:23) 
function create_if_block_2$2(ctx) {
	let h2;
	let t;
	let current;
	let if_block = /*text*/ ctx[0] != undefined && create_if_block_3$1(ctx);
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	return {
		c() {
			h2 = element("h2");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			h2 = claim_element(nodes, "H2", { class: true, style: true });
			var h2_nodes = children(h2);
			if (if_block) if_block.l(h2_nodes);
			t = claim_space(h2_nodes);
			if (default_slot) default_slot.l(h2_nodes);
			h2_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(h2, "class", " svelte-182aib");
			set_style(h2, "--font-size", /*settings*/ ctx[2].font_size + /*settings*/ ctx[2].font_unit);
			set_style(h2, "--font-size-mobile", /*settings*/ ctx[2].font_size_mobile + /*settings*/ ctx[2].font_unit);
			set_style(h2, "--color", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color), '(')), ')')));
			set_style(h2, "--color-dark", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color_dark), '(')), ')')));
			set_style(h2, "--text-align", /*settings*/ ctx[2].text_align);
		},
		m(target, anchor) {
			insert_hydration(target, h2, anchor);
			if (if_block) if_block.m(h2, null);
			append_hydration(h2, t);

			if (default_slot) {
				default_slot.m(h2, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*text*/ ctx[0] != undefined) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3$1(ctx);
					if_block.c();
					if_block.m(h2, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h2, "--font-size", /*settings*/ ctx[2].font_size + /*settings*/ ctx[2].font_unit);
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h2, "--font-size-mobile", /*settings*/ ctx[2].font_size_mobile + /*settings*/ ctx[2].font_unit);
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h2, "--color", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color), '(')), ')')));
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h2, "--color-dark", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color_dark), '(')), ')')));
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h2, "--text-align", /*settings*/ ctx[2].text_align);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h2);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (73:0) {#if type == 'h1' }
function create_if_block$3(ctx) {
	let h1;
	let t;
	let current;
	let if_block = /*text*/ ctx[0] != undefined && create_if_block_1$2(ctx);
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	return {
		c() {
			h1 = element("h1");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			h1 = claim_element(nodes, "H1", { class: true, style: true });
			var h1_nodes = children(h1);
			if (if_block) if_block.l(h1_nodes);
			t = claim_space(h1_nodes);
			if (default_slot) default_slot.l(h1_nodes);
			h1_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(h1, "class", " svelte-182aib");
			set_style(h1, "--font-size", /*settings*/ ctx[2].font_size + /*settings*/ ctx[2].font_unit);
			set_style(h1, "--font-size-mobile", /*settings*/ ctx[2].font_size_mobile + /*settings*/ ctx[2].font_unit);
			set_style(h1, "--color", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color), '(')), ')')));
			set_style(h1, "--color-dark", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color_dark), '(')), ')')));
			set_style(h1, "--text-align", /*settings*/ ctx[2].text_align);
		},
		m(target, anchor) {
			insert_hydration(target, h1, anchor);
			if (if_block) if_block.m(h1, null);
			append_hydration(h1, t);

			if (default_slot) {
				default_slot.m(h1, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*text*/ ctx[0] != undefined) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$2(ctx);
					if_block.c();
					if_block.m(h1, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h1, "--font-size", /*settings*/ ctx[2].font_size + /*settings*/ ctx[2].font_unit);
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h1, "--font-size-mobile", /*settings*/ ctx[2].font_size_mobile + /*settings*/ ctx[2].font_unit);
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h1, "--color", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color), '(')), ')')));
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h1, "--color-dark", /*liquid*/ ctx[3].first(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].last(/*liquid*/ ctx[3].split(/*liquid*/ ctx[3].color_to_rgb(/*settings*/ ctx[2].color_dark), '(')), ')')));
			}

			if (!current || dirty & /*settings*/ 4) {
				set_style(h1, "--text-align", /*settings*/ ctx[2].text_align);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h1);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (134:4) {#if text != undefined }
function create_if_block_11(ctx) {
	let html_tag;
	let raw_value = (/*text*/ ctx[0] || '') + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTagHydration(false);
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_tag = claim_html_tag(nodes, false);
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_hydration(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*text*/ 1 && raw_value !== (raw_value = (/*text*/ ctx[0] || '') + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (123:4) {#if text != undefined }
function create_if_block_9(ctx) {
	let html_tag;
	let raw_value = (/*text*/ ctx[0] || '') + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTagHydration(false);
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_tag = claim_html_tag(nodes, false);
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_hydration(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*text*/ 1 && raw_value !== (raw_value = (/*text*/ ctx[0] || '') + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (112:4) {#if text != undefined }
function create_if_block_7(ctx) {
	let html_tag;
	let raw_value = (/*text*/ ctx[0] || '') + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTagHydration(false);
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_tag = claim_html_tag(nodes, false);
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_hydration(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*text*/ 1 && raw_value !== (raw_value = (/*text*/ ctx[0] || '') + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (101:4) {#if text != undefined }
function create_if_block_5(ctx) {
	let html_tag;
	let raw_value = (/*text*/ ctx[0] || '') + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTagHydration(false);
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_tag = claim_html_tag(nodes, false);
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_hydration(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*text*/ 1 && raw_value !== (raw_value = (/*text*/ ctx[0] || '') + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (90:4) {#if text != undefined }
function create_if_block_3$1(ctx) {
	let html_tag;
	let raw_value = (/*text*/ ctx[0] || '') + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTagHydration(false);
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_tag = claim_html_tag(nodes, false);
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_hydration(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*text*/ 1 && raw_value !== (raw_value = (/*text*/ ctx[0] || '') + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (79:4) {#if text != undefined }
function create_if_block_1$2(ctx) {
	let html_tag;
	let raw_value = (/*text*/ ctx[0] || '') + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTagHydration(false);
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_tag = claim_html_tag(nodes, false);
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_hydration(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*text*/ 1 && raw_value !== (raw_value = (/*text*/ ctx[0] || '') + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

function create_fragment$4(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block$3,
		create_if_block_2$2,
		create_if_block_4,
		create_if_block_6,
		create_if_block_8,
		create_if_block_10
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*type*/ ctx[1] == 'h1') return 0;
		if (/*type*/ ctx[1] == 'h2') return 1;
		if (/*type*/ ctx[1] == 'h3') return 2;
		if (/*type*/ ctx[1] == 'h4') return 3;
		if (/*type*/ ctx[1] == 'h5') return 4;
		if (/*type*/ ctx[1] == 'h6') return 5;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

function fc$3(e, t, r) {
	const n = e.find(e => e === t);

	return n || e.reduce((e, n) => {
		let o = Math.abs(e - t), i = Math.abs(n - t);

		return "higher" === r
		? n > t && i <= o ? n : e
		: "lower" === r ? n < t && i <= o ? n : e : void 0;
	});
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { importsSeek = 'lower' } = $$props;
	let themeImports = getContext('svelteProps') || {};
	let lec = getContext('lec') || {};
	(() => window.cicR = $$props.resetCicR ? 1 : window.cicR + 1)();
	const cic = window.cicR;
	const liquid = cachedLiquid(lec);
	let { text = '' } = $$props;
	let { type = 'h1' } = $$props;
	let { settings = themeImports['settings'].find(e => e.component_index == fc$3(themeImports['settings'].map(e => e.component_index), cic, importsSeek)).value } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('importsSeek' in $$new_props) $$invalidate(4, importsSeek = $$new_props.importsSeek);
		if ('text' in $$new_props) $$invalidate(0, text = $$new_props.text);
		if ('type' in $$new_props) $$invalidate(1, type = $$new_props.type);
		if ('settings' in $$new_props) $$invalidate(2, settings = $$new_props.settings);
		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$props = exclude_internal_props($$props);
	return [text, type, settings, liquid, importsSeek, $$scope, slots];
}

class H extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			importsSeek: 4,
			text: 0,
			type: 1,
			settings: 2
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/snippets/essential-components/P.liquivelte generated by Svelte v3.50.0 */

function create_if_block$2(ctx) {
	let html_tag;
	let raw_value = (/*text*/ ctx[0] || '') + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTagHydration(false);
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_tag = claim_html_tag(nodes, false);
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_hydration(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*text*/ 1 && raw_value !== (raw_value = (/*text*/ ctx[0] || '') + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

function create_fragment$3(ctx) {
	let p;
	let t;
	let current;
	let if_block = /*text*/ ctx[0] != undefined && create_if_block$2(ctx);
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	return {
		c() {
			p = element("p");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l(nodes) {
			p = claim_element(nodes, "P", { class: true, style: true });
			var p_nodes = children(p);
			if (if_block) if_block.l(p_nodes);
			t = claim_space(p_nodes);
			if (default_slot) default_slot.l(p_nodes);
			p_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(p, "class", " svelte-1oyu6be");
			set_style(p, "--font-size", /*settings*/ ctx[1].p_font_size + /*settings*/ ctx[1].p_font_unit);
			set_style(p, "--font-size-mobile", /*settings*/ ctx[1].p_font_size_mobile + /*settings*/ ctx[1].p_font_unit);
			set_style(p, "--color", /*liquid*/ ctx[2].first(/*liquid*/ ctx[2].split(/*liquid*/ ctx[2].last(/*liquid*/ ctx[2].split(/*liquid*/ ctx[2].color_to_rgb(/*settings*/ ctx[1].p_color), '(')), ')')));
			set_style(p, "--color-dark", /*liquid*/ ctx[2].first(/*liquid*/ ctx[2].split(/*liquid*/ ctx[2].last(/*liquid*/ ctx[2].split(/*liquid*/ ctx[2].color_to_rgb(/*settings*/ ctx[1].p_color_dark), '(')), ')')));
			set_style(p, "--text-align", /*settings*/ ctx[1].p_text_align);
		},
		m(target, anchor) {
			insert_hydration(target, p, anchor);
			if (if_block) if_block.m(p, null);
			append_hydration(p, t);

			if (default_slot) {
				default_slot.m(p, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (/*text*/ ctx[0] != undefined) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					if_block.m(p, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[4],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*settings*/ 2) {
				set_style(p, "--font-size", /*settings*/ ctx[1].p_font_size + /*settings*/ ctx[1].p_font_unit);
			}

			if (!current || dirty & /*settings*/ 2) {
				set_style(p, "--font-size-mobile", /*settings*/ ctx[1].p_font_size_mobile + /*settings*/ ctx[1].p_font_unit);
			}

			if (!current || dirty & /*settings*/ 2) {
				set_style(p, "--color", /*liquid*/ ctx[2].first(/*liquid*/ ctx[2].split(/*liquid*/ ctx[2].last(/*liquid*/ ctx[2].split(/*liquid*/ ctx[2].color_to_rgb(/*settings*/ ctx[1].p_color), '(')), ')')));
			}

			if (!current || dirty & /*settings*/ 2) {
				set_style(p, "--color-dark", /*liquid*/ ctx[2].first(/*liquid*/ ctx[2].split(/*liquid*/ ctx[2].last(/*liquid*/ ctx[2].split(/*liquid*/ ctx[2].color_to_rgb(/*settings*/ ctx[1].p_color_dark), '(')), ')')));
			}

			if (!current || dirty & /*settings*/ 2) {
				set_style(p, "--text-align", /*settings*/ ctx[1].p_text_align);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(p);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function fc$2(e, t, r) {
	const n = e.find(e => e === t);

	return n || e.reduce((e, n) => {
		let o = Math.abs(e - t), i = Math.abs(n - t);

		return "higher" === r
		? n > t && i <= o ? n : e
		: "lower" === r ? n < t && i <= o ? n : e : void 0;
	});
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { importsSeek = 'lower' } = $$props;
	let themeImports = getContext('svelteProps') || {};
	let lec = getContext('lec') || {};
	(() => window.cicR = $$props.resetCicR ? 1 : window.cicR + 1)();
	const cic = window.cicR;
	const liquid = cachedLiquid(lec);
	let { text = '' } = $$props;
	let { settings = themeImports['settings'].find(e => e.component_index == fc$2(themeImports['settings'].map(e => e.component_index), cic, importsSeek)).value } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('importsSeek' in $$new_props) $$invalidate(3, importsSeek = $$new_props.importsSeek);
		if ('text' in $$new_props) $$invalidate(0, text = $$new_props.text);
		if ('settings' in $$new_props) $$invalidate(1, settings = $$new_props.settings);
		if ('$$scope' in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$props = exclude_internal_props($$props);
	return [text, settings, liquid, importsSeek, $$scope, slots];
}

class P extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { importsSeek: 3, text: 0, settings: 1 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/snippets/essential-components/Button.liquivelte generated by Svelte v3.50.0 */

function create_default_slot$2(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$2(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				href: /*href*/ ctx[4],
				large: /*settings*/ ctx[0].button_isbig,
				raised: /*settings*/ ctx[0].button_israised,
				fill: /*filled*/ ctx[1],
				outline: /*outlined*/ ctx[2],
				classes: /*button_classes*/ ctx[3],
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		l(nodes) {
			claim_component(button.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const button_changes = {};
			if (dirty & /*href*/ 16) button_changes.href = /*href*/ ctx[4];
			if (dirty & /*settings*/ 1) button_changes.large = /*settings*/ ctx[0].button_isbig;
			if (dirty & /*settings*/ 1) button_changes.raised = /*settings*/ ctx[0].button_israised;
			if (dirty & /*filled*/ 2) button_changes.fill = /*filled*/ ctx[1];
			if (dirty & /*outlined*/ 4) button_changes.outline = /*outlined*/ ctx[2];
			if (dirty & /*button_classes*/ 8) button_changes.classes = /*button_classes*/ ctx[3];

			if (dirty & /*$$scope*/ 128) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

function fc$1(e, t, r) {
	const n = e.find(e => e === t);

	return n || e.reduce((e, n) => {
		let o = Math.abs(e - t), i = Math.abs(n - t);

		return "higher" === r
		? n > t && i <= o ? n : e
		: "lower" === r ? n < t && i <= o ? n : e : void 0;
	});
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { importsSeek = 'lower' } = $$props;
	let themeImports = getContext('svelteProps') || {};
	getContext('lec') || {};
	(() => window.cicR = $$props.resetCicR ? 1 : window.cicR + 1)();
	const cic = window.cicR;
	let { settings = themeImports['settings'].find(e => e.component_index == fc$1(themeImports['settings'].map(e => e.component_index), cic, importsSeek)).value } = $$props;
	let { filled = themeImports['filled'].find(e => e.component_index == fc$1(themeImports['filled'].map(e => e.component_index), cic, importsSeek)).value } = $$props;
	let { outlined = themeImports['outlined'].find(e => e.component_index == fc$1(themeImports['outlined'].map(e => e.component_index), cic, importsSeek)).value } = $$props;
	let { button_classes = themeImports['button_classes'].find(e => e.component_index == fc$1(themeImports['button_classes'].map(e => e.component_index), cic, importsSeek)).value } = $$props;
	console.log('button classes ', button_classes);
	let { href } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('importsSeek' in $$new_props) $$invalidate(5, importsSeek = $$new_props.importsSeek);
		if ('settings' in $$new_props) $$invalidate(0, settings = $$new_props.settings);
		if ('filled' in $$new_props) $$invalidate(1, filled = $$new_props.filled);
		if ('outlined' in $$new_props) $$invalidate(2, outlined = $$new_props.outlined);
		if ('button_classes' in $$new_props) $$invalidate(3, button_classes = $$new_props.button_classes);
		if ('href' in $$new_props) $$invalidate(4, href = $$new_props.href);
		if ('$$scope' in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$props = exclude_internal_props($$props);
	return [settings, filled, outlined, button_classes, href, importsSeek, slots, $$scope];
}

class Button_1 extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			importsSeek: 5,
			settings: 0,
			filled: 1,
			outlined: 2,
			button_classes: 3,
			href: 4
		});
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/sections/slider-general/blocks/image-with-card.liquivelte generated by Svelte v3.50.0 */

function create_else_block$1(ctx) {
	let image;
	let current;

	image = new Image({
			props: {
				source: /*block*/ ctx[0].settings.image,
				sizes: "100vw@fixed",
				loading: "lazy"
			}
		});

	return {
		c() {
			create_component(image.$$.fragment);
		},
		l(nodes) {
			claim_component(image.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(image, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const image_changes = {};
			if (dirty & /*block*/ 1) image_changes.source = /*block*/ ctx[0].settings.image;
			image.$set(image_changes);
		},
		i(local) {
			if (current) return;
			transition_in(image.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(image.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(image, detaching);
		}
	};
}

// (36:0) {#if forloop.index == 1 }
function create_if_block_2$1(ctx) {
	let image;
	let current;

	image = new Image({
			props: {
				source: /*block*/ ctx[0].settings.image,
				sizes: "100vw@fixed",
				loading: "eager"
			}
		});

	return {
		c() {
			create_component(image.$$.fragment);
		},
		l(nodes) {
			claim_component(image.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(image, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const image_changes = {};
			if (dirty & /*block*/ 1) image_changes.source = /*block*/ ctx[0].settings.image;
			image.$set(image_changes);
		},
		i(local) {
			if (current) return;
			transition_in(image.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(image.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(image, detaching);
		}
	};
}

// (51:6) <H  type="h1" >
function create_default_slot_6(ctx) {
	let html_tag;
	let raw_value = (/*block*/ ctx[0].settings.card_title || '') + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTagHydration(false);
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_tag = claim_html_tag(nodes, false);
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_hydration(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*block*/ 1 && raw_value !== (raw_value = (/*block*/ ctx[0].settings.card_title || '') + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (52:6) <H  type="h2" >
function create_default_slot_5(ctx) {
	let html_tag;
	let raw_value = (/*block*/ ctx[0].settings.card_subtitle || '') + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTagHydration(false);
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_tag = claim_html_tag(nodes, false);
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_hydration(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*block*/ 1 && raw_value !== (raw_value = (/*block*/ ctx[0].settings.card_subtitle || '') + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (53:6) <P  >
function create_default_slot_4(ctx) {
	let html_tag;
	let raw_value = (/*block*/ ctx[0].settings.card_content || '') + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTagHydration(false);
			html_anchor = empty();
			this.h();
		},
		l(nodes) {
			html_tag = claim_html_tag(nodes, false);
			html_anchor = empty();
			this.h();
		},
		h() {
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert_hydration(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*block*/ 1 && raw_value !== (raw_value = (/*block*/ ctx[0].settings.card_content || '') + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) detach(html_anchor);
			if (detaching) html_tag.d();
		}
	};
}

// (56:6) {#if block.settings.cta_url }
function create_if_block_1$1(ctx) {
	let button;
	let current;

	button = new Button_1({
			props: {
				classes: "",
				href: /*block*/ ctx[0].settings.cta_url,
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		l(nodes) {
			claim_component(button.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*block*/ 1) button_changes.href = /*block*/ ctx[0].settings.cta_url;

			if (dirty & /*$$scope, block*/ 257) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (57:8) <Button  classes="" href="{ block.settings.cta_url }" >
function create_default_slot_3(ctx) {
	let t_value = /*block*/ ctx[0].settings.cta_text + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*block*/ 1 && t_value !== (t_value = /*block*/ ctx[0].settings.cta_text + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (59:6) {#if block.settings.cta_url_2 }
function create_if_block$1(ctx) {
	let button;
	let current;

	button = new Button_1({
			props: {
				classes: "",
				href: /*block*/ ctx[0].settings.cta_url_2,
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		l(nodes) {
			claim_component(button.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*block*/ 1) button_changes.href = /*block*/ ctx[0].settings.cta_url_2;

			if (dirty & /*$$scope, block*/ 257) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (60:8) <Button  classes="" href="{ block.settings.cta_url_2 }" >
function create_default_slot_2$1(ctx) {
	let t_value = /*block*/ ctx[0].settings.cta_text_2 + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		l(nodes) {
			t = claim_text(nodes, t_value);
		},
		m(target, anchor) {
			insert_hydration(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*block*/ 1 && t_value !== (t_value = /*block*/ ctx[0].settings.cta_text_2 + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (55:4) <ButtonGroup   >
function create_default_slot_1$1(ctx) {
	let t;
	let if_block1_anchor;
	let current;
	let if_block0 = /*block*/ ctx[0].settings.cta_url && create_if_block_1$1(ctx);
	let if_block1 = /*block*/ ctx[0].settings.cta_url_2 && create_if_block$1(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		l(nodes) {
			if (if_block0) if_block0.l(nodes);
			t = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*block*/ ctx[0].settings.cta_url) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*block*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*block*/ ctx[0].settings.cta_url_2) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*block*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (49:2) <Card  settings="{ block.settings }" >
function create_default_slot$1(ctx) {
	let div;
	let h0;
	let t0;
	let h1;
	let t1;
	let p;
	let t2;
	let buttongroup;
	let current;

	h0 = new H({
			props: {
				type: "h1",
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			}
		});

	h1 = new H({
			props: {
				type: "h2",
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			}
		});

	p = new P({
			props: {
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			}
		});

	buttongroup = new Button_group({
			props: {
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(h0.$$.fragment);
			t0 = space();
			create_component(h1.$$.fragment);
			t1 = space();
			create_component(p.$$.fragment);
			t2 = space();
			create_component(buttongroup.$$.fragment);
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(h0.$$.fragment, div_nodes);
			t0 = claim_space(div_nodes);
			claim_component(h1.$$.fragment, div_nodes);
			t1 = claim_space(div_nodes);
			claim_component(p.$$.fragment, div_nodes);
			div_nodes.forEach(detach);
			t2 = claim_space(nodes);
			claim_component(buttongroup.$$.fragment, nodes);
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			mount_component(h0, div, null);
			append_hydration(div, t0);
			mount_component(h1, div, null);
			append_hydration(div, t1);
			mount_component(p, div, null);
			insert_hydration(target, t2, anchor);
			mount_component(buttongroup, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const h0_changes = {};

			if (dirty & /*$$scope, block*/ 257) {
				h0_changes.$$scope = { dirty, ctx };
			}

			h0.$set(h0_changes);
			const h1_changes = {};

			if (dirty & /*$$scope, block*/ 257) {
				h1_changes.$$scope = { dirty, ctx };
			}

			h1.$set(h1_changes);
			const p_changes = {};

			if (dirty & /*$$scope, block*/ 257) {
				p_changes.$$scope = { dirty, ctx };
			}

			p.$set(p_changes);
			const buttongroup_changes = {};

			if (dirty & /*$$scope, block*/ 257) {
				buttongroup_changes.$$scope = { dirty, ctx };
			}

			buttongroup.$set(buttongroup_changes);
		},
		i(local) {
			if (current) return;
			transition_in(h0.$$.fragment, local);
			transition_in(h1.$$.fragment, local);
			transition_in(p.$$.fragment, local);
			transition_in(buttongroup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(h0.$$.fragment, local);
			transition_out(h1.$$.fragment, local);
			transition_out(p.$$.fragment, local);
			transition_out(buttongroup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(h0);
			destroy_component(h1);
			destroy_component(p);
			if (detaching) detach(t2);
			destroy_component(buttongroup, detaching);
		}
	};
}

function create_fragment$1(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let t;
	let card;
	let current;
	const if_block_creators = [create_if_block_2$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*forloop*/ ctx[1].index == 1) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	card = new Card({
			props: {
				settings: /*block*/ ctx[0].settings,
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			if_block.c();
			t = space();
			create_component(card.$$.fragment);
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if_block.l(div_nodes);
			t = claim_space(div_nodes);
			claim_component(card.$$.fragment, div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "relative");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			append_hydration(div, t);
			mount_component(card, div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, t);
			}

			const card_changes = {};
			if (dirty & /*block*/ 1) card_changes.settings = /*block*/ ctx[0].settings;

			if (dirty & /*$$scope, block*/ 257) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
			destroy_component(card);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { importsSeek = 'lower' } = $$props;
	getContext('svelteProps') || {};
	getContext('lec') || {};
	(() => window.cicR = $$props.resetCicR ? 1 : window.cicR + 1)();
	let { block } = $$props;
	let { forloop } = $$props;

	onMount(() => {
		console.log('mounted', block);
		tick();
	});

	console.log('block w/ card', block);

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('importsSeek' in $$new_props) $$invalidate(2, importsSeek = $$new_props.importsSeek);
		if ('block' in $$new_props) $$invalidate(0, block = $$new_props.block);
		if ('forloop' in $$new_props) $$invalidate(1, forloop = $$new_props.forloop);
	};

	$$props = exclude_internal_props($$props);
	return [block, forloop, importsSeek];
}

class Image_with_card extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { importsSeek: 2, block: 0, forloop: 1 });
	}
}

/* Usersmalipetek/Documents/Documents/Projects/LIQUVELTE/LIQUIVELTE TEST/src/sections/slider-general/index.liquivelte generated by Svelte v3.50.0 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	child_ctx[14] = i;

	const constants_0 = {
		first: /*index*/ child_ctx[14] === 0,
		index: /*index*/ child_ctx[14] + 1,
		index0: /*index*/ child_ctx[14],
		last: /*index*/ child_ctx[14] === /*section*/ child_ctx[0].blocks.length - 1,
		rindex: /*section*/ child_ctx[0].blocks.length - /*index*/ child_ctx[14],
		rindex0: /*section*/ child_ctx[0].blocks.length - /*index*/ child_ctx[14] - 1,
		length: /*section*/ child_ctx[0].blocks.length
	};

	child_ctx[12] = constants_0;
	return child_ctx;
}

// (33:2) {#if section.settings.flush_with_header }
function create_if_block_3(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "flush-shadow");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (69:43) 
function create_if_block_2(ctx) {
	let swiperslide;
	let current;

	swiperslide = new Swiper_slide({
			props: {
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(swiperslide.$$.fragment);
		},
		l(nodes) {
			claim_component(swiperslide.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(swiperslide, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const swiperslide_changes = {};

			if (dirty & /*$$scope, section*/ 32769) {
				swiperslide_changes.$$scope = { dirty, ctx };
			}

			swiperslide.$set(swiperslide_changes);
		},
		i(local) {
			if (current) return;
			transition_in(swiperslide.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(swiperslide.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(swiperslide, detaching);
		}
	};
}

// (52:6) {#if block.type == 'image' }
function create_if_block(ctx) {
	let swiperslide;
	let current;

	swiperslide = new Swiper_slide({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(swiperslide.$$.fragment);
		},
		l(nodes) {
			claim_component(swiperslide.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(swiperslide, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const swiperslide_changes = {};

			if (dirty & /*$$scope, section*/ 32769) {
				swiperslide_changes.$$scope = { dirty, ctx };
			}

			swiperslide.$set(swiperslide_changes);
		},
		i(local) {
			if (current) return;
			transition_in(swiperslide.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(swiperslide.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(swiperslide, detaching);
		}
	};
}

// (70:8) <SwiperSlide   >
function create_default_slot_2(ctx) {
	let imagewithcard;
	let t;
	let current;

	imagewithcard = new Image_with_card({
			props: {
				block: /*block*/ ctx[11],
				forloop: /*forloop*/ ctx[12]
			}
		});

	return {
		c() {
			create_component(imagewithcard.$$.fragment);
			t = space();
		},
		l(nodes) {
			claim_component(imagewithcard.$$.fragment, nodes);
			t = claim_space(nodes);
		},
		m(target, anchor) {
			mount_component(imagewithcard, target, anchor);
			insert_hydration(target, t, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const imagewithcard_changes = {};
			if (dirty & /*section*/ 1) imagewithcard_changes.block = /*block*/ ctx[11];
			if (dirty & /*section*/ 1) imagewithcard_changes.forloop = /*forloop*/ ctx[12];
			imagewithcard.$set(imagewithcard_changes);
		},
		i(local) {
			if (current) return;
			transition_in(imagewithcard.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(imagewithcard.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(imagewithcard, detaching);
			if (detaching) detach(t);
		}
	};
}

// (60:10) {:else}
function create_else_block(ctx) {
	let image;
	let current;

	image = new Image({
			props: {
				source: /*block*/ ctx[11].settings.image,
				sizes: "100vw@fixed",
				loading: "lazy"
			}
		});

	return {
		c() {
			create_component(image.$$.fragment);
		},
		l(nodes) {
			claim_component(image.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(image, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const image_changes = {};
			if (dirty & /*section*/ 1) image_changes.source = /*block*/ ctx[11].settings.image;
			image.$set(image_changes);
		},
		i(local) {
			if (current) return;
			transition_in(image.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(image.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(image, detaching);
		}
	};
}

// (54:10) {#if forloop.index == 1 }
function create_if_block_1(ctx) {
	let image;
	let current;

	image = new Image({
			props: {
				source: /*block*/ ctx[11].settings.image,
				sizes: "100vw@fixed",
				loading: "eager"
			}
		});

	return {
		c() {
			create_component(image.$$.fragment);
		},
		l(nodes) {
			claim_component(image.$$.fragment, nodes);
		},
		m(target, anchor) {
			mount_component(image, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const image_changes = {};
			if (dirty & /*section*/ 1) image_changes.source = /*block*/ ctx[11].settings.image;
			image.$set(image_changes);
		},
		i(local) {
			if (current) return;
			transition_in(image.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(image.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(image, detaching);
		}
	};
}

// (53:8) <SwiperSlide   >
function create_default_slot_1(ctx) {
	let current_block_type_index;
	let if_block;
	let t;
	let current;
	const if_block_creators = [create_if_block_1, create_else_block];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*forloop*/ ctx[12].index == 1) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			t = space();
		},
		l(nodes) {
			if_block.l(nodes);
			t = claim_space(nodes);
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration(target, t, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(t.parentNode, t);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(t);
		}
	};
}

// (42:4) {#each  section.blocks as block, index   }
function create_each_block(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_if_block_2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*block*/ ctx[11].type == 'image') return 0;
		if (/*block*/ ctx[11].type == 'image-card') return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_hydration(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach(if_block_anchor);
		}
	};
}

// (37:2) <Swiper  freemode="{ { enabled: true, sticky: true } }"            mousewheel="{ { forceToAxis: true, sensitivity: 1.5 } }"           modules="{[FreeMode, Mousewheel]}"            preloadImages="{false}"          >
function create_default_slot(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*section*/ ctx[0].blocks;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_hydration(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*section*/ 1) {
				each_value = /*section*/ ctx[0].blocks;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let t;
	let swiper;
	let current;
	let if_block = /*section*/ ctx[0].settings.flush_with_header && create_if_block_3();

	swiper = new Swiper_1({
			props: {
				freemode: { enabled: true, sticky: true },
				mousewheel: { forceToAxis: true, sensitivity: 1.5 },
				modules: [freeMode, Mousewheel],
				preloadImages: false,
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			create_component(swiper.$$.fragment);
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			claim_component(swiper.$$.fragment, div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "relative");
		},
		m(target, anchor) {
			insert_hydration(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_hydration(div, t);
			mount_component(swiper, div, null);
			/*div_binding*/ ctx[5](div);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*section*/ ctx[0].settings.flush_with_header) {
				if (if_block) ; else {
					if_block = create_if_block_3();
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			const swiper_changes = {};

			if (dirty & /*$$scope, section*/ 32769) {
				swiper_changes.$$scope = { dirty, ctx };
			}

			swiper.$set(swiper_changes);
		},
		i(local) {
			if (current) return;
			transition_in(swiper.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(swiper.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			destroy_component(swiper);
			/*div_binding*/ ctx[5](null);
		}
	};
}

function fc(e, t, r) {
	const n = e.find(e => e === t);

	return n || e.reduce((e, n) => {
		let o = Math.abs(e - t), i = Math.abs(n - t);

		return "higher" === r
		? n > t && i <= o ? n : e
		: "lower" === r ? n < t && i <= o ? n : e : void 0;
	});
}

function instance($$self, $$props, $$invalidate) {
	let { importsSeek = 'lower' } = $$props;
	let themeImports = getContext('svelteProps') || {};
	getContext('lec') || {};
	(() => window.cicR = $$props.resetCicR ? 1 : window.cicR + 1)();
	const cic = window.cicR;
	const section = {};
	let { sectionsettings } = $$props;

	try {
		section = section || {};
	} catch(e) {
		
	} /*whatever*/

	section.settings = themeImports['sectionsettings'].find(e => e.component_index == fc(themeImports['sectionsettings'].map(e => e.component_index), cic, importsSeek)).value;
	let { sectionblocks } = $$props;

	try {
		section = section || {};
	} catch(e) {
		
	} /*whatever*/

	section.blocks = themeImports['sectionblocks'].find(e => e.component_index == fc(themeImports['sectionblocks'].map(e => e.component_index), cic, importsSeek)).value;
	let container;

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			container = $$value;
			$$invalidate(1, container);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ('importsSeek' in $$new_props) $$invalidate(2, importsSeek = $$new_props.importsSeek);
		if ('sectionsettings' in $$new_props) $$invalidate(3, sectionsettings = $$new_props.sectionsettings);
		if ('sectionblocks' in $$new_props) $$invalidate(4, sectionblocks = $$new_props.sectionblocks);
	};

	$$props = exclude_internal_props($$props);

	return [
		section,
		container,
		importsSeek,
		sectionsettings,
		sectionblocks,
		div_binding
	];
}

class Slider_general extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			importsSeek: 2,
			sectionsettings: 3,
			sectionblocks: 4
		});
	}
}

export { Slider_general as default };
